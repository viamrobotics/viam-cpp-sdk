// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: service/vision/v1/vision.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_service_2fvision_2fv1_2fvision_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_service_2fvision_2fv1_2fvision_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "common/v1/common.pb.h"
#include "google/api/annotations.pb.h"
#include <google/protobuf/struct.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_service_2fvision_2fv1_2fvision_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_service_2fvision_2fv1_2fvision_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_service_2fvision_2fv1_2fvision_2eproto;
namespace viam {
namespace service {
namespace vision {
namespace v1 {
class AddClassifierRequest;
struct AddClassifierRequestDefaultTypeInternal;
extern AddClassifierRequestDefaultTypeInternal _AddClassifierRequest_default_instance_;
class AddClassifierResponse;
struct AddClassifierResponseDefaultTypeInternal;
extern AddClassifierResponseDefaultTypeInternal _AddClassifierResponse_default_instance_;
class AddDetectorRequest;
struct AddDetectorRequestDefaultTypeInternal;
extern AddDetectorRequestDefaultTypeInternal _AddDetectorRequest_default_instance_;
class AddDetectorResponse;
struct AddDetectorResponseDefaultTypeInternal;
extern AddDetectorResponseDefaultTypeInternal _AddDetectorResponse_default_instance_;
class AddSegmenterRequest;
struct AddSegmenterRequestDefaultTypeInternal;
extern AddSegmenterRequestDefaultTypeInternal _AddSegmenterRequest_default_instance_;
class AddSegmenterResponse;
struct AddSegmenterResponseDefaultTypeInternal;
extern AddSegmenterResponseDefaultTypeInternal _AddSegmenterResponse_default_instance_;
class Classification;
struct ClassificationDefaultTypeInternal;
extern ClassificationDefaultTypeInternal _Classification_default_instance_;
class Detection;
struct DetectionDefaultTypeInternal;
extern DetectionDefaultTypeInternal _Detection_default_instance_;
class GetClassificationsFromCameraRequest;
struct GetClassificationsFromCameraRequestDefaultTypeInternal;
extern GetClassificationsFromCameraRequestDefaultTypeInternal _GetClassificationsFromCameraRequest_default_instance_;
class GetClassificationsFromCameraResponse;
struct GetClassificationsFromCameraResponseDefaultTypeInternal;
extern GetClassificationsFromCameraResponseDefaultTypeInternal _GetClassificationsFromCameraResponse_default_instance_;
class GetClassificationsRequest;
struct GetClassificationsRequestDefaultTypeInternal;
extern GetClassificationsRequestDefaultTypeInternal _GetClassificationsRequest_default_instance_;
class GetClassificationsResponse;
struct GetClassificationsResponseDefaultTypeInternal;
extern GetClassificationsResponseDefaultTypeInternal _GetClassificationsResponse_default_instance_;
class GetClassifierNamesRequest;
struct GetClassifierNamesRequestDefaultTypeInternal;
extern GetClassifierNamesRequestDefaultTypeInternal _GetClassifierNamesRequest_default_instance_;
class GetClassifierNamesResponse;
struct GetClassifierNamesResponseDefaultTypeInternal;
extern GetClassifierNamesResponseDefaultTypeInternal _GetClassifierNamesResponse_default_instance_;
class GetDetectionsFromCameraRequest;
struct GetDetectionsFromCameraRequestDefaultTypeInternal;
extern GetDetectionsFromCameraRequestDefaultTypeInternal _GetDetectionsFromCameraRequest_default_instance_;
class GetDetectionsFromCameraResponse;
struct GetDetectionsFromCameraResponseDefaultTypeInternal;
extern GetDetectionsFromCameraResponseDefaultTypeInternal _GetDetectionsFromCameraResponse_default_instance_;
class GetDetectionsRequest;
struct GetDetectionsRequestDefaultTypeInternal;
extern GetDetectionsRequestDefaultTypeInternal _GetDetectionsRequest_default_instance_;
class GetDetectionsResponse;
struct GetDetectionsResponseDefaultTypeInternal;
extern GetDetectionsResponseDefaultTypeInternal _GetDetectionsResponse_default_instance_;
class GetDetectorNamesRequest;
struct GetDetectorNamesRequestDefaultTypeInternal;
extern GetDetectorNamesRequestDefaultTypeInternal _GetDetectorNamesRequest_default_instance_;
class GetDetectorNamesResponse;
struct GetDetectorNamesResponseDefaultTypeInternal;
extern GetDetectorNamesResponseDefaultTypeInternal _GetDetectorNamesResponse_default_instance_;
class GetModelParameterSchemaRequest;
struct GetModelParameterSchemaRequestDefaultTypeInternal;
extern GetModelParameterSchemaRequestDefaultTypeInternal _GetModelParameterSchemaRequest_default_instance_;
class GetModelParameterSchemaResponse;
struct GetModelParameterSchemaResponseDefaultTypeInternal;
extern GetModelParameterSchemaResponseDefaultTypeInternal _GetModelParameterSchemaResponse_default_instance_;
class GetObjectPointCloudsRequest;
struct GetObjectPointCloudsRequestDefaultTypeInternal;
extern GetObjectPointCloudsRequestDefaultTypeInternal _GetObjectPointCloudsRequest_default_instance_;
class GetObjectPointCloudsResponse;
struct GetObjectPointCloudsResponseDefaultTypeInternal;
extern GetObjectPointCloudsResponseDefaultTypeInternal _GetObjectPointCloudsResponse_default_instance_;
class GetSegmenterNamesRequest;
struct GetSegmenterNamesRequestDefaultTypeInternal;
extern GetSegmenterNamesRequestDefaultTypeInternal _GetSegmenterNamesRequest_default_instance_;
class GetSegmenterNamesResponse;
struct GetSegmenterNamesResponseDefaultTypeInternal;
extern GetSegmenterNamesResponseDefaultTypeInternal _GetSegmenterNamesResponse_default_instance_;
class RemoveClassifierRequest;
struct RemoveClassifierRequestDefaultTypeInternal;
extern RemoveClassifierRequestDefaultTypeInternal _RemoveClassifierRequest_default_instance_;
class RemoveClassifierResponse;
struct RemoveClassifierResponseDefaultTypeInternal;
extern RemoveClassifierResponseDefaultTypeInternal _RemoveClassifierResponse_default_instance_;
class RemoveDetectorRequest;
struct RemoveDetectorRequestDefaultTypeInternal;
extern RemoveDetectorRequestDefaultTypeInternal _RemoveDetectorRequest_default_instance_;
class RemoveDetectorResponse;
struct RemoveDetectorResponseDefaultTypeInternal;
extern RemoveDetectorResponseDefaultTypeInternal _RemoveDetectorResponse_default_instance_;
class RemoveSegmenterRequest;
struct RemoveSegmenterRequestDefaultTypeInternal;
extern RemoveSegmenterRequestDefaultTypeInternal _RemoveSegmenterRequest_default_instance_;
class RemoveSegmenterResponse;
struct RemoveSegmenterResponseDefaultTypeInternal;
extern RemoveSegmenterResponseDefaultTypeInternal _RemoveSegmenterResponse_default_instance_;
}  // namespace v1
}  // namespace vision
}  // namespace service
}  // namespace viam
PROTOBUF_NAMESPACE_OPEN
template<> ::viam::service::vision::v1::AddClassifierRequest* Arena::CreateMaybeMessage<::viam::service::vision::v1::AddClassifierRequest>(Arena*);
template<> ::viam::service::vision::v1::AddClassifierResponse* Arena::CreateMaybeMessage<::viam::service::vision::v1::AddClassifierResponse>(Arena*);
template<> ::viam::service::vision::v1::AddDetectorRequest* Arena::CreateMaybeMessage<::viam::service::vision::v1::AddDetectorRequest>(Arena*);
template<> ::viam::service::vision::v1::AddDetectorResponse* Arena::CreateMaybeMessage<::viam::service::vision::v1::AddDetectorResponse>(Arena*);
template<> ::viam::service::vision::v1::AddSegmenterRequest* Arena::CreateMaybeMessage<::viam::service::vision::v1::AddSegmenterRequest>(Arena*);
template<> ::viam::service::vision::v1::AddSegmenterResponse* Arena::CreateMaybeMessage<::viam::service::vision::v1::AddSegmenterResponse>(Arena*);
template<> ::viam::service::vision::v1::Classification* Arena::CreateMaybeMessage<::viam::service::vision::v1::Classification>(Arena*);
template<> ::viam::service::vision::v1::Detection* Arena::CreateMaybeMessage<::viam::service::vision::v1::Detection>(Arena*);
template<> ::viam::service::vision::v1::GetClassificationsFromCameraRequest* Arena::CreateMaybeMessage<::viam::service::vision::v1::GetClassificationsFromCameraRequest>(Arena*);
template<> ::viam::service::vision::v1::GetClassificationsFromCameraResponse* Arena::CreateMaybeMessage<::viam::service::vision::v1::GetClassificationsFromCameraResponse>(Arena*);
template<> ::viam::service::vision::v1::GetClassificationsRequest* Arena::CreateMaybeMessage<::viam::service::vision::v1::GetClassificationsRequest>(Arena*);
template<> ::viam::service::vision::v1::GetClassificationsResponse* Arena::CreateMaybeMessage<::viam::service::vision::v1::GetClassificationsResponse>(Arena*);
template<> ::viam::service::vision::v1::GetClassifierNamesRequest* Arena::CreateMaybeMessage<::viam::service::vision::v1::GetClassifierNamesRequest>(Arena*);
template<> ::viam::service::vision::v1::GetClassifierNamesResponse* Arena::CreateMaybeMessage<::viam::service::vision::v1::GetClassifierNamesResponse>(Arena*);
template<> ::viam::service::vision::v1::GetDetectionsFromCameraRequest* Arena::CreateMaybeMessage<::viam::service::vision::v1::GetDetectionsFromCameraRequest>(Arena*);
template<> ::viam::service::vision::v1::GetDetectionsFromCameraResponse* Arena::CreateMaybeMessage<::viam::service::vision::v1::GetDetectionsFromCameraResponse>(Arena*);
template<> ::viam::service::vision::v1::GetDetectionsRequest* Arena::CreateMaybeMessage<::viam::service::vision::v1::GetDetectionsRequest>(Arena*);
template<> ::viam::service::vision::v1::GetDetectionsResponse* Arena::CreateMaybeMessage<::viam::service::vision::v1::GetDetectionsResponse>(Arena*);
template<> ::viam::service::vision::v1::GetDetectorNamesRequest* Arena::CreateMaybeMessage<::viam::service::vision::v1::GetDetectorNamesRequest>(Arena*);
template<> ::viam::service::vision::v1::GetDetectorNamesResponse* Arena::CreateMaybeMessage<::viam::service::vision::v1::GetDetectorNamesResponse>(Arena*);
template<> ::viam::service::vision::v1::GetModelParameterSchemaRequest* Arena::CreateMaybeMessage<::viam::service::vision::v1::GetModelParameterSchemaRequest>(Arena*);
template<> ::viam::service::vision::v1::GetModelParameterSchemaResponse* Arena::CreateMaybeMessage<::viam::service::vision::v1::GetModelParameterSchemaResponse>(Arena*);
template<> ::viam::service::vision::v1::GetObjectPointCloudsRequest* Arena::CreateMaybeMessage<::viam::service::vision::v1::GetObjectPointCloudsRequest>(Arena*);
template<> ::viam::service::vision::v1::GetObjectPointCloudsResponse* Arena::CreateMaybeMessage<::viam::service::vision::v1::GetObjectPointCloudsResponse>(Arena*);
template<> ::viam::service::vision::v1::GetSegmenterNamesRequest* Arena::CreateMaybeMessage<::viam::service::vision::v1::GetSegmenterNamesRequest>(Arena*);
template<> ::viam::service::vision::v1::GetSegmenterNamesResponse* Arena::CreateMaybeMessage<::viam::service::vision::v1::GetSegmenterNamesResponse>(Arena*);
template<> ::viam::service::vision::v1::RemoveClassifierRequest* Arena::CreateMaybeMessage<::viam::service::vision::v1::RemoveClassifierRequest>(Arena*);
template<> ::viam::service::vision::v1::RemoveClassifierResponse* Arena::CreateMaybeMessage<::viam::service::vision::v1::RemoveClassifierResponse>(Arena*);
template<> ::viam::service::vision::v1::RemoveDetectorRequest* Arena::CreateMaybeMessage<::viam::service::vision::v1::RemoveDetectorRequest>(Arena*);
template<> ::viam::service::vision::v1::RemoveDetectorResponse* Arena::CreateMaybeMessage<::viam::service::vision::v1::RemoveDetectorResponse>(Arena*);
template<> ::viam::service::vision::v1::RemoveSegmenterRequest* Arena::CreateMaybeMessage<::viam::service::vision::v1::RemoveSegmenterRequest>(Arena*);
template<> ::viam::service::vision::v1::RemoveSegmenterResponse* Arena::CreateMaybeMessage<::viam::service::vision::v1::RemoveSegmenterResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace viam {
namespace service {
namespace vision {
namespace v1 {

// ===================================================================

class GetModelParameterSchemaRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.service.vision.v1.GetModelParameterSchemaRequest) */ {
 public:
  inline GetModelParameterSchemaRequest() : GetModelParameterSchemaRequest(nullptr) {}
  ~GetModelParameterSchemaRequest() override;
  explicit PROTOBUF_CONSTEXPR GetModelParameterSchemaRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetModelParameterSchemaRequest(const GetModelParameterSchemaRequest& from);
  GetModelParameterSchemaRequest(GetModelParameterSchemaRequest&& from) noexcept
    : GetModelParameterSchemaRequest() {
    *this = ::std::move(from);
  }

  inline GetModelParameterSchemaRequest& operator=(const GetModelParameterSchemaRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetModelParameterSchemaRequest& operator=(GetModelParameterSchemaRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetModelParameterSchemaRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetModelParameterSchemaRequest* internal_default_instance() {
    return reinterpret_cast<const GetModelParameterSchemaRequest*>(
               &_GetModelParameterSchemaRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(GetModelParameterSchemaRequest& a, GetModelParameterSchemaRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetModelParameterSchemaRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetModelParameterSchemaRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetModelParameterSchemaRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetModelParameterSchemaRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetModelParameterSchemaRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetModelParameterSchemaRequest& from) {
    GetModelParameterSchemaRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetModelParameterSchemaRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.service.vision.v1.GetModelParameterSchemaRequest";
  }
  protected:
  explicit GetModelParameterSchemaRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kModelTypeFieldNumber = 2,
    kExtraFieldNumber = 99,
  };
  // string name = 1 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string model_type = 2 [json_name = "modelType"];
  void clear_model_type();
  const std::string& model_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model_type();
  PROTOBUF_NODISCARD std::string* release_model_type();
  void set_allocated_model_type(std::string* model_type);
  private:
  const std::string& _internal_model_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_type(const std::string& value);
  std::string* _internal_mutable_model_type();
  public:

  // .google.protobuf.Struct extra = 99 [json_name = "extra"];
  bool has_extra() const;
  private:
  bool _internal_has_extra() const;
  public:
  void clear_extra();
  const ::PROTOBUF_NAMESPACE_ID::Struct& extra() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_extra();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_extra();
  void set_allocated_extra(::PROTOBUF_NAMESPACE_ID::Struct* extra);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_extra() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_extra();
  public:
  void unsafe_arena_set_allocated_extra(
      ::PROTOBUF_NAMESPACE_ID::Struct* extra);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_extra();

  // @@protoc_insertion_point(class_scope:viam.service.vision.v1.GetModelParameterSchemaRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_type_;
    ::PROTOBUF_NAMESPACE_ID::Struct* extra_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2fvision_2fv1_2fvision_2eproto;
};
// -------------------------------------------------------------------

class GetModelParameterSchemaResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.service.vision.v1.GetModelParameterSchemaResponse) */ {
 public:
  inline GetModelParameterSchemaResponse() : GetModelParameterSchemaResponse(nullptr) {}
  ~GetModelParameterSchemaResponse() override;
  explicit PROTOBUF_CONSTEXPR GetModelParameterSchemaResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetModelParameterSchemaResponse(const GetModelParameterSchemaResponse& from);
  GetModelParameterSchemaResponse(GetModelParameterSchemaResponse&& from) noexcept
    : GetModelParameterSchemaResponse() {
    *this = ::std::move(from);
  }

  inline GetModelParameterSchemaResponse& operator=(const GetModelParameterSchemaResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetModelParameterSchemaResponse& operator=(GetModelParameterSchemaResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetModelParameterSchemaResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetModelParameterSchemaResponse* internal_default_instance() {
    return reinterpret_cast<const GetModelParameterSchemaResponse*>(
               &_GetModelParameterSchemaResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(GetModelParameterSchemaResponse& a, GetModelParameterSchemaResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetModelParameterSchemaResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetModelParameterSchemaResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetModelParameterSchemaResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetModelParameterSchemaResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetModelParameterSchemaResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetModelParameterSchemaResponse& from) {
    GetModelParameterSchemaResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetModelParameterSchemaResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.service.vision.v1.GetModelParameterSchemaResponse";
  }
  protected:
  explicit GetModelParameterSchemaResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelParameterSchemaFieldNumber = 1,
  };
  // bytes model_parameter_schema = 1 [json_name = "modelParameterSchema"];
  void clear_model_parameter_schema();
  const std::string& model_parameter_schema() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model_parameter_schema(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model_parameter_schema();
  PROTOBUF_NODISCARD std::string* release_model_parameter_schema();
  void set_allocated_model_parameter_schema(std::string* model_parameter_schema);
  private:
  const std::string& _internal_model_parameter_schema() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_parameter_schema(const std::string& value);
  std::string* _internal_mutable_model_parameter_schema();
  public:

  // @@protoc_insertion_point(class_scope:viam.service.vision.v1.GetModelParameterSchemaResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_parameter_schema_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2fvision_2fv1_2fvision_2eproto;
};
// -------------------------------------------------------------------

class GetDetectorNamesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.service.vision.v1.GetDetectorNamesRequest) */ {
 public:
  inline GetDetectorNamesRequest() : GetDetectorNamesRequest(nullptr) {}
  ~GetDetectorNamesRequest() override;
  explicit PROTOBUF_CONSTEXPR GetDetectorNamesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetDetectorNamesRequest(const GetDetectorNamesRequest& from);
  GetDetectorNamesRequest(GetDetectorNamesRequest&& from) noexcept
    : GetDetectorNamesRequest() {
    *this = ::std::move(from);
  }

  inline GetDetectorNamesRequest& operator=(const GetDetectorNamesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetDetectorNamesRequest& operator=(GetDetectorNamesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetDetectorNamesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetDetectorNamesRequest* internal_default_instance() {
    return reinterpret_cast<const GetDetectorNamesRequest*>(
               &_GetDetectorNamesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(GetDetectorNamesRequest& a, GetDetectorNamesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetDetectorNamesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetDetectorNamesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetDetectorNamesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetDetectorNamesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetDetectorNamesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetDetectorNamesRequest& from) {
    GetDetectorNamesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetDetectorNamesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.service.vision.v1.GetDetectorNamesRequest";
  }
  protected:
  explicit GetDetectorNamesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kExtraFieldNumber = 99,
  };
  // string name = 1 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .google.protobuf.Struct extra = 99 [json_name = "extra"];
  bool has_extra() const;
  private:
  bool _internal_has_extra() const;
  public:
  void clear_extra();
  const ::PROTOBUF_NAMESPACE_ID::Struct& extra() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_extra();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_extra();
  void set_allocated_extra(::PROTOBUF_NAMESPACE_ID::Struct* extra);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_extra() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_extra();
  public:
  void unsafe_arena_set_allocated_extra(
      ::PROTOBUF_NAMESPACE_ID::Struct* extra);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_extra();

  // @@protoc_insertion_point(class_scope:viam.service.vision.v1.GetDetectorNamesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::Struct* extra_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2fvision_2fv1_2fvision_2eproto;
};
// -------------------------------------------------------------------

class GetDetectorNamesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.service.vision.v1.GetDetectorNamesResponse) */ {
 public:
  inline GetDetectorNamesResponse() : GetDetectorNamesResponse(nullptr) {}
  ~GetDetectorNamesResponse() override;
  explicit PROTOBUF_CONSTEXPR GetDetectorNamesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetDetectorNamesResponse(const GetDetectorNamesResponse& from);
  GetDetectorNamesResponse(GetDetectorNamesResponse&& from) noexcept
    : GetDetectorNamesResponse() {
    *this = ::std::move(from);
  }

  inline GetDetectorNamesResponse& operator=(const GetDetectorNamesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetDetectorNamesResponse& operator=(GetDetectorNamesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetDetectorNamesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetDetectorNamesResponse* internal_default_instance() {
    return reinterpret_cast<const GetDetectorNamesResponse*>(
               &_GetDetectorNamesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(GetDetectorNamesResponse& a, GetDetectorNamesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetDetectorNamesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetDetectorNamesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetDetectorNamesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetDetectorNamesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetDetectorNamesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetDetectorNamesResponse& from) {
    GetDetectorNamesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetDetectorNamesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.service.vision.v1.GetDetectorNamesResponse";
  }
  protected:
  explicit GetDetectorNamesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDetectorNamesFieldNumber = 1,
  };
  // repeated string detector_names = 1 [json_name = "detectorNames"];
  int detector_names_size() const;
  private:
  int _internal_detector_names_size() const;
  public:
  void clear_detector_names();
  const std::string& detector_names(int index) const;
  std::string* mutable_detector_names(int index);
  void set_detector_names(int index, const std::string& value);
  void set_detector_names(int index, std::string&& value);
  void set_detector_names(int index, const char* value);
  void set_detector_names(int index, const char* value, size_t size);
  std::string* add_detector_names();
  void add_detector_names(const std::string& value);
  void add_detector_names(std::string&& value);
  void add_detector_names(const char* value);
  void add_detector_names(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& detector_names() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_detector_names();
  private:
  const std::string& _internal_detector_names(int index) const;
  std::string* _internal_add_detector_names();
  public:

  // @@protoc_insertion_point(class_scope:viam.service.vision.v1.GetDetectorNamesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> detector_names_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2fvision_2fv1_2fvision_2eproto;
};
// -------------------------------------------------------------------

class AddDetectorRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.service.vision.v1.AddDetectorRequest) */ {
 public:
  inline AddDetectorRequest() : AddDetectorRequest(nullptr) {}
  ~AddDetectorRequest() override;
  explicit PROTOBUF_CONSTEXPR AddDetectorRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddDetectorRequest(const AddDetectorRequest& from);
  AddDetectorRequest(AddDetectorRequest&& from) noexcept
    : AddDetectorRequest() {
    *this = ::std::move(from);
  }

  inline AddDetectorRequest& operator=(const AddDetectorRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddDetectorRequest& operator=(AddDetectorRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddDetectorRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddDetectorRequest* internal_default_instance() {
    return reinterpret_cast<const AddDetectorRequest*>(
               &_AddDetectorRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(AddDetectorRequest& a, AddDetectorRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AddDetectorRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddDetectorRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddDetectorRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddDetectorRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddDetectorRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AddDetectorRequest& from) {
    AddDetectorRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddDetectorRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.service.vision.v1.AddDetectorRequest";
  }
  protected:
  explicit AddDetectorRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDetectorNameFieldNumber = 2,
    kDetectorModelTypeFieldNumber = 3,
    kDetectorParametersFieldNumber = 4,
    kExtraFieldNumber = 99,
  };
  // string name = 1 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string detector_name = 2 [json_name = "detectorName"];
  void clear_detector_name();
  const std::string& detector_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_detector_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_detector_name();
  PROTOBUF_NODISCARD std::string* release_detector_name();
  void set_allocated_detector_name(std::string* detector_name);
  private:
  const std::string& _internal_detector_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_detector_name(const std::string& value);
  std::string* _internal_mutable_detector_name();
  public:

  // string detector_model_type = 3 [json_name = "detectorModelType"];
  void clear_detector_model_type();
  const std::string& detector_model_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_detector_model_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_detector_model_type();
  PROTOBUF_NODISCARD std::string* release_detector_model_type();
  void set_allocated_detector_model_type(std::string* detector_model_type);
  private:
  const std::string& _internal_detector_model_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_detector_model_type(const std::string& value);
  std::string* _internal_mutable_detector_model_type();
  public:

  // .google.protobuf.Struct detector_parameters = 4 [json_name = "detectorParameters"];
  bool has_detector_parameters() const;
  private:
  bool _internal_has_detector_parameters() const;
  public:
  void clear_detector_parameters();
  const ::PROTOBUF_NAMESPACE_ID::Struct& detector_parameters() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_detector_parameters();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_detector_parameters();
  void set_allocated_detector_parameters(::PROTOBUF_NAMESPACE_ID::Struct* detector_parameters);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_detector_parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_detector_parameters();
  public:
  void unsafe_arena_set_allocated_detector_parameters(
      ::PROTOBUF_NAMESPACE_ID::Struct* detector_parameters);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_detector_parameters();

  // .google.protobuf.Struct extra = 99 [json_name = "extra"];
  bool has_extra() const;
  private:
  bool _internal_has_extra() const;
  public:
  void clear_extra();
  const ::PROTOBUF_NAMESPACE_ID::Struct& extra() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_extra();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_extra();
  void set_allocated_extra(::PROTOBUF_NAMESPACE_ID::Struct* extra);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_extra() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_extra();
  public:
  void unsafe_arena_set_allocated_extra(
      ::PROTOBUF_NAMESPACE_ID::Struct* extra);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_extra();

  // @@protoc_insertion_point(class_scope:viam.service.vision.v1.AddDetectorRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr detector_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr detector_model_type_;
    ::PROTOBUF_NAMESPACE_ID::Struct* detector_parameters_;
    ::PROTOBUF_NAMESPACE_ID::Struct* extra_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2fvision_2fv1_2fvision_2eproto;
};
// -------------------------------------------------------------------

class AddDetectorResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.service.vision.v1.AddDetectorResponse) */ {
 public:
  inline AddDetectorResponse() : AddDetectorResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR AddDetectorResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddDetectorResponse(const AddDetectorResponse& from);
  AddDetectorResponse(AddDetectorResponse&& from) noexcept
    : AddDetectorResponse() {
    *this = ::std::move(from);
  }

  inline AddDetectorResponse& operator=(const AddDetectorResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddDetectorResponse& operator=(AddDetectorResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddDetectorResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddDetectorResponse* internal_default_instance() {
    return reinterpret_cast<const AddDetectorResponse*>(
               &_AddDetectorResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(AddDetectorResponse& a, AddDetectorResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AddDetectorResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddDetectorResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddDetectorResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddDetectorResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const AddDetectorResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const AddDetectorResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.service.vision.v1.AddDetectorResponse";
  }
  protected:
  explicit AddDetectorResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.service.vision.v1.AddDetectorResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_service_2fvision_2fv1_2fvision_2eproto;
};
// -------------------------------------------------------------------

class RemoveDetectorRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.service.vision.v1.RemoveDetectorRequest) */ {
 public:
  inline RemoveDetectorRequest() : RemoveDetectorRequest(nullptr) {}
  ~RemoveDetectorRequest() override;
  explicit PROTOBUF_CONSTEXPR RemoveDetectorRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RemoveDetectorRequest(const RemoveDetectorRequest& from);
  RemoveDetectorRequest(RemoveDetectorRequest&& from) noexcept
    : RemoveDetectorRequest() {
    *this = ::std::move(from);
  }

  inline RemoveDetectorRequest& operator=(const RemoveDetectorRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoveDetectorRequest& operator=(RemoveDetectorRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoveDetectorRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoveDetectorRequest* internal_default_instance() {
    return reinterpret_cast<const RemoveDetectorRequest*>(
               &_RemoveDetectorRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(RemoveDetectorRequest& a, RemoveDetectorRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoveDetectorRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoveDetectorRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoveDetectorRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RemoveDetectorRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RemoveDetectorRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RemoveDetectorRequest& from) {
    RemoveDetectorRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoveDetectorRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.service.vision.v1.RemoveDetectorRequest";
  }
  protected:
  explicit RemoveDetectorRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDetectorNameFieldNumber = 2,
    kExtraFieldNumber = 99,
  };
  // string name = 1 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string detector_name = 2 [json_name = "detectorName"];
  void clear_detector_name();
  const std::string& detector_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_detector_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_detector_name();
  PROTOBUF_NODISCARD std::string* release_detector_name();
  void set_allocated_detector_name(std::string* detector_name);
  private:
  const std::string& _internal_detector_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_detector_name(const std::string& value);
  std::string* _internal_mutable_detector_name();
  public:

  // .google.protobuf.Struct extra = 99 [json_name = "extra"];
  bool has_extra() const;
  private:
  bool _internal_has_extra() const;
  public:
  void clear_extra();
  const ::PROTOBUF_NAMESPACE_ID::Struct& extra() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_extra();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_extra();
  void set_allocated_extra(::PROTOBUF_NAMESPACE_ID::Struct* extra);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_extra() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_extra();
  public:
  void unsafe_arena_set_allocated_extra(
      ::PROTOBUF_NAMESPACE_ID::Struct* extra);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_extra();

  // @@protoc_insertion_point(class_scope:viam.service.vision.v1.RemoveDetectorRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr detector_name_;
    ::PROTOBUF_NAMESPACE_ID::Struct* extra_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2fvision_2fv1_2fvision_2eproto;
};
// -------------------------------------------------------------------

class RemoveDetectorResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.service.vision.v1.RemoveDetectorResponse) */ {
 public:
  inline RemoveDetectorResponse() : RemoveDetectorResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR RemoveDetectorResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RemoveDetectorResponse(const RemoveDetectorResponse& from);
  RemoveDetectorResponse(RemoveDetectorResponse&& from) noexcept
    : RemoveDetectorResponse() {
    *this = ::std::move(from);
  }

  inline RemoveDetectorResponse& operator=(const RemoveDetectorResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoveDetectorResponse& operator=(RemoveDetectorResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoveDetectorResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoveDetectorResponse* internal_default_instance() {
    return reinterpret_cast<const RemoveDetectorResponse*>(
               &_RemoveDetectorResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(RemoveDetectorResponse& a, RemoveDetectorResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoveDetectorResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoveDetectorResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoveDetectorResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RemoveDetectorResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const RemoveDetectorResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const RemoveDetectorResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.service.vision.v1.RemoveDetectorResponse";
  }
  protected:
  explicit RemoveDetectorResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.service.vision.v1.RemoveDetectorResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_service_2fvision_2fv1_2fvision_2eproto;
};
// -------------------------------------------------------------------

class GetDetectionsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.service.vision.v1.GetDetectionsRequest) */ {
 public:
  inline GetDetectionsRequest() : GetDetectionsRequest(nullptr) {}
  ~GetDetectionsRequest() override;
  explicit PROTOBUF_CONSTEXPR GetDetectionsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetDetectionsRequest(const GetDetectionsRequest& from);
  GetDetectionsRequest(GetDetectionsRequest&& from) noexcept
    : GetDetectionsRequest() {
    *this = ::std::move(from);
  }

  inline GetDetectionsRequest& operator=(const GetDetectionsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetDetectionsRequest& operator=(GetDetectionsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetDetectionsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetDetectionsRequest* internal_default_instance() {
    return reinterpret_cast<const GetDetectionsRequest*>(
               &_GetDetectionsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(GetDetectionsRequest& a, GetDetectionsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetDetectionsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetDetectionsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetDetectionsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetDetectionsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetDetectionsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetDetectionsRequest& from) {
    GetDetectionsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetDetectionsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.service.vision.v1.GetDetectionsRequest";
  }
  protected:
  explicit GetDetectionsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kImageFieldNumber = 2,
    kMimeTypeFieldNumber = 5,
    kDetectorNameFieldNumber = 6,
    kExtraFieldNumber = 99,
    kWidthFieldNumber = 3,
    kHeightFieldNumber = 4,
  };
  // string name = 1 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // bytes image = 2 [json_name = "image"];
  void clear_image();
  const std::string& image() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_image(ArgT0&& arg0, ArgT... args);
  std::string* mutable_image();
  PROTOBUF_NODISCARD std::string* release_image();
  void set_allocated_image(std::string* image);
  private:
  const std::string& _internal_image() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_image(const std::string& value);
  std::string* _internal_mutable_image();
  public:

  // string mime_type = 5 [json_name = "mimeType"];
  void clear_mime_type();
  const std::string& mime_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mime_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mime_type();
  PROTOBUF_NODISCARD std::string* release_mime_type();
  void set_allocated_mime_type(std::string* mime_type);
  private:
  const std::string& _internal_mime_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mime_type(const std::string& value);
  std::string* _internal_mutable_mime_type();
  public:

  // string detector_name = 6 [json_name = "detectorName"];
  void clear_detector_name();
  const std::string& detector_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_detector_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_detector_name();
  PROTOBUF_NODISCARD std::string* release_detector_name();
  void set_allocated_detector_name(std::string* detector_name);
  private:
  const std::string& _internal_detector_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_detector_name(const std::string& value);
  std::string* _internal_mutable_detector_name();
  public:

  // .google.protobuf.Struct extra = 99 [json_name = "extra"];
  bool has_extra() const;
  private:
  bool _internal_has_extra() const;
  public:
  void clear_extra();
  const ::PROTOBUF_NAMESPACE_ID::Struct& extra() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_extra();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_extra();
  void set_allocated_extra(::PROTOBUF_NAMESPACE_ID::Struct* extra);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_extra() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_extra();
  public:
  void unsafe_arena_set_allocated_extra(
      ::PROTOBUF_NAMESPACE_ID::Struct* extra);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_extra();

  // int64 width = 3 [json_name = "width"];
  void clear_width();
  int64_t width() const;
  void set_width(int64_t value);
  private:
  int64_t _internal_width() const;
  void _internal_set_width(int64_t value);
  public:

  // int64 height = 4 [json_name = "height"];
  void clear_height();
  int64_t height() const;
  void set_height(int64_t value);
  private:
  int64_t _internal_height() const;
  void _internal_set_height(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:viam.service.vision.v1.GetDetectionsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr image_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mime_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr detector_name_;
    ::PROTOBUF_NAMESPACE_ID::Struct* extra_;
    int64_t width_;
    int64_t height_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2fvision_2fv1_2fvision_2eproto;
};
// -------------------------------------------------------------------

class GetDetectionsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.service.vision.v1.GetDetectionsResponse) */ {
 public:
  inline GetDetectionsResponse() : GetDetectionsResponse(nullptr) {}
  ~GetDetectionsResponse() override;
  explicit PROTOBUF_CONSTEXPR GetDetectionsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetDetectionsResponse(const GetDetectionsResponse& from);
  GetDetectionsResponse(GetDetectionsResponse&& from) noexcept
    : GetDetectionsResponse() {
    *this = ::std::move(from);
  }

  inline GetDetectionsResponse& operator=(const GetDetectionsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetDetectionsResponse& operator=(GetDetectionsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetDetectionsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetDetectionsResponse* internal_default_instance() {
    return reinterpret_cast<const GetDetectionsResponse*>(
               &_GetDetectionsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(GetDetectionsResponse& a, GetDetectionsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetDetectionsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetDetectionsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetDetectionsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetDetectionsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetDetectionsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetDetectionsResponse& from) {
    GetDetectionsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetDetectionsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.service.vision.v1.GetDetectionsResponse";
  }
  protected:
  explicit GetDetectionsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDetectionsFieldNumber = 1,
  };
  // repeated .viam.service.vision.v1.Detection detections = 1 [json_name = "detections"];
  int detections_size() const;
  private:
  int _internal_detections_size() const;
  public:
  void clear_detections();
  ::viam::service::vision::v1::Detection* mutable_detections(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::service::vision::v1::Detection >*
      mutable_detections();
  private:
  const ::viam::service::vision::v1::Detection& _internal_detections(int index) const;
  ::viam::service::vision::v1::Detection* _internal_add_detections();
  public:
  const ::viam::service::vision::v1::Detection& detections(int index) const;
  ::viam::service::vision::v1::Detection* add_detections();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::service::vision::v1::Detection >&
      detections() const;

  // @@protoc_insertion_point(class_scope:viam.service.vision.v1.GetDetectionsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::service::vision::v1::Detection > detections_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2fvision_2fv1_2fvision_2eproto;
};
// -------------------------------------------------------------------

class GetDetectionsFromCameraRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.service.vision.v1.GetDetectionsFromCameraRequest) */ {
 public:
  inline GetDetectionsFromCameraRequest() : GetDetectionsFromCameraRequest(nullptr) {}
  ~GetDetectionsFromCameraRequest() override;
  explicit PROTOBUF_CONSTEXPR GetDetectionsFromCameraRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetDetectionsFromCameraRequest(const GetDetectionsFromCameraRequest& from);
  GetDetectionsFromCameraRequest(GetDetectionsFromCameraRequest&& from) noexcept
    : GetDetectionsFromCameraRequest() {
    *this = ::std::move(from);
  }

  inline GetDetectionsFromCameraRequest& operator=(const GetDetectionsFromCameraRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetDetectionsFromCameraRequest& operator=(GetDetectionsFromCameraRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetDetectionsFromCameraRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetDetectionsFromCameraRequest* internal_default_instance() {
    return reinterpret_cast<const GetDetectionsFromCameraRequest*>(
               &_GetDetectionsFromCameraRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(GetDetectionsFromCameraRequest& a, GetDetectionsFromCameraRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetDetectionsFromCameraRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetDetectionsFromCameraRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetDetectionsFromCameraRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetDetectionsFromCameraRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetDetectionsFromCameraRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetDetectionsFromCameraRequest& from) {
    GetDetectionsFromCameraRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetDetectionsFromCameraRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.service.vision.v1.GetDetectionsFromCameraRequest";
  }
  protected:
  explicit GetDetectionsFromCameraRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kCameraNameFieldNumber = 2,
    kDetectorNameFieldNumber = 3,
    kExtraFieldNumber = 99,
  };
  // string name = 1 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string camera_name = 2 [json_name = "cameraName"];
  void clear_camera_name();
  const std::string& camera_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_camera_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_camera_name();
  PROTOBUF_NODISCARD std::string* release_camera_name();
  void set_allocated_camera_name(std::string* camera_name);
  private:
  const std::string& _internal_camera_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_camera_name(const std::string& value);
  std::string* _internal_mutable_camera_name();
  public:

  // string detector_name = 3 [json_name = "detectorName"];
  void clear_detector_name();
  const std::string& detector_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_detector_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_detector_name();
  PROTOBUF_NODISCARD std::string* release_detector_name();
  void set_allocated_detector_name(std::string* detector_name);
  private:
  const std::string& _internal_detector_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_detector_name(const std::string& value);
  std::string* _internal_mutable_detector_name();
  public:

  // .google.protobuf.Struct extra = 99 [json_name = "extra"];
  bool has_extra() const;
  private:
  bool _internal_has_extra() const;
  public:
  void clear_extra();
  const ::PROTOBUF_NAMESPACE_ID::Struct& extra() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_extra();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_extra();
  void set_allocated_extra(::PROTOBUF_NAMESPACE_ID::Struct* extra);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_extra() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_extra();
  public:
  void unsafe_arena_set_allocated_extra(
      ::PROTOBUF_NAMESPACE_ID::Struct* extra);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_extra();

  // @@protoc_insertion_point(class_scope:viam.service.vision.v1.GetDetectionsFromCameraRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr camera_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr detector_name_;
    ::PROTOBUF_NAMESPACE_ID::Struct* extra_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2fvision_2fv1_2fvision_2eproto;
};
// -------------------------------------------------------------------

class GetDetectionsFromCameraResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.service.vision.v1.GetDetectionsFromCameraResponse) */ {
 public:
  inline GetDetectionsFromCameraResponse() : GetDetectionsFromCameraResponse(nullptr) {}
  ~GetDetectionsFromCameraResponse() override;
  explicit PROTOBUF_CONSTEXPR GetDetectionsFromCameraResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetDetectionsFromCameraResponse(const GetDetectionsFromCameraResponse& from);
  GetDetectionsFromCameraResponse(GetDetectionsFromCameraResponse&& from) noexcept
    : GetDetectionsFromCameraResponse() {
    *this = ::std::move(from);
  }

  inline GetDetectionsFromCameraResponse& operator=(const GetDetectionsFromCameraResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetDetectionsFromCameraResponse& operator=(GetDetectionsFromCameraResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetDetectionsFromCameraResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetDetectionsFromCameraResponse* internal_default_instance() {
    return reinterpret_cast<const GetDetectionsFromCameraResponse*>(
               &_GetDetectionsFromCameraResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(GetDetectionsFromCameraResponse& a, GetDetectionsFromCameraResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetDetectionsFromCameraResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetDetectionsFromCameraResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetDetectionsFromCameraResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetDetectionsFromCameraResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetDetectionsFromCameraResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetDetectionsFromCameraResponse& from) {
    GetDetectionsFromCameraResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetDetectionsFromCameraResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.service.vision.v1.GetDetectionsFromCameraResponse";
  }
  protected:
  explicit GetDetectionsFromCameraResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDetectionsFieldNumber = 1,
  };
  // repeated .viam.service.vision.v1.Detection detections = 1 [json_name = "detections"];
  int detections_size() const;
  private:
  int _internal_detections_size() const;
  public:
  void clear_detections();
  ::viam::service::vision::v1::Detection* mutable_detections(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::service::vision::v1::Detection >*
      mutable_detections();
  private:
  const ::viam::service::vision::v1::Detection& _internal_detections(int index) const;
  ::viam::service::vision::v1::Detection* _internal_add_detections();
  public:
  const ::viam::service::vision::v1::Detection& detections(int index) const;
  ::viam::service::vision::v1::Detection* add_detections();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::service::vision::v1::Detection >&
      detections() const;

  // @@protoc_insertion_point(class_scope:viam.service.vision.v1.GetDetectionsFromCameraResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::service::vision::v1::Detection > detections_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2fvision_2fv1_2fvision_2eproto;
};
// -------------------------------------------------------------------

class Detection final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.service.vision.v1.Detection) */ {
 public:
  inline Detection() : Detection(nullptr) {}
  ~Detection() override;
  explicit PROTOBUF_CONSTEXPR Detection(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Detection(const Detection& from);
  Detection(Detection&& from) noexcept
    : Detection() {
    *this = ::std::move(from);
  }

  inline Detection& operator=(const Detection& from) {
    CopyFrom(from);
    return *this;
  }
  inline Detection& operator=(Detection&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Detection& default_instance() {
    return *internal_default_instance();
  }
  static inline const Detection* internal_default_instance() {
    return reinterpret_cast<const Detection*>(
               &_Detection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Detection& a, Detection& b) {
    a.Swap(&b);
  }
  inline void Swap(Detection* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Detection* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Detection* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Detection>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Detection& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Detection& from) {
    Detection::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Detection* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.service.vision.v1.Detection";
  }
  protected:
  explicit Detection(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClassNameFieldNumber = 6,
    kXMinFieldNumber = 1,
    kYMinFieldNumber = 2,
    kXMaxFieldNumber = 3,
    kYMaxFieldNumber = 4,
    kConfidenceFieldNumber = 5,
  };
  // string class_name = 6 [json_name = "className"];
  void clear_class_name();
  const std::string& class_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_class_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_class_name();
  PROTOBUF_NODISCARD std::string* release_class_name();
  void set_allocated_class_name(std::string* class_name);
  private:
  const std::string& _internal_class_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_class_name(const std::string& value);
  std::string* _internal_mutable_class_name();
  public:

  // optional int64 x_min = 1 [json_name = "xMin"];
  bool has_x_min() const;
  private:
  bool _internal_has_x_min() const;
  public:
  void clear_x_min();
  int64_t x_min() const;
  void set_x_min(int64_t value);
  private:
  int64_t _internal_x_min() const;
  void _internal_set_x_min(int64_t value);
  public:

  // optional int64 y_min = 2 [json_name = "yMin"];
  bool has_y_min() const;
  private:
  bool _internal_has_y_min() const;
  public:
  void clear_y_min();
  int64_t y_min() const;
  void set_y_min(int64_t value);
  private:
  int64_t _internal_y_min() const;
  void _internal_set_y_min(int64_t value);
  public:

  // optional int64 x_max = 3 [json_name = "xMax"];
  bool has_x_max() const;
  private:
  bool _internal_has_x_max() const;
  public:
  void clear_x_max();
  int64_t x_max() const;
  void set_x_max(int64_t value);
  private:
  int64_t _internal_x_max() const;
  void _internal_set_x_max(int64_t value);
  public:

  // optional int64 y_max = 4 [json_name = "yMax"];
  bool has_y_max() const;
  private:
  bool _internal_has_y_max() const;
  public:
  void clear_y_max();
  int64_t y_max() const;
  void set_y_max(int64_t value);
  private:
  int64_t _internal_y_max() const;
  void _internal_set_y_max(int64_t value);
  public:

  // double confidence = 5 [json_name = "confidence"];
  void clear_confidence();
  double confidence() const;
  void set_confidence(double value);
  private:
  double _internal_confidence() const;
  void _internal_set_confidence(double value);
  public:

  // @@protoc_insertion_point(class_scope:viam.service.vision.v1.Detection)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr class_name_;
    int64_t x_min_;
    int64_t y_min_;
    int64_t x_max_;
    int64_t y_max_;
    double confidence_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2fvision_2fv1_2fvision_2eproto;
};
// -------------------------------------------------------------------

class GetClassifierNamesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.service.vision.v1.GetClassifierNamesRequest) */ {
 public:
  inline GetClassifierNamesRequest() : GetClassifierNamesRequest(nullptr) {}
  ~GetClassifierNamesRequest() override;
  explicit PROTOBUF_CONSTEXPR GetClassifierNamesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetClassifierNamesRequest(const GetClassifierNamesRequest& from);
  GetClassifierNamesRequest(GetClassifierNamesRequest&& from) noexcept
    : GetClassifierNamesRequest() {
    *this = ::std::move(from);
  }

  inline GetClassifierNamesRequest& operator=(const GetClassifierNamesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetClassifierNamesRequest& operator=(GetClassifierNamesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetClassifierNamesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetClassifierNamesRequest* internal_default_instance() {
    return reinterpret_cast<const GetClassifierNamesRequest*>(
               &_GetClassifierNamesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(GetClassifierNamesRequest& a, GetClassifierNamesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetClassifierNamesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetClassifierNamesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetClassifierNamesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetClassifierNamesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetClassifierNamesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetClassifierNamesRequest& from) {
    GetClassifierNamesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetClassifierNamesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.service.vision.v1.GetClassifierNamesRequest";
  }
  protected:
  explicit GetClassifierNamesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kExtraFieldNumber = 99,
  };
  // string name = 1 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .google.protobuf.Struct extra = 99 [json_name = "extra"];
  bool has_extra() const;
  private:
  bool _internal_has_extra() const;
  public:
  void clear_extra();
  const ::PROTOBUF_NAMESPACE_ID::Struct& extra() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_extra();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_extra();
  void set_allocated_extra(::PROTOBUF_NAMESPACE_ID::Struct* extra);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_extra() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_extra();
  public:
  void unsafe_arena_set_allocated_extra(
      ::PROTOBUF_NAMESPACE_ID::Struct* extra);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_extra();

  // @@protoc_insertion_point(class_scope:viam.service.vision.v1.GetClassifierNamesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::Struct* extra_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2fvision_2fv1_2fvision_2eproto;
};
// -------------------------------------------------------------------

class GetClassifierNamesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.service.vision.v1.GetClassifierNamesResponse) */ {
 public:
  inline GetClassifierNamesResponse() : GetClassifierNamesResponse(nullptr) {}
  ~GetClassifierNamesResponse() override;
  explicit PROTOBUF_CONSTEXPR GetClassifierNamesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetClassifierNamesResponse(const GetClassifierNamesResponse& from);
  GetClassifierNamesResponse(GetClassifierNamesResponse&& from) noexcept
    : GetClassifierNamesResponse() {
    *this = ::std::move(from);
  }

  inline GetClassifierNamesResponse& operator=(const GetClassifierNamesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetClassifierNamesResponse& operator=(GetClassifierNamesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetClassifierNamesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetClassifierNamesResponse* internal_default_instance() {
    return reinterpret_cast<const GetClassifierNamesResponse*>(
               &_GetClassifierNamesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(GetClassifierNamesResponse& a, GetClassifierNamesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetClassifierNamesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetClassifierNamesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetClassifierNamesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetClassifierNamesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetClassifierNamesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetClassifierNamesResponse& from) {
    GetClassifierNamesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetClassifierNamesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.service.vision.v1.GetClassifierNamesResponse";
  }
  protected:
  explicit GetClassifierNamesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClassifierNamesFieldNumber = 1,
  };
  // repeated string classifier_names = 1 [json_name = "classifierNames"];
  int classifier_names_size() const;
  private:
  int _internal_classifier_names_size() const;
  public:
  void clear_classifier_names();
  const std::string& classifier_names(int index) const;
  std::string* mutable_classifier_names(int index);
  void set_classifier_names(int index, const std::string& value);
  void set_classifier_names(int index, std::string&& value);
  void set_classifier_names(int index, const char* value);
  void set_classifier_names(int index, const char* value, size_t size);
  std::string* add_classifier_names();
  void add_classifier_names(const std::string& value);
  void add_classifier_names(std::string&& value);
  void add_classifier_names(const char* value);
  void add_classifier_names(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& classifier_names() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_classifier_names();
  private:
  const std::string& _internal_classifier_names(int index) const;
  std::string* _internal_add_classifier_names();
  public:

  // @@protoc_insertion_point(class_scope:viam.service.vision.v1.GetClassifierNamesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> classifier_names_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2fvision_2fv1_2fvision_2eproto;
};
// -------------------------------------------------------------------

class AddClassifierRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.service.vision.v1.AddClassifierRequest) */ {
 public:
  inline AddClassifierRequest() : AddClassifierRequest(nullptr) {}
  ~AddClassifierRequest() override;
  explicit PROTOBUF_CONSTEXPR AddClassifierRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddClassifierRequest(const AddClassifierRequest& from);
  AddClassifierRequest(AddClassifierRequest&& from) noexcept
    : AddClassifierRequest() {
    *this = ::std::move(from);
  }

  inline AddClassifierRequest& operator=(const AddClassifierRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddClassifierRequest& operator=(AddClassifierRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddClassifierRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddClassifierRequest* internal_default_instance() {
    return reinterpret_cast<const AddClassifierRequest*>(
               &_AddClassifierRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(AddClassifierRequest& a, AddClassifierRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AddClassifierRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddClassifierRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddClassifierRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddClassifierRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddClassifierRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AddClassifierRequest& from) {
    AddClassifierRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddClassifierRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.service.vision.v1.AddClassifierRequest";
  }
  protected:
  explicit AddClassifierRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kClassifierNameFieldNumber = 2,
    kClassifierModelTypeFieldNumber = 3,
    kClassifierParametersFieldNumber = 4,
    kExtraFieldNumber = 99,
  };
  // string name = 1 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string classifier_name = 2 [json_name = "classifierName"];
  void clear_classifier_name();
  const std::string& classifier_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_classifier_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_classifier_name();
  PROTOBUF_NODISCARD std::string* release_classifier_name();
  void set_allocated_classifier_name(std::string* classifier_name);
  private:
  const std::string& _internal_classifier_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_classifier_name(const std::string& value);
  std::string* _internal_mutable_classifier_name();
  public:

  // string classifier_model_type = 3 [json_name = "classifierModelType"];
  void clear_classifier_model_type();
  const std::string& classifier_model_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_classifier_model_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_classifier_model_type();
  PROTOBUF_NODISCARD std::string* release_classifier_model_type();
  void set_allocated_classifier_model_type(std::string* classifier_model_type);
  private:
  const std::string& _internal_classifier_model_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_classifier_model_type(const std::string& value);
  std::string* _internal_mutable_classifier_model_type();
  public:

  // .google.protobuf.Struct classifier_parameters = 4 [json_name = "classifierParameters"];
  bool has_classifier_parameters() const;
  private:
  bool _internal_has_classifier_parameters() const;
  public:
  void clear_classifier_parameters();
  const ::PROTOBUF_NAMESPACE_ID::Struct& classifier_parameters() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_classifier_parameters();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_classifier_parameters();
  void set_allocated_classifier_parameters(::PROTOBUF_NAMESPACE_ID::Struct* classifier_parameters);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_classifier_parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_classifier_parameters();
  public:
  void unsafe_arena_set_allocated_classifier_parameters(
      ::PROTOBUF_NAMESPACE_ID::Struct* classifier_parameters);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_classifier_parameters();

  // .google.protobuf.Struct extra = 99 [json_name = "extra"];
  bool has_extra() const;
  private:
  bool _internal_has_extra() const;
  public:
  void clear_extra();
  const ::PROTOBUF_NAMESPACE_ID::Struct& extra() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_extra();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_extra();
  void set_allocated_extra(::PROTOBUF_NAMESPACE_ID::Struct* extra);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_extra() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_extra();
  public:
  void unsafe_arena_set_allocated_extra(
      ::PROTOBUF_NAMESPACE_ID::Struct* extra);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_extra();

  // @@protoc_insertion_point(class_scope:viam.service.vision.v1.AddClassifierRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr classifier_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr classifier_model_type_;
    ::PROTOBUF_NAMESPACE_ID::Struct* classifier_parameters_;
    ::PROTOBUF_NAMESPACE_ID::Struct* extra_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2fvision_2fv1_2fvision_2eproto;
};
// -------------------------------------------------------------------

class AddClassifierResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.service.vision.v1.AddClassifierResponse) */ {
 public:
  inline AddClassifierResponse() : AddClassifierResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR AddClassifierResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddClassifierResponse(const AddClassifierResponse& from);
  AddClassifierResponse(AddClassifierResponse&& from) noexcept
    : AddClassifierResponse() {
    *this = ::std::move(from);
  }

  inline AddClassifierResponse& operator=(const AddClassifierResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddClassifierResponse& operator=(AddClassifierResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddClassifierResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddClassifierResponse* internal_default_instance() {
    return reinterpret_cast<const AddClassifierResponse*>(
               &_AddClassifierResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(AddClassifierResponse& a, AddClassifierResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AddClassifierResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddClassifierResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddClassifierResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddClassifierResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const AddClassifierResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const AddClassifierResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.service.vision.v1.AddClassifierResponse";
  }
  protected:
  explicit AddClassifierResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.service.vision.v1.AddClassifierResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_service_2fvision_2fv1_2fvision_2eproto;
};
// -------------------------------------------------------------------

class RemoveClassifierRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.service.vision.v1.RemoveClassifierRequest) */ {
 public:
  inline RemoveClassifierRequest() : RemoveClassifierRequest(nullptr) {}
  ~RemoveClassifierRequest() override;
  explicit PROTOBUF_CONSTEXPR RemoveClassifierRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RemoveClassifierRequest(const RemoveClassifierRequest& from);
  RemoveClassifierRequest(RemoveClassifierRequest&& from) noexcept
    : RemoveClassifierRequest() {
    *this = ::std::move(from);
  }

  inline RemoveClassifierRequest& operator=(const RemoveClassifierRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoveClassifierRequest& operator=(RemoveClassifierRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoveClassifierRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoveClassifierRequest* internal_default_instance() {
    return reinterpret_cast<const RemoveClassifierRequest*>(
               &_RemoveClassifierRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(RemoveClassifierRequest& a, RemoveClassifierRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoveClassifierRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoveClassifierRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoveClassifierRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RemoveClassifierRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RemoveClassifierRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RemoveClassifierRequest& from) {
    RemoveClassifierRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoveClassifierRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.service.vision.v1.RemoveClassifierRequest";
  }
  protected:
  explicit RemoveClassifierRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kClassifierNameFieldNumber = 2,
    kExtraFieldNumber = 99,
  };
  // string name = 1 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string classifier_name = 2 [json_name = "classifierName"];
  void clear_classifier_name();
  const std::string& classifier_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_classifier_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_classifier_name();
  PROTOBUF_NODISCARD std::string* release_classifier_name();
  void set_allocated_classifier_name(std::string* classifier_name);
  private:
  const std::string& _internal_classifier_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_classifier_name(const std::string& value);
  std::string* _internal_mutable_classifier_name();
  public:

  // .google.protobuf.Struct extra = 99 [json_name = "extra"];
  bool has_extra() const;
  private:
  bool _internal_has_extra() const;
  public:
  void clear_extra();
  const ::PROTOBUF_NAMESPACE_ID::Struct& extra() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_extra();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_extra();
  void set_allocated_extra(::PROTOBUF_NAMESPACE_ID::Struct* extra);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_extra() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_extra();
  public:
  void unsafe_arena_set_allocated_extra(
      ::PROTOBUF_NAMESPACE_ID::Struct* extra);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_extra();

  // @@protoc_insertion_point(class_scope:viam.service.vision.v1.RemoveClassifierRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr classifier_name_;
    ::PROTOBUF_NAMESPACE_ID::Struct* extra_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2fvision_2fv1_2fvision_2eproto;
};
// -------------------------------------------------------------------

class RemoveClassifierResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.service.vision.v1.RemoveClassifierResponse) */ {
 public:
  inline RemoveClassifierResponse() : RemoveClassifierResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR RemoveClassifierResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RemoveClassifierResponse(const RemoveClassifierResponse& from);
  RemoveClassifierResponse(RemoveClassifierResponse&& from) noexcept
    : RemoveClassifierResponse() {
    *this = ::std::move(from);
  }

  inline RemoveClassifierResponse& operator=(const RemoveClassifierResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoveClassifierResponse& operator=(RemoveClassifierResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoveClassifierResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoveClassifierResponse* internal_default_instance() {
    return reinterpret_cast<const RemoveClassifierResponse*>(
               &_RemoveClassifierResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(RemoveClassifierResponse& a, RemoveClassifierResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoveClassifierResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoveClassifierResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoveClassifierResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RemoveClassifierResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const RemoveClassifierResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const RemoveClassifierResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.service.vision.v1.RemoveClassifierResponse";
  }
  protected:
  explicit RemoveClassifierResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.service.vision.v1.RemoveClassifierResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_service_2fvision_2fv1_2fvision_2eproto;
};
// -------------------------------------------------------------------

class GetClassificationsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.service.vision.v1.GetClassificationsRequest) */ {
 public:
  inline GetClassificationsRequest() : GetClassificationsRequest(nullptr) {}
  ~GetClassificationsRequest() override;
  explicit PROTOBUF_CONSTEXPR GetClassificationsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetClassificationsRequest(const GetClassificationsRequest& from);
  GetClassificationsRequest(GetClassificationsRequest&& from) noexcept
    : GetClassificationsRequest() {
    *this = ::std::move(from);
  }

  inline GetClassificationsRequest& operator=(const GetClassificationsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetClassificationsRequest& operator=(GetClassificationsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetClassificationsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetClassificationsRequest* internal_default_instance() {
    return reinterpret_cast<const GetClassificationsRequest*>(
               &_GetClassificationsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(GetClassificationsRequest& a, GetClassificationsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetClassificationsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetClassificationsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetClassificationsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetClassificationsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetClassificationsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetClassificationsRequest& from) {
    GetClassificationsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetClassificationsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.service.vision.v1.GetClassificationsRequest";
  }
  protected:
  explicit GetClassificationsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kImageFieldNumber = 2,
    kMimeTypeFieldNumber = 5,
    kClassifierNameFieldNumber = 6,
    kExtraFieldNumber = 99,
    kWidthFieldNumber = 3,
    kHeightFieldNumber = 4,
    kNFieldNumber = 7,
  };
  // string name = 1 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // bytes image = 2 [json_name = "image"];
  void clear_image();
  const std::string& image() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_image(ArgT0&& arg0, ArgT... args);
  std::string* mutable_image();
  PROTOBUF_NODISCARD std::string* release_image();
  void set_allocated_image(std::string* image);
  private:
  const std::string& _internal_image() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_image(const std::string& value);
  std::string* _internal_mutable_image();
  public:

  // string mime_type = 5 [json_name = "mimeType"];
  void clear_mime_type();
  const std::string& mime_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mime_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mime_type();
  PROTOBUF_NODISCARD std::string* release_mime_type();
  void set_allocated_mime_type(std::string* mime_type);
  private:
  const std::string& _internal_mime_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mime_type(const std::string& value);
  std::string* _internal_mutable_mime_type();
  public:

  // string classifier_name = 6 [json_name = "classifierName"];
  void clear_classifier_name();
  const std::string& classifier_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_classifier_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_classifier_name();
  PROTOBUF_NODISCARD std::string* release_classifier_name();
  void set_allocated_classifier_name(std::string* classifier_name);
  private:
  const std::string& _internal_classifier_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_classifier_name(const std::string& value);
  std::string* _internal_mutable_classifier_name();
  public:

  // .google.protobuf.Struct extra = 99 [json_name = "extra"];
  bool has_extra() const;
  private:
  bool _internal_has_extra() const;
  public:
  void clear_extra();
  const ::PROTOBUF_NAMESPACE_ID::Struct& extra() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_extra();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_extra();
  void set_allocated_extra(::PROTOBUF_NAMESPACE_ID::Struct* extra);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_extra() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_extra();
  public:
  void unsafe_arena_set_allocated_extra(
      ::PROTOBUF_NAMESPACE_ID::Struct* extra);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_extra();

  // int32 width = 3 [json_name = "width"];
  void clear_width();
  int32_t width() const;
  void set_width(int32_t value);
  private:
  int32_t _internal_width() const;
  void _internal_set_width(int32_t value);
  public:

  // int32 height = 4 [json_name = "height"];
  void clear_height();
  int32_t height() const;
  void set_height(int32_t value);
  private:
  int32_t _internal_height() const;
  void _internal_set_height(int32_t value);
  public:

  // int32 n = 7 [json_name = "n"];
  void clear_n();
  int32_t n() const;
  void set_n(int32_t value);
  private:
  int32_t _internal_n() const;
  void _internal_set_n(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:viam.service.vision.v1.GetClassificationsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr image_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mime_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr classifier_name_;
    ::PROTOBUF_NAMESPACE_ID::Struct* extra_;
    int32_t width_;
    int32_t height_;
    int32_t n_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2fvision_2fv1_2fvision_2eproto;
};
// -------------------------------------------------------------------

class GetClassificationsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.service.vision.v1.GetClassificationsResponse) */ {
 public:
  inline GetClassificationsResponse() : GetClassificationsResponse(nullptr) {}
  ~GetClassificationsResponse() override;
  explicit PROTOBUF_CONSTEXPR GetClassificationsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetClassificationsResponse(const GetClassificationsResponse& from);
  GetClassificationsResponse(GetClassificationsResponse&& from) noexcept
    : GetClassificationsResponse() {
    *this = ::std::move(from);
  }

  inline GetClassificationsResponse& operator=(const GetClassificationsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetClassificationsResponse& operator=(GetClassificationsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetClassificationsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetClassificationsResponse* internal_default_instance() {
    return reinterpret_cast<const GetClassificationsResponse*>(
               &_GetClassificationsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(GetClassificationsResponse& a, GetClassificationsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetClassificationsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetClassificationsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetClassificationsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetClassificationsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetClassificationsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetClassificationsResponse& from) {
    GetClassificationsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetClassificationsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.service.vision.v1.GetClassificationsResponse";
  }
  protected:
  explicit GetClassificationsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClassificationsFieldNumber = 1,
  };
  // repeated .viam.service.vision.v1.Classification classifications = 1 [json_name = "classifications"];
  int classifications_size() const;
  private:
  int _internal_classifications_size() const;
  public:
  void clear_classifications();
  ::viam::service::vision::v1::Classification* mutable_classifications(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::service::vision::v1::Classification >*
      mutable_classifications();
  private:
  const ::viam::service::vision::v1::Classification& _internal_classifications(int index) const;
  ::viam::service::vision::v1::Classification* _internal_add_classifications();
  public:
  const ::viam::service::vision::v1::Classification& classifications(int index) const;
  ::viam::service::vision::v1::Classification* add_classifications();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::service::vision::v1::Classification >&
      classifications() const;

  // @@protoc_insertion_point(class_scope:viam.service.vision.v1.GetClassificationsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::service::vision::v1::Classification > classifications_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2fvision_2fv1_2fvision_2eproto;
};
// -------------------------------------------------------------------

class GetClassificationsFromCameraRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.service.vision.v1.GetClassificationsFromCameraRequest) */ {
 public:
  inline GetClassificationsFromCameraRequest() : GetClassificationsFromCameraRequest(nullptr) {}
  ~GetClassificationsFromCameraRequest() override;
  explicit PROTOBUF_CONSTEXPR GetClassificationsFromCameraRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetClassificationsFromCameraRequest(const GetClassificationsFromCameraRequest& from);
  GetClassificationsFromCameraRequest(GetClassificationsFromCameraRequest&& from) noexcept
    : GetClassificationsFromCameraRequest() {
    *this = ::std::move(from);
  }

  inline GetClassificationsFromCameraRequest& operator=(const GetClassificationsFromCameraRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetClassificationsFromCameraRequest& operator=(GetClassificationsFromCameraRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetClassificationsFromCameraRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetClassificationsFromCameraRequest* internal_default_instance() {
    return reinterpret_cast<const GetClassificationsFromCameraRequest*>(
               &_GetClassificationsFromCameraRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(GetClassificationsFromCameraRequest& a, GetClassificationsFromCameraRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetClassificationsFromCameraRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetClassificationsFromCameraRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetClassificationsFromCameraRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetClassificationsFromCameraRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetClassificationsFromCameraRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetClassificationsFromCameraRequest& from) {
    GetClassificationsFromCameraRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetClassificationsFromCameraRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.service.vision.v1.GetClassificationsFromCameraRequest";
  }
  protected:
  explicit GetClassificationsFromCameraRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kCameraNameFieldNumber = 2,
    kClassifierNameFieldNumber = 3,
    kExtraFieldNumber = 99,
    kNFieldNumber = 4,
  };
  // string name = 1 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string camera_name = 2 [json_name = "cameraName"];
  void clear_camera_name();
  const std::string& camera_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_camera_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_camera_name();
  PROTOBUF_NODISCARD std::string* release_camera_name();
  void set_allocated_camera_name(std::string* camera_name);
  private:
  const std::string& _internal_camera_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_camera_name(const std::string& value);
  std::string* _internal_mutable_camera_name();
  public:

  // string classifier_name = 3 [json_name = "classifierName"];
  void clear_classifier_name();
  const std::string& classifier_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_classifier_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_classifier_name();
  PROTOBUF_NODISCARD std::string* release_classifier_name();
  void set_allocated_classifier_name(std::string* classifier_name);
  private:
  const std::string& _internal_classifier_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_classifier_name(const std::string& value);
  std::string* _internal_mutable_classifier_name();
  public:

  // .google.protobuf.Struct extra = 99 [json_name = "extra"];
  bool has_extra() const;
  private:
  bool _internal_has_extra() const;
  public:
  void clear_extra();
  const ::PROTOBUF_NAMESPACE_ID::Struct& extra() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_extra();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_extra();
  void set_allocated_extra(::PROTOBUF_NAMESPACE_ID::Struct* extra);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_extra() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_extra();
  public:
  void unsafe_arena_set_allocated_extra(
      ::PROTOBUF_NAMESPACE_ID::Struct* extra);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_extra();

  // int32 n = 4 [json_name = "n"];
  void clear_n();
  int32_t n() const;
  void set_n(int32_t value);
  private:
  int32_t _internal_n() const;
  void _internal_set_n(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:viam.service.vision.v1.GetClassificationsFromCameraRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr camera_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr classifier_name_;
    ::PROTOBUF_NAMESPACE_ID::Struct* extra_;
    int32_t n_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2fvision_2fv1_2fvision_2eproto;
};
// -------------------------------------------------------------------

class GetClassificationsFromCameraResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.service.vision.v1.GetClassificationsFromCameraResponse) */ {
 public:
  inline GetClassificationsFromCameraResponse() : GetClassificationsFromCameraResponse(nullptr) {}
  ~GetClassificationsFromCameraResponse() override;
  explicit PROTOBUF_CONSTEXPR GetClassificationsFromCameraResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetClassificationsFromCameraResponse(const GetClassificationsFromCameraResponse& from);
  GetClassificationsFromCameraResponse(GetClassificationsFromCameraResponse&& from) noexcept
    : GetClassificationsFromCameraResponse() {
    *this = ::std::move(from);
  }

  inline GetClassificationsFromCameraResponse& operator=(const GetClassificationsFromCameraResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetClassificationsFromCameraResponse& operator=(GetClassificationsFromCameraResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetClassificationsFromCameraResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetClassificationsFromCameraResponse* internal_default_instance() {
    return reinterpret_cast<const GetClassificationsFromCameraResponse*>(
               &_GetClassificationsFromCameraResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(GetClassificationsFromCameraResponse& a, GetClassificationsFromCameraResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetClassificationsFromCameraResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetClassificationsFromCameraResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetClassificationsFromCameraResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetClassificationsFromCameraResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetClassificationsFromCameraResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetClassificationsFromCameraResponse& from) {
    GetClassificationsFromCameraResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetClassificationsFromCameraResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.service.vision.v1.GetClassificationsFromCameraResponse";
  }
  protected:
  explicit GetClassificationsFromCameraResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClassificationsFieldNumber = 1,
  };
  // repeated .viam.service.vision.v1.Classification classifications = 1 [json_name = "classifications"];
  int classifications_size() const;
  private:
  int _internal_classifications_size() const;
  public:
  void clear_classifications();
  ::viam::service::vision::v1::Classification* mutable_classifications(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::service::vision::v1::Classification >*
      mutable_classifications();
  private:
  const ::viam::service::vision::v1::Classification& _internal_classifications(int index) const;
  ::viam::service::vision::v1::Classification* _internal_add_classifications();
  public:
  const ::viam::service::vision::v1::Classification& classifications(int index) const;
  ::viam::service::vision::v1::Classification* add_classifications();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::service::vision::v1::Classification >&
      classifications() const;

  // @@protoc_insertion_point(class_scope:viam.service.vision.v1.GetClassificationsFromCameraResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::service::vision::v1::Classification > classifications_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2fvision_2fv1_2fvision_2eproto;
};
// -------------------------------------------------------------------

class Classification final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.service.vision.v1.Classification) */ {
 public:
  inline Classification() : Classification(nullptr) {}
  ~Classification() override;
  explicit PROTOBUF_CONSTEXPR Classification(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Classification(const Classification& from);
  Classification(Classification&& from) noexcept
    : Classification() {
    *this = ::std::move(from);
  }

  inline Classification& operator=(const Classification& from) {
    CopyFrom(from);
    return *this;
  }
  inline Classification& operator=(Classification&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Classification& default_instance() {
    return *internal_default_instance();
  }
  static inline const Classification* internal_default_instance() {
    return reinterpret_cast<const Classification*>(
               &_Classification_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(Classification& a, Classification& b) {
    a.Swap(&b);
  }
  inline void Swap(Classification* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Classification* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Classification* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Classification>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Classification& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Classification& from) {
    Classification::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Classification* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.service.vision.v1.Classification";
  }
  protected:
  explicit Classification(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClassNameFieldNumber = 1,
    kConfidenceFieldNumber = 2,
  };
  // string class_name = 1 [json_name = "className"];
  void clear_class_name();
  const std::string& class_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_class_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_class_name();
  PROTOBUF_NODISCARD std::string* release_class_name();
  void set_allocated_class_name(std::string* class_name);
  private:
  const std::string& _internal_class_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_class_name(const std::string& value);
  std::string* _internal_mutable_class_name();
  public:

  // double confidence = 2 [json_name = "confidence"];
  void clear_confidence();
  double confidence() const;
  void set_confidence(double value);
  private:
  double _internal_confidence() const;
  void _internal_set_confidence(double value);
  public:

  // @@protoc_insertion_point(class_scope:viam.service.vision.v1.Classification)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr class_name_;
    double confidence_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2fvision_2fv1_2fvision_2eproto;
};
// -------------------------------------------------------------------

class GetSegmenterNamesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.service.vision.v1.GetSegmenterNamesRequest) */ {
 public:
  inline GetSegmenterNamesRequest() : GetSegmenterNamesRequest(nullptr) {}
  ~GetSegmenterNamesRequest() override;
  explicit PROTOBUF_CONSTEXPR GetSegmenterNamesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetSegmenterNamesRequest(const GetSegmenterNamesRequest& from);
  GetSegmenterNamesRequest(GetSegmenterNamesRequest&& from) noexcept
    : GetSegmenterNamesRequest() {
    *this = ::std::move(from);
  }

  inline GetSegmenterNamesRequest& operator=(const GetSegmenterNamesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSegmenterNamesRequest& operator=(GetSegmenterNamesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSegmenterNamesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSegmenterNamesRequest* internal_default_instance() {
    return reinterpret_cast<const GetSegmenterNamesRequest*>(
               &_GetSegmenterNamesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(GetSegmenterNamesRequest& a, GetSegmenterNamesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSegmenterNamesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSegmenterNamesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSegmenterNamesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetSegmenterNamesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetSegmenterNamesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetSegmenterNamesRequest& from) {
    GetSegmenterNamesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSegmenterNamesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.service.vision.v1.GetSegmenterNamesRequest";
  }
  protected:
  explicit GetSegmenterNamesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kExtraFieldNumber = 99,
  };
  // string name = 1 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .google.protobuf.Struct extra = 99 [json_name = "extra"];
  bool has_extra() const;
  private:
  bool _internal_has_extra() const;
  public:
  void clear_extra();
  const ::PROTOBUF_NAMESPACE_ID::Struct& extra() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_extra();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_extra();
  void set_allocated_extra(::PROTOBUF_NAMESPACE_ID::Struct* extra);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_extra() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_extra();
  public:
  void unsafe_arena_set_allocated_extra(
      ::PROTOBUF_NAMESPACE_ID::Struct* extra);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_extra();

  // @@protoc_insertion_point(class_scope:viam.service.vision.v1.GetSegmenterNamesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::Struct* extra_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2fvision_2fv1_2fvision_2eproto;
};
// -------------------------------------------------------------------

class GetSegmenterNamesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.service.vision.v1.GetSegmenterNamesResponse) */ {
 public:
  inline GetSegmenterNamesResponse() : GetSegmenterNamesResponse(nullptr) {}
  ~GetSegmenterNamesResponse() override;
  explicit PROTOBUF_CONSTEXPR GetSegmenterNamesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetSegmenterNamesResponse(const GetSegmenterNamesResponse& from);
  GetSegmenterNamesResponse(GetSegmenterNamesResponse&& from) noexcept
    : GetSegmenterNamesResponse() {
    *this = ::std::move(from);
  }

  inline GetSegmenterNamesResponse& operator=(const GetSegmenterNamesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSegmenterNamesResponse& operator=(GetSegmenterNamesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSegmenterNamesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSegmenterNamesResponse* internal_default_instance() {
    return reinterpret_cast<const GetSegmenterNamesResponse*>(
               &_GetSegmenterNamesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(GetSegmenterNamesResponse& a, GetSegmenterNamesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSegmenterNamesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSegmenterNamesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSegmenterNamesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetSegmenterNamesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetSegmenterNamesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetSegmenterNamesResponse& from) {
    GetSegmenterNamesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSegmenterNamesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.service.vision.v1.GetSegmenterNamesResponse";
  }
  protected:
  explicit GetSegmenterNamesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSegmenterNamesFieldNumber = 1,
  };
  // repeated string segmenter_names = 1 [json_name = "segmenterNames"];
  int segmenter_names_size() const;
  private:
  int _internal_segmenter_names_size() const;
  public:
  void clear_segmenter_names();
  const std::string& segmenter_names(int index) const;
  std::string* mutable_segmenter_names(int index);
  void set_segmenter_names(int index, const std::string& value);
  void set_segmenter_names(int index, std::string&& value);
  void set_segmenter_names(int index, const char* value);
  void set_segmenter_names(int index, const char* value, size_t size);
  std::string* add_segmenter_names();
  void add_segmenter_names(const std::string& value);
  void add_segmenter_names(std::string&& value);
  void add_segmenter_names(const char* value);
  void add_segmenter_names(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& segmenter_names() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_segmenter_names();
  private:
  const std::string& _internal_segmenter_names(int index) const;
  std::string* _internal_add_segmenter_names();
  public:

  // @@protoc_insertion_point(class_scope:viam.service.vision.v1.GetSegmenterNamesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> segmenter_names_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2fvision_2fv1_2fvision_2eproto;
};
// -------------------------------------------------------------------

class AddSegmenterRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.service.vision.v1.AddSegmenterRequest) */ {
 public:
  inline AddSegmenterRequest() : AddSegmenterRequest(nullptr) {}
  ~AddSegmenterRequest() override;
  explicit PROTOBUF_CONSTEXPR AddSegmenterRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddSegmenterRequest(const AddSegmenterRequest& from);
  AddSegmenterRequest(AddSegmenterRequest&& from) noexcept
    : AddSegmenterRequest() {
    *this = ::std::move(from);
  }

  inline AddSegmenterRequest& operator=(const AddSegmenterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddSegmenterRequest& operator=(AddSegmenterRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddSegmenterRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddSegmenterRequest* internal_default_instance() {
    return reinterpret_cast<const AddSegmenterRequest*>(
               &_AddSegmenterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(AddSegmenterRequest& a, AddSegmenterRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AddSegmenterRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddSegmenterRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddSegmenterRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddSegmenterRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddSegmenterRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AddSegmenterRequest& from) {
    AddSegmenterRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddSegmenterRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.service.vision.v1.AddSegmenterRequest";
  }
  protected:
  explicit AddSegmenterRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kSegmenterNameFieldNumber = 2,
    kSegmenterModelTypeFieldNumber = 3,
    kSegmenterParametersFieldNumber = 4,
    kExtraFieldNumber = 99,
  };
  // string name = 1 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string segmenter_name = 2 [json_name = "segmenterName"];
  void clear_segmenter_name();
  const std::string& segmenter_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_segmenter_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_segmenter_name();
  PROTOBUF_NODISCARD std::string* release_segmenter_name();
  void set_allocated_segmenter_name(std::string* segmenter_name);
  private:
  const std::string& _internal_segmenter_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_segmenter_name(const std::string& value);
  std::string* _internal_mutable_segmenter_name();
  public:

  // string segmenter_model_type = 3 [json_name = "segmenterModelType"];
  void clear_segmenter_model_type();
  const std::string& segmenter_model_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_segmenter_model_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_segmenter_model_type();
  PROTOBUF_NODISCARD std::string* release_segmenter_model_type();
  void set_allocated_segmenter_model_type(std::string* segmenter_model_type);
  private:
  const std::string& _internal_segmenter_model_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_segmenter_model_type(const std::string& value);
  std::string* _internal_mutable_segmenter_model_type();
  public:

  // .google.protobuf.Struct segmenter_parameters = 4 [json_name = "segmenterParameters"];
  bool has_segmenter_parameters() const;
  private:
  bool _internal_has_segmenter_parameters() const;
  public:
  void clear_segmenter_parameters();
  const ::PROTOBUF_NAMESPACE_ID::Struct& segmenter_parameters() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_segmenter_parameters();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_segmenter_parameters();
  void set_allocated_segmenter_parameters(::PROTOBUF_NAMESPACE_ID::Struct* segmenter_parameters);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_segmenter_parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_segmenter_parameters();
  public:
  void unsafe_arena_set_allocated_segmenter_parameters(
      ::PROTOBUF_NAMESPACE_ID::Struct* segmenter_parameters);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_segmenter_parameters();

  // .google.protobuf.Struct extra = 99 [json_name = "extra"];
  bool has_extra() const;
  private:
  bool _internal_has_extra() const;
  public:
  void clear_extra();
  const ::PROTOBUF_NAMESPACE_ID::Struct& extra() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_extra();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_extra();
  void set_allocated_extra(::PROTOBUF_NAMESPACE_ID::Struct* extra);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_extra() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_extra();
  public:
  void unsafe_arena_set_allocated_extra(
      ::PROTOBUF_NAMESPACE_ID::Struct* extra);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_extra();

  // @@protoc_insertion_point(class_scope:viam.service.vision.v1.AddSegmenterRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr segmenter_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr segmenter_model_type_;
    ::PROTOBUF_NAMESPACE_ID::Struct* segmenter_parameters_;
    ::PROTOBUF_NAMESPACE_ID::Struct* extra_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2fvision_2fv1_2fvision_2eproto;
};
// -------------------------------------------------------------------

class AddSegmenterResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.service.vision.v1.AddSegmenterResponse) */ {
 public:
  inline AddSegmenterResponse() : AddSegmenterResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR AddSegmenterResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddSegmenterResponse(const AddSegmenterResponse& from);
  AddSegmenterResponse(AddSegmenterResponse&& from) noexcept
    : AddSegmenterResponse() {
    *this = ::std::move(from);
  }

  inline AddSegmenterResponse& operator=(const AddSegmenterResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddSegmenterResponse& operator=(AddSegmenterResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddSegmenterResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddSegmenterResponse* internal_default_instance() {
    return reinterpret_cast<const AddSegmenterResponse*>(
               &_AddSegmenterResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(AddSegmenterResponse& a, AddSegmenterResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AddSegmenterResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddSegmenterResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddSegmenterResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddSegmenterResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const AddSegmenterResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const AddSegmenterResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.service.vision.v1.AddSegmenterResponse";
  }
  protected:
  explicit AddSegmenterResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.service.vision.v1.AddSegmenterResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_service_2fvision_2fv1_2fvision_2eproto;
};
// -------------------------------------------------------------------

class RemoveSegmenterRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.service.vision.v1.RemoveSegmenterRequest) */ {
 public:
  inline RemoveSegmenterRequest() : RemoveSegmenterRequest(nullptr) {}
  ~RemoveSegmenterRequest() override;
  explicit PROTOBUF_CONSTEXPR RemoveSegmenterRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RemoveSegmenterRequest(const RemoveSegmenterRequest& from);
  RemoveSegmenterRequest(RemoveSegmenterRequest&& from) noexcept
    : RemoveSegmenterRequest() {
    *this = ::std::move(from);
  }

  inline RemoveSegmenterRequest& operator=(const RemoveSegmenterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoveSegmenterRequest& operator=(RemoveSegmenterRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoveSegmenterRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoveSegmenterRequest* internal_default_instance() {
    return reinterpret_cast<const RemoveSegmenterRequest*>(
               &_RemoveSegmenterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(RemoveSegmenterRequest& a, RemoveSegmenterRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoveSegmenterRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoveSegmenterRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoveSegmenterRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RemoveSegmenterRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RemoveSegmenterRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RemoveSegmenterRequest& from) {
    RemoveSegmenterRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoveSegmenterRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.service.vision.v1.RemoveSegmenterRequest";
  }
  protected:
  explicit RemoveSegmenterRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kSegmenterNameFieldNumber = 2,
    kExtraFieldNumber = 99,
  };
  // string name = 1 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string segmenter_name = 2 [json_name = "segmenterName"];
  void clear_segmenter_name();
  const std::string& segmenter_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_segmenter_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_segmenter_name();
  PROTOBUF_NODISCARD std::string* release_segmenter_name();
  void set_allocated_segmenter_name(std::string* segmenter_name);
  private:
  const std::string& _internal_segmenter_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_segmenter_name(const std::string& value);
  std::string* _internal_mutable_segmenter_name();
  public:

  // .google.protobuf.Struct extra = 99 [json_name = "extra"];
  bool has_extra() const;
  private:
  bool _internal_has_extra() const;
  public:
  void clear_extra();
  const ::PROTOBUF_NAMESPACE_ID::Struct& extra() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_extra();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_extra();
  void set_allocated_extra(::PROTOBUF_NAMESPACE_ID::Struct* extra);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_extra() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_extra();
  public:
  void unsafe_arena_set_allocated_extra(
      ::PROTOBUF_NAMESPACE_ID::Struct* extra);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_extra();

  // @@protoc_insertion_point(class_scope:viam.service.vision.v1.RemoveSegmenterRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr segmenter_name_;
    ::PROTOBUF_NAMESPACE_ID::Struct* extra_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2fvision_2fv1_2fvision_2eproto;
};
// -------------------------------------------------------------------

class RemoveSegmenterResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.service.vision.v1.RemoveSegmenterResponse) */ {
 public:
  inline RemoveSegmenterResponse() : RemoveSegmenterResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR RemoveSegmenterResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RemoveSegmenterResponse(const RemoveSegmenterResponse& from);
  RemoveSegmenterResponse(RemoveSegmenterResponse&& from) noexcept
    : RemoveSegmenterResponse() {
    *this = ::std::move(from);
  }

  inline RemoveSegmenterResponse& operator=(const RemoveSegmenterResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoveSegmenterResponse& operator=(RemoveSegmenterResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoveSegmenterResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoveSegmenterResponse* internal_default_instance() {
    return reinterpret_cast<const RemoveSegmenterResponse*>(
               &_RemoveSegmenterResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(RemoveSegmenterResponse& a, RemoveSegmenterResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoveSegmenterResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoveSegmenterResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoveSegmenterResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RemoveSegmenterResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const RemoveSegmenterResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const RemoveSegmenterResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.service.vision.v1.RemoveSegmenterResponse";
  }
  protected:
  explicit RemoveSegmenterResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.service.vision.v1.RemoveSegmenterResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_service_2fvision_2fv1_2fvision_2eproto;
};
// -------------------------------------------------------------------

class GetObjectPointCloudsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.service.vision.v1.GetObjectPointCloudsRequest) */ {
 public:
  inline GetObjectPointCloudsRequest() : GetObjectPointCloudsRequest(nullptr) {}
  ~GetObjectPointCloudsRequest() override;
  explicit PROTOBUF_CONSTEXPR GetObjectPointCloudsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetObjectPointCloudsRequest(const GetObjectPointCloudsRequest& from);
  GetObjectPointCloudsRequest(GetObjectPointCloudsRequest&& from) noexcept
    : GetObjectPointCloudsRequest() {
    *this = ::std::move(from);
  }

  inline GetObjectPointCloudsRequest& operator=(const GetObjectPointCloudsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetObjectPointCloudsRequest& operator=(GetObjectPointCloudsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetObjectPointCloudsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetObjectPointCloudsRequest* internal_default_instance() {
    return reinterpret_cast<const GetObjectPointCloudsRequest*>(
               &_GetObjectPointCloudsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(GetObjectPointCloudsRequest& a, GetObjectPointCloudsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetObjectPointCloudsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetObjectPointCloudsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetObjectPointCloudsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetObjectPointCloudsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetObjectPointCloudsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetObjectPointCloudsRequest& from) {
    GetObjectPointCloudsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetObjectPointCloudsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.service.vision.v1.GetObjectPointCloudsRequest";
  }
  protected:
  explicit GetObjectPointCloudsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kCameraNameFieldNumber = 2,
    kSegmenterNameFieldNumber = 3,
    kMimeTypeFieldNumber = 4,
    kExtraFieldNumber = 99,
  };
  // string name = 1 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string camera_name = 2 [json_name = "cameraName"];
  void clear_camera_name();
  const std::string& camera_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_camera_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_camera_name();
  PROTOBUF_NODISCARD std::string* release_camera_name();
  void set_allocated_camera_name(std::string* camera_name);
  private:
  const std::string& _internal_camera_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_camera_name(const std::string& value);
  std::string* _internal_mutable_camera_name();
  public:

  // string segmenter_name = 3 [json_name = "segmenterName"];
  void clear_segmenter_name();
  const std::string& segmenter_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_segmenter_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_segmenter_name();
  PROTOBUF_NODISCARD std::string* release_segmenter_name();
  void set_allocated_segmenter_name(std::string* segmenter_name);
  private:
  const std::string& _internal_segmenter_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_segmenter_name(const std::string& value);
  std::string* _internal_mutable_segmenter_name();
  public:

  // string mime_type = 4 [json_name = "mimeType"];
  void clear_mime_type();
  const std::string& mime_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mime_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mime_type();
  PROTOBUF_NODISCARD std::string* release_mime_type();
  void set_allocated_mime_type(std::string* mime_type);
  private:
  const std::string& _internal_mime_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mime_type(const std::string& value);
  std::string* _internal_mutable_mime_type();
  public:

  // .google.protobuf.Struct extra = 99 [json_name = "extra"];
  bool has_extra() const;
  private:
  bool _internal_has_extra() const;
  public:
  void clear_extra();
  const ::PROTOBUF_NAMESPACE_ID::Struct& extra() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_extra();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_extra();
  void set_allocated_extra(::PROTOBUF_NAMESPACE_ID::Struct* extra);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_extra() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_extra();
  public:
  void unsafe_arena_set_allocated_extra(
      ::PROTOBUF_NAMESPACE_ID::Struct* extra);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_extra();

  // @@protoc_insertion_point(class_scope:viam.service.vision.v1.GetObjectPointCloudsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr camera_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr segmenter_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mime_type_;
    ::PROTOBUF_NAMESPACE_ID::Struct* extra_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2fvision_2fv1_2fvision_2eproto;
};
// -------------------------------------------------------------------

class GetObjectPointCloudsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.service.vision.v1.GetObjectPointCloudsResponse) */ {
 public:
  inline GetObjectPointCloudsResponse() : GetObjectPointCloudsResponse(nullptr) {}
  ~GetObjectPointCloudsResponse() override;
  explicit PROTOBUF_CONSTEXPR GetObjectPointCloudsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetObjectPointCloudsResponse(const GetObjectPointCloudsResponse& from);
  GetObjectPointCloudsResponse(GetObjectPointCloudsResponse&& from) noexcept
    : GetObjectPointCloudsResponse() {
    *this = ::std::move(from);
  }

  inline GetObjectPointCloudsResponse& operator=(const GetObjectPointCloudsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetObjectPointCloudsResponse& operator=(GetObjectPointCloudsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetObjectPointCloudsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetObjectPointCloudsResponse* internal_default_instance() {
    return reinterpret_cast<const GetObjectPointCloudsResponse*>(
               &_GetObjectPointCloudsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(GetObjectPointCloudsResponse& a, GetObjectPointCloudsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetObjectPointCloudsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetObjectPointCloudsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetObjectPointCloudsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetObjectPointCloudsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetObjectPointCloudsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetObjectPointCloudsResponse& from) {
    GetObjectPointCloudsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetObjectPointCloudsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.service.vision.v1.GetObjectPointCloudsResponse";
  }
  protected:
  explicit GetObjectPointCloudsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectsFieldNumber = 2,
    kMimeTypeFieldNumber = 1,
  };
  // repeated .viam.common.v1.PointCloudObject objects = 2 [json_name = "objects"];
  int objects_size() const;
  private:
  int _internal_objects_size() const;
  public:
  void clear_objects();
  ::viam::common::v1::PointCloudObject* mutable_objects(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::common::v1::PointCloudObject >*
      mutable_objects();
  private:
  const ::viam::common::v1::PointCloudObject& _internal_objects(int index) const;
  ::viam::common::v1::PointCloudObject* _internal_add_objects();
  public:
  const ::viam::common::v1::PointCloudObject& objects(int index) const;
  ::viam::common::v1::PointCloudObject* add_objects();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::common::v1::PointCloudObject >&
      objects() const;

  // string mime_type = 1 [json_name = "mimeType"];
  void clear_mime_type();
  const std::string& mime_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mime_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mime_type();
  PROTOBUF_NODISCARD std::string* release_mime_type();
  void set_allocated_mime_type(std::string* mime_type);
  private:
  const std::string& _internal_mime_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mime_type(const std::string& value);
  std::string* _internal_mutable_mime_type();
  public:

  // @@protoc_insertion_point(class_scope:viam.service.vision.v1.GetObjectPointCloudsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::common::v1::PointCloudObject > objects_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mime_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_service_2fvision_2fv1_2fvision_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// GetModelParameterSchemaRequest

// string name = 1 [json_name = "name"];
inline void GetModelParameterSchemaRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& GetModelParameterSchemaRequest::name() const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.GetModelParameterSchemaRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetModelParameterSchemaRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.service.vision.v1.GetModelParameterSchemaRequest.name)
}
inline std::string* GetModelParameterSchemaRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.service.vision.v1.GetModelParameterSchemaRequest.name)
  return _s;
}
inline const std::string& GetModelParameterSchemaRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void GetModelParameterSchemaRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* GetModelParameterSchemaRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* GetModelParameterSchemaRequest::release_name() {
  // @@protoc_insertion_point(field_release:viam.service.vision.v1.GetModelParameterSchemaRequest.name)
  return _impl_.name_.Release();
}
inline void GetModelParameterSchemaRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.vision.v1.GetModelParameterSchemaRequest.name)
}

// string model_type = 2 [json_name = "modelType"];
inline void GetModelParameterSchemaRequest::clear_model_type() {
  _impl_.model_type_.ClearToEmpty();
}
inline const std::string& GetModelParameterSchemaRequest::model_type() const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.GetModelParameterSchemaRequest.model_type)
  return _internal_model_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetModelParameterSchemaRequest::set_model_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.model_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.service.vision.v1.GetModelParameterSchemaRequest.model_type)
}
inline std::string* GetModelParameterSchemaRequest::mutable_model_type() {
  std::string* _s = _internal_mutable_model_type();
  // @@protoc_insertion_point(field_mutable:viam.service.vision.v1.GetModelParameterSchemaRequest.model_type)
  return _s;
}
inline const std::string& GetModelParameterSchemaRequest::_internal_model_type() const {
  return _impl_.model_type_.Get();
}
inline void GetModelParameterSchemaRequest::_internal_set_model_type(const std::string& value) {
  
  _impl_.model_type_.Set(value, GetArenaForAllocation());
}
inline std::string* GetModelParameterSchemaRequest::_internal_mutable_model_type() {
  
  return _impl_.model_type_.Mutable(GetArenaForAllocation());
}
inline std::string* GetModelParameterSchemaRequest::release_model_type() {
  // @@protoc_insertion_point(field_release:viam.service.vision.v1.GetModelParameterSchemaRequest.model_type)
  return _impl_.model_type_.Release();
}
inline void GetModelParameterSchemaRequest::set_allocated_model_type(std::string* model_type) {
  if (model_type != nullptr) {
    
  } else {
    
  }
  _impl_.model_type_.SetAllocated(model_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.model_type_.IsDefault()) {
    _impl_.model_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.vision.v1.GetModelParameterSchemaRequest.model_type)
}

// .google.protobuf.Struct extra = 99 [json_name = "extra"];
inline bool GetModelParameterSchemaRequest::_internal_has_extra() const {
  return this != internal_default_instance() && _impl_.extra_ != nullptr;
}
inline bool GetModelParameterSchemaRequest::has_extra() const {
  return _internal_has_extra();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& GetModelParameterSchemaRequest::_internal_extra() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.extra_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& GetModelParameterSchemaRequest::extra() const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.GetModelParameterSchemaRequest.extra)
  return _internal_extra();
}
inline void GetModelParameterSchemaRequest::unsafe_arena_set_allocated_extra(
    ::PROTOBUF_NAMESPACE_ID::Struct* extra) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.extra_);
  }
  _impl_.extra_ = extra;
  if (extra) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.vision.v1.GetModelParameterSchemaRequest.extra)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* GetModelParameterSchemaRequest::release_extra() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.extra_;
  _impl_.extra_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* GetModelParameterSchemaRequest::unsafe_arena_release_extra() {
  // @@protoc_insertion_point(field_release:viam.service.vision.v1.GetModelParameterSchemaRequest.extra)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.extra_;
  _impl_.extra_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* GetModelParameterSchemaRequest::_internal_mutable_extra() {
  
  if (_impl_.extra_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.extra_ = p;
  }
  return _impl_.extra_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* GetModelParameterSchemaRequest::mutable_extra() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_extra();
  // @@protoc_insertion_point(field_mutable:viam.service.vision.v1.GetModelParameterSchemaRequest.extra)
  return _msg;
}
inline void GetModelParameterSchemaRequest::set_allocated_extra(::PROTOBUF_NAMESPACE_ID::Struct* extra) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.extra_);
  }
  if (extra) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(extra));
    if (message_arena != submessage_arena) {
      extra = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, extra, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.extra_ = extra;
  // @@protoc_insertion_point(field_set_allocated:viam.service.vision.v1.GetModelParameterSchemaRequest.extra)
}

// -------------------------------------------------------------------

// GetModelParameterSchemaResponse

// bytes model_parameter_schema = 1 [json_name = "modelParameterSchema"];
inline void GetModelParameterSchemaResponse::clear_model_parameter_schema() {
  _impl_.model_parameter_schema_.ClearToEmpty();
}
inline const std::string& GetModelParameterSchemaResponse::model_parameter_schema() const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.GetModelParameterSchemaResponse.model_parameter_schema)
  return _internal_model_parameter_schema();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetModelParameterSchemaResponse::set_model_parameter_schema(ArgT0&& arg0, ArgT... args) {
 
 _impl_.model_parameter_schema_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.service.vision.v1.GetModelParameterSchemaResponse.model_parameter_schema)
}
inline std::string* GetModelParameterSchemaResponse::mutable_model_parameter_schema() {
  std::string* _s = _internal_mutable_model_parameter_schema();
  // @@protoc_insertion_point(field_mutable:viam.service.vision.v1.GetModelParameterSchemaResponse.model_parameter_schema)
  return _s;
}
inline const std::string& GetModelParameterSchemaResponse::_internal_model_parameter_schema() const {
  return _impl_.model_parameter_schema_.Get();
}
inline void GetModelParameterSchemaResponse::_internal_set_model_parameter_schema(const std::string& value) {
  
  _impl_.model_parameter_schema_.Set(value, GetArenaForAllocation());
}
inline std::string* GetModelParameterSchemaResponse::_internal_mutable_model_parameter_schema() {
  
  return _impl_.model_parameter_schema_.Mutable(GetArenaForAllocation());
}
inline std::string* GetModelParameterSchemaResponse::release_model_parameter_schema() {
  // @@protoc_insertion_point(field_release:viam.service.vision.v1.GetModelParameterSchemaResponse.model_parameter_schema)
  return _impl_.model_parameter_schema_.Release();
}
inline void GetModelParameterSchemaResponse::set_allocated_model_parameter_schema(std::string* model_parameter_schema) {
  if (model_parameter_schema != nullptr) {
    
  } else {
    
  }
  _impl_.model_parameter_schema_.SetAllocated(model_parameter_schema, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.model_parameter_schema_.IsDefault()) {
    _impl_.model_parameter_schema_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.vision.v1.GetModelParameterSchemaResponse.model_parameter_schema)
}

// -------------------------------------------------------------------

// GetDetectorNamesRequest

// string name = 1 [json_name = "name"];
inline void GetDetectorNamesRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& GetDetectorNamesRequest::name() const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.GetDetectorNamesRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetDetectorNamesRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.service.vision.v1.GetDetectorNamesRequest.name)
}
inline std::string* GetDetectorNamesRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.service.vision.v1.GetDetectorNamesRequest.name)
  return _s;
}
inline const std::string& GetDetectorNamesRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void GetDetectorNamesRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* GetDetectorNamesRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* GetDetectorNamesRequest::release_name() {
  // @@protoc_insertion_point(field_release:viam.service.vision.v1.GetDetectorNamesRequest.name)
  return _impl_.name_.Release();
}
inline void GetDetectorNamesRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.vision.v1.GetDetectorNamesRequest.name)
}

// .google.protobuf.Struct extra = 99 [json_name = "extra"];
inline bool GetDetectorNamesRequest::_internal_has_extra() const {
  return this != internal_default_instance() && _impl_.extra_ != nullptr;
}
inline bool GetDetectorNamesRequest::has_extra() const {
  return _internal_has_extra();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& GetDetectorNamesRequest::_internal_extra() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.extra_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& GetDetectorNamesRequest::extra() const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.GetDetectorNamesRequest.extra)
  return _internal_extra();
}
inline void GetDetectorNamesRequest::unsafe_arena_set_allocated_extra(
    ::PROTOBUF_NAMESPACE_ID::Struct* extra) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.extra_);
  }
  _impl_.extra_ = extra;
  if (extra) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.vision.v1.GetDetectorNamesRequest.extra)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* GetDetectorNamesRequest::release_extra() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.extra_;
  _impl_.extra_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* GetDetectorNamesRequest::unsafe_arena_release_extra() {
  // @@protoc_insertion_point(field_release:viam.service.vision.v1.GetDetectorNamesRequest.extra)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.extra_;
  _impl_.extra_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* GetDetectorNamesRequest::_internal_mutable_extra() {
  
  if (_impl_.extra_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.extra_ = p;
  }
  return _impl_.extra_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* GetDetectorNamesRequest::mutable_extra() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_extra();
  // @@protoc_insertion_point(field_mutable:viam.service.vision.v1.GetDetectorNamesRequest.extra)
  return _msg;
}
inline void GetDetectorNamesRequest::set_allocated_extra(::PROTOBUF_NAMESPACE_ID::Struct* extra) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.extra_);
  }
  if (extra) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(extra));
    if (message_arena != submessage_arena) {
      extra = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, extra, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.extra_ = extra;
  // @@protoc_insertion_point(field_set_allocated:viam.service.vision.v1.GetDetectorNamesRequest.extra)
}

// -------------------------------------------------------------------

// GetDetectorNamesResponse

// repeated string detector_names = 1 [json_name = "detectorNames"];
inline int GetDetectorNamesResponse::_internal_detector_names_size() const {
  return _impl_.detector_names_.size();
}
inline int GetDetectorNamesResponse::detector_names_size() const {
  return _internal_detector_names_size();
}
inline void GetDetectorNamesResponse::clear_detector_names() {
  _impl_.detector_names_.Clear();
}
inline std::string* GetDetectorNamesResponse::add_detector_names() {
  std::string* _s = _internal_add_detector_names();
  // @@protoc_insertion_point(field_add_mutable:viam.service.vision.v1.GetDetectorNamesResponse.detector_names)
  return _s;
}
inline const std::string& GetDetectorNamesResponse::_internal_detector_names(int index) const {
  return _impl_.detector_names_.Get(index);
}
inline const std::string& GetDetectorNamesResponse::detector_names(int index) const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.GetDetectorNamesResponse.detector_names)
  return _internal_detector_names(index);
}
inline std::string* GetDetectorNamesResponse::mutable_detector_names(int index) {
  // @@protoc_insertion_point(field_mutable:viam.service.vision.v1.GetDetectorNamesResponse.detector_names)
  return _impl_.detector_names_.Mutable(index);
}
inline void GetDetectorNamesResponse::set_detector_names(int index, const std::string& value) {
  _impl_.detector_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:viam.service.vision.v1.GetDetectorNamesResponse.detector_names)
}
inline void GetDetectorNamesResponse::set_detector_names(int index, std::string&& value) {
  _impl_.detector_names_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:viam.service.vision.v1.GetDetectorNamesResponse.detector_names)
}
inline void GetDetectorNamesResponse::set_detector_names(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.detector_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:viam.service.vision.v1.GetDetectorNamesResponse.detector_names)
}
inline void GetDetectorNamesResponse::set_detector_names(int index, const char* value, size_t size) {
  _impl_.detector_names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:viam.service.vision.v1.GetDetectorNamesResponse.detector_names)
}
inline std::string* GetDetectorNamesResponse::_internal_add_detector_names() {
  return _impl_.detector_names_.Add();
}
inline void GetDetectorNamesResponse::add_detector_names(const std::string& value) {
  _impl_.detector_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:viam.service.vision.v1.GetDetectorNamesResponse.detector_names)
}
inline void GetDetectorNamesResponse::add_detector_names(std::string&& value) {
  _impl_.detector_names_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:viam.service.vision.v1.GetDetectorNamesResponse.detector_names)
}
inline void GetDetectorNamesResponse::add_detector_names(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.detector_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:viam.service.vision.v1.GetDetectorNamesResponse.detector_names)
}
inline void GetDetectorNamesResponse::add_detector_names(const char* value, size_t size) {
  _impl_.detector_names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:viam.service.vision.v1.GetDetectorNamesResponse.detector_names)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetDetectorNamesResponse::detector_names() const {
  // @@protoc_insertion_point(field_list:viam.service.vision.v1.GetDetectorNamesResponse.detector_names)
  return _impl_.detector_names_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetDetectorNamesResponse::mutable_detector_names() {
  // @@protoc_insertion_point(field_mutable_list:viam.service.vision.v1.GetDetectorNamesResponse.detector_names)
  return &_impl_.detector_names_;
}

// -------------------------------------------------------------------

// AddDetectorRequest

// string name = 1 [json_name = "name"];
inline void AddDetectorRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& AddDetectorRequest::name() const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.AddDetectorRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddDetectorRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.service.vision.v1.AddDetectorRequest.name)
}
inline std::string* AddDetectorRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.service.vision.v1.AddDetectorRequest.name)
  return _s;
}
inline const std::string& AddDetectorRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void AddDetectorRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* AddDetectorRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* AddDetectorRequest::release_name() {
  // @@protoc_insertion_point(field_release:viam.service.vision.v1.AddDetectorRequest.name)
  return _impl_.name_.Release();
}
inline void AddDetectorRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.vision.v1.AddDetectorRequest.name)
}

// string detector_name = 2 [json_name = "detectorName"];
inline void AddDetectorRequest::clear_detector_name() {
  _impl_.detector_name_.ClearToEmpty();
}
inline const std::string& AddDetectorRequest::detector_name() const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.AddDetectorRequest.detector_name)
  return _internal_detector_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddDetectorRequest::set_detector_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.detector_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.service.vision.v1.AddDetectorRequest.detector_name)
}
inline std::string* AddDetectorRequest::mutable_detector_name() {
  std::string* _s = _internal_mutable_detector_name();
  // @@protoc_insertion_point(field_mutable:viam.service.vision.v1.AddDetectorRequest.detector_name)
  return _s;
}
inline const std::string& AddDetectorRequest::_internal_detector_name() const {
  return _impl_.detector_name_.Get();
}
inline void AddDetectorRequest::_internal_set_detector_name(const std::string& value) {
  
  _impl_.detector_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AddDetectorRequest::_internal_mutable_detector_name() {
  
  return _impl_.detector_name_.Mutable(GetArenaForAllocation());
}
inline std::string* AddDetectorRequest::release_detector_name() {
  // @@protoc_insertion_point(field_release:viam.service.vision.v1.AddDetectorRequest.detector_name)
  return _impl_.detector_name_.Release();
}
inline void AddDetectorRequest::set_allocated_detector_name(std::string* detector_name) {
  if (detector_name != nullptr) {
    
  } else {
    
  }
  _impl_.detector_name_.SetAllocated(detector_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.detector_name_.IsDefault()) {
    _impl_.detector_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.vision.v1.AddDetectorRequest.detector_name)
}

// string detector_model_type = 3 [json_name = "detectorModelType"];
inline void AddDetectorRequest::clear_detector_model_type() {
  _impl_.detector_model_type_.ClearToEmpty();
}
inline const std::string& AddDetectorRequest::detector_model_type() const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.AddDetectorRequest.detector_model_type)
  return _internal_detector_model_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddDetectorRequest::set_detector_model_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.detector_model_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.service.vision.v1.AddDetectorRequest.detector_model_type)
}
inline std::string* AddDetectorRequest::mutable_detector_model_type() {
  std::string* _s = _internal_mutable_detector_model_type();
  // @@protoc_insertion_point(field_mutable:viam.service.vision.v1.AddDetectorRequest.detector_model_type)
  return _s;
}
inline const std::string& AddDetectorRequest::_internal_detector_model_type() const {
  return _impl_.detector_model_type_.Get();
}
inline void AddDetectorRequest::_internal_set_detector_model_type(const std::string& value) {
  
  _impl_.detector_model_type_.Set(value, GetArenaForAllocation());
}
inline std::string* AddDetectorRequest::_internal_mutable_detector_model_type() {
  
  return _impl_.detector_model_type_.Mutable(GetArenaForAllocation());
}
inline std::string* AddDetectorRequest::release_detector_model_type() {
  // @@protoc_insertion_point(field_release:viam.service.vision.v1.AddDetectorRequest.detector_model_type)
  return _impl_.detector_model_type_.Release();
}
inline void AddDetectorRequest::set_allocated_detector_model_type(std::string* detector_model_type) {
  if (detector_model_type != nullptr) {
    
  } else {
    
  }
  _impl_.detector_model_type_.SetAllocated(detector_model_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.detector_model_type_.IsDefault()) {
    _impl_.detector_model_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.vision.v1.AddDetectorRequest.detector_model_type)
}

// .google.protobuf.Struct detector_parameters = 4 [json_name = "detectorParameters"];
inline bool AddDetectorRequest::_internal_has_detector_parameters() const {
  return this != internal_default_instance() && _impl_.detector_parameters_ != nullptr;
}
inline bool AddDetectorRequest::has_detector_parameters() const {
  return _internal_has_detector_parameters();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& AddDetectorRequest::_internal_detector_parameters() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.detector_parameters_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& AddDetectorRequest::detector_parameters() const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.AddDetectorRequest.detector_parameters)
  return _internal_detector_parameters();
}
inline void AddDetectorRequest::unsafe_arena_set_allocated_detector_parameters(
    ::PROTOBUF_NAMESPACE_ID::Struct* detector_parameters) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.detector_parameters_);
  }
  _impl_.detector_parameters_ = detector_parameters;
  if (detector_parameters) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.vision.v1.AddDetectorRequest.detector_parameters)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AddDetectorRequest::release_detector_parameters() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.detector_parameters_;
  _impl_.detector_parameters_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AddDetectorRequest::unsafe_arena_release_detector_parameters() {
  // @@protoc_insertion_point(field_release:viam.service.vision.v1.AddDetectorRequest.detector_parameters)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.detector_parameters_;
  _impl_.detector_parameters_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AddDetectorRequest::_internal_mutable_detector_parameters() {
  
  if (_impl_.detector_parameters_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.detector_parameters_ = p;
  }
  return _impl_.detector_parameters_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AddDetectorRequest::mutable_detector_parameters() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_detector_parameters();
  // @@protoc_insertion_point(field_mutable:viam.service.vision.v1.AddDetectorRequest.detector_parameters)
  return _msg;
}
inline void AddDetectorRequest::set_allocated_detector_parameters(::PROTOBUF_NAMESPACE_ID::Struct* detector_parameters) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.detector_parameters_);
  }
  if (detector_parameters) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(detector_parameters));
    if (message_arena != submessage_arena) {
      detector_parameters = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, detector_parameters, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.detector_parameters_ = detector_parameters;
  // @@protoc_insertion_point(field_set_allocated:viam.service.vision.v1.AddDetectorRequest.detector_parameters)
}

// .google.protobuf.Struct extra = 99 [json_name = "extra"];
inline bool AddDetectorRequest::_internal_has_extra() const {
  return this != internal_default_instance() && _impl_.extra_ != nullptr;
}
inline bool AddDetectorRequest::has_extra() const {
  return _internal_has_extra();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& AddDetectorRequest::_internal_extra() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.extra_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& AddDetectorRequest::extra() const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.AddDetectorRequest.extra)
  return _internal_extra();
}
inline void AddDetectorRequest::unsafe_arena_set_allocated_extra(
    ::PROTOBUF_NAMESPACE_ID::Struct* extra) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.extra_);
  }
  _impl_.extra_ = extra;
  if (extra) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.vision.v1.AddDetectorRequest.extra)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AddDetectorRequest::release_extra() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.extra_;
  _impl_.extra_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AddDetectorRequest::unsafe_arena_release_extra() {
  // @@protoc_insertion_point(field_release:viam.service.vision.v1.AddDetectorRequest.extra)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.extra_;
  _impl_.extra_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AddDetectorRequest::_internal_mutable_extra() {
  
  if (_impl_.extra_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.extra_ = p;
  }
  return _impl_.extra_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AddDetectorRequest::mutable_extra() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_extra();
  // @@protoc_insertion_point(field_mutable:viam.service.vision.v1.AddDetectorRequest.extra)
  return _msg;
}
inline void AddDetectorRequest::set_allocated_extra(::PROTOBUF_NAMESPACE_ID::Struct* extra) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.extra_);
  }
  if (extra) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(extra));
    if (message_arena != submessage_arena) {
      extra = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, extra, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.extra_ = extra;
  // @@protoc_insertion_point(field_set_allocated:viam.service.vision.v1.AddDetectorRequest.extra)
}

// -------------------------------------------------------------------

// AddDetectorResponse

// -------------------------------------------------------------------

// RemoveDetectorRequest

// string name = 1 [json_name = "name"];
inline void RemoveDetectorRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& RemoveDetectorRequest::name() const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.RemoveDetectorRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RemoveDetectorRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.service.vision.v1.RemoveDetectorRequest.name)
}
inline std::string* RemoveDetectorRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.service.vision.v1.RemoveDetectorRequest.name)
  return _s;
}
inline const std::string& RemoveDetectorRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void RemoveDetectorRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* RemoveDetectorRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* RemoveDetectorRequest::release_name() {
  // @@protoc_insertion_point(field_release:viam.service.vision.v1.RemoveDetectorRequest.name)
  return _impl_.name_.Release();
}
inline void RemoveDetectorRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.vision.v1.RemoveDetectorRequest.name)
}

// string detector_name = 2 [json_name = "detectorName"];
inline void RemoveDetectorRequest::clear_detector_name() {
  _impl_.detector_name_.ClearToEmpty();
}
inline const std::string& RemoveDetectorRequest::detector_name() const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.RemoveDetectorRequest.detector_name)
  return _internal_detector_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RemoveDetectorRequest::set_detector_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.detector_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.service.vision.v1.RemoveDetectorRequest.detector_name)
}
inline std::string* RemoveDetectorRequest::mutable_detector_name() {
  std::string* _s = _internal_mutable_detector_name();
  // @@protoc_insertion_point(field_mutable:viam.service.vision.v1.RemoveDetectorRequest.detector_name)
  return _s;
}
inline const std::string& RemoveDetectorRequest::_internal_detector_name() const {
  return _impl_.detector_name_.Get();
}
inline void RemoveDetectorRequest::_internal_set_detector_name(const std::string& value) {
  
  _impl_.detector_name_.Set(value, GetArenaForAllocation());
}
inline std::string* RemoveDetectorRequest::_internal_mutable_detector_name() {
  
  return _impl_.detector_name_.Mutable(GetArenaForAllocation());
}
inline std::string* RemoveDetectorRequest::release_detector_name() {
  // @@protoc_insertion_point(field_release:viam.service.vision.v1.RemoveDetectorRequest.detector_name)
  return _impl_.detector_name_.Release();
}
inline void RemoveDetectorRequest::set_allocated_detector_name(std::string* detector_name) {
  if (detector_name != nullptr) {
    
  } else {
    
  }
  _impl_.detector_name_.SetAllocated(detector_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.detector_name_.IsDefault()) {
    _impl_.detector_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.vision.v1.RemoveDetectorRequest.detector_name)
}

// .google.protobuf.Struct extra = 99 [json_name = "extra"];
inline bool RemoveDetectorRequest::_internal_has_extra() const {
  return this != internal_default_instance() && _impl_.extra_ != nullptr;
}
inline bool RemoveDetectorRequest::has_extra() const {
  return _internal_has_extra();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& RemoveDetectorRequest::_internal_extra() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.extra_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& RemoveDetectorRequest::extra() const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.RemoveDetectorRequest.extra)
  return _internal_extra();
}
inline void RemoveDetectorRequest::unsafe_arena_set_allocated_extra(
    ::PROTOBUF_NAMESPACE_ID::Struct* extra) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.extra_);
  }
  _impl_.extra_ = extra;
  if (extra) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.vision.v1.RemoveDetectorRequest.extra)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* RemoveDetectorRequest::release_extra() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.extra_;
  _impl_.extra_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* RemoveDetectorRequest::unsafe_arena_release_extra() {
  // @@protoc_insertion_point(field_release:viam.service.vision.v1.RemoveDetectorRequest.extra)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.extra_;
  _impl_.extra_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* RemoveDetectorRequest::_internal_mutable_extra() {
  
  if (_impl_.extra_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.extra_ = p;
  }
  return _impl_.extra_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* RemoveDetectorRequest::mutable_extra() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_extra();
  // @@protoc_insertion_point(field_mutable:viam.service.vision.v1.RemoveDetectorRequest.extra)
  return _msg;
}
inline void RemoveDetectorRequest::set_allocated_extra(::PROTOBUF_NAMESPACE_ID::Struct* extra) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.extra_);
  }
  if (extra) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(extra));
    if (message_arena != submessage_arena) {
      extra = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, extra, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.extra_ = extra;
  // @@protoc_insertion_point(field_set_allocated:viam.service.vision.v1.RemoveDetectorRequest.extra)
}

// -------------------------------------------------------------------

// RemoveDetectorResponse

// -------------------------------------------------------------------

// GetDetectionsRequest

// string name = 1 [json_name = "name"];
inline void GetDetectionsRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& GetDetectionsRequest::name() const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.GetDetectionsRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetDetectionsRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.service.vision.v1.GetDetectionsRequest.name)
}
inline std::string* GetDetectionsRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.service.vision.v1.GetDetectionsRequest.name)
  return _s;
}
inline const std::string& GetDetectionsRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void GetDetectionsRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* GetDetectionsRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* GetDetectionsRequest::release_name() {
  // @@protoc_insertion_point(field_release:viam.service.vision.v1.GetDetectionsRequest.name)
  return _impl_.name_.Release();
}
inline void GetDetectionsRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.vision.v1.GetDetectionsRequest.name)
}

// bytes image = 2 [json_name = "image"];
inline void GetDetectionsRequest::clear_image() {
  _impl_.image_.ClearToEmpty();
}
inline const std::string& GetDetectionsRequest::image() const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.GetDetectionsRequest.image)
  return _internal_image();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetDetectionsRequest::set_image(ArgT0&& arg0, ArgT... args) {
 
 _impl_.image_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.service.vision.v1.GetDetectionsRequest.image)
}
inline std::string* GetDetectionsRequest::mutable_image() {
  std::string* _s = _internal_mutable_image();
  // @@protoc_insertion_point(field_mutable:viam.service.vision.v1.GetDetectionsRequest.image)
  return _s;
}
inline const std::string& GetDetectionsRequest::_internal_image() const {
  return _impl_.image_.Get();
}
inline void GetDetectionsRequest::_internal_set_image(const std::string& value) {
  
  _impl_.image_.Set(value, GetArenaForAllocation());
}
inline std::string* GetDetectionsRequest::_internal_mutable_image() {
  
  return _impl_.image_.Mutable(GetArenaForAllocation());
}
inline std::string* GetDetectionsRequest::release_image() {
  // @@protoc_insertion_point(field_release:viam.service.vision.v1.GetDetectionsRequest.image)
  return _impl_.image_.Release();
}
inline void GetDetectionsRequest::set_allocated_image(std::string* image) {
  if (image != nullptr) {
    
  } else {
    
  }
  _impl_.image_.SetAllocated(image, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.image_.IsDefault()) {
    _impl_.image_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.vision.v1.GetDetectionsRequest.image)
}

// int64 width = 3 [json_name = "width"];
inline void GetDetectionsRequest::clear_width() {
  _impl_.width_ = int64_t{0};
}
inline int64_t GetDetectionsRequest::_internal_width() const {
  return _impl_.width_;
}
inline int64_t GetDetectionsRequest::width() const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.GetDetectionsRequest.width)
  return _internal_width();
}
inline void GetDetectionsRequest::_internal_set_width(int64_t value) {
  
  _impl_.width_ = value;
}
inline void GetDetectionsRequest::set_width(int64_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:viam.service.vision.v1.GetDetectionsRequest.width)
}

// int64 height = 4 [json_name = "height"];
inline void GetDetectionsRequest::clear_height() {
  _impl_.height_ = int64_t{0};
}
inline int64_t GetDetectionsRequest::_internal_height() const {
  return _impl_.height_;
}
inline int64_t GetDetectionsRequest::height() const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.GetDetectionsRequest.height)
  return _internal_height();
}
inline void GetDetectionsRequest::_internal_set_height(int64_t value) {
  
  _impl_.height_ = value;
}
inline void GetDetectionsRequest::set_height(int64_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:viam.service.vision.v1.GetDetectionsRequest.height)
}

// string mime_type = 5 [json_name = "mimeType"];
inline void GetDetectionsRequest::clear_mime_type() {
  _impl_.mime_type_.ClearToEmpty();
}
inline const std::string& GetDetectionsRequest::mime_type() const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.GetDetectionsRequest.mime_type)
  return _internal_mime_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetDetectionsRequest::set_mime_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mime_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.service.vision.v1.GetDetectionsRequest.mime_type)
}
inline std::string* GetDetectionsRequest::mutable_mime_type() {
  std::string* _s = _internal_mutable_mime_type();
  // @@protoc_insertion_point(field_mutable:viam.service.vision.v1.GetDetectionsRequest.mime_type)
  return _s;
}
inline const std::string& GetDetectionsRequest::_internal_mime_type() const {
  return _impl_.mime_type_.Get();
}
inline void GetDetectionsRequest::_internal_set_mime_type(const std::string& value) {
  
  _impl_.mime_type_.Set(value, GetArenaForAllocation());
}
inline std::string* GetDetectionsRequest::_internal_mutable_mime_type() {
  
  return _impl_.mime_type_.Mutable(GetArenaForAllocation());
}
inline std::string* GetDetectionsRequest::release_mime_type() {
  // @@protoc_insertion_point(field_release:viam.service.vision.v1.GetDetectionsRequest.mime_type)
  return _impl_.mime_type_.Release();
}
inline void GetDetectionsRequest::set_allocated_mime_type(std::string* mime_type) {
  if (mime_type != nullptr) {
    
  } else {
    
  }
  _impl_.mime_type_.SetAllocated(mime_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mime_type_.IsDefault()) {
    _impl_.mime_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.vision.v1.GetDetectionsRequest.mime_type)
}

// string detector_name = 6 [json_name = "detectorName"];
inline void GetDetectionsRequest::clear_detector_name() {
  _impl_.detector_name_.ClearToEmpty();
}
inline const std::string& GetDetectionsRequest::detector_name() const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.GetDetectionsRequest.detector_name)
  return _internal_detector_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetDetectionsRequest::set_detector_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.detector_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.service.vision.v1.GetDetectionsRequest.detector_name)
}
inline std::string* GetDetectionsRequest::mutable_detector_name() {
  std::string* _s = _internal_mutable_detector_name();
  // @@protoc_insertion_point(field_mutable:viam.service.vision.v1.GetDetectionsRequest.detector_name)
  return _s;
}
inline const std::string& GetDetectionsRequest::_internal_detector_name() const {
  return _impl_.detector_name_.Get();
}
inline void GetDetectionsRequest::_internal_set_detector_name(const std::string& value) {
  
  _impl_.detector_name_.Set(value, GetArenaForAllocation());
}
inline std::string* GetDetectionsRequest::_internal_mutable_detector_name() {
  
  return _impl_.detector_name_.Mutable(GetArenaForAllocation());
}
inline std::string* GetDetectionsRequest::release_detector_name() {
  // @@protoc_insertion_point(field_release:viam.service.vision.v1.GetDetectionsRequest.detector_name)
  return _impl_.detector_name_.Release();
}
inline void GetDetectionsRequest::set_allocated_detector_name(std::string* detector_name) {
  if (detector_name != nullptr) {
    
  } else {
    
  }
  _impl_.detector_name_.SetAllocated(detector_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.detector_name_.IsDefault()) {
    _impl_.detector_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.vision.v1.GetDetectionsRequest.detector_name)
}

// .google.protobuf.Struct extra = 99 [json_name = "extra"];
inline bool GetDetectionsRequest::_internal_has_extra() const {
  return this != internal_default_instance() && _impl_.extra_ != nullptr;
}
inline bool GetDetectionsRequest::has_extra() const {
  return _internal_has_extra();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& GetDetectionsRequest::_internal_extra() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.extra_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& GetDetectionsRequest::extra() const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.GetDetectionsRequest.extra)
  return _internal_extra();
}
inline void GetDetectionsRequest::unsafe_arena_set_allocated_extra(
    ::PROTOBUF_NAMESPACE_ID::Struct* extra) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.extra_);
  }
  _impl_.extra_ = extra;
  if (extra) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.vision.v1.GetDetectionsRequest.extra)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* GetDetectionsRequest::release_extra() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.extra_;
  _impl_.extra_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* GetDetectionsRequest::unsafe_arena_release_extra() {
  // @@protoc_insertion_point(field_release:viam.service.vision.v1.GetDetectionsRequest.extra)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.extra_;
  _impl_.extra_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* GetDetectionsRequest::_internal_mutable_extra() {
  
  if (_impl_.extra_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.extra_ = p;
  }
  return _impl_.extra_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* GetDetectionsRequest::mutable_extra() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_extra();
  // @@protoc_insertion_point(field_mutable:viam.service.vision.v1.GetDetectionsRequest.extra)
  return _msg;
}
inline void GetDetectionsRequest::set_allocated_extra(::PROTOBUF_NAMESPACE_ID::Struct* extra) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.extra_);
  }
  if (extra) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(extra));
    if (message_arena != submessage_arena) {
      extra = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, extra, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.extra_ = extra;
  // @@protoc_insertion_point(field_set_allocated:viam.service.vision.v1.GetDetectionsRequest.extra)
}

// -------------------------------------------------------------------

// GetDetectionsResponse

// repeated .viam.service.vision.v1.Detection detections = 1 [json_name = "detections"];
inline int GetDetectionsResponse::_internal_detections_size() const {
  return _impl_.detections_.size();
}
inline int GetDetectionsResponse::detections_size() const {
  return _internal_detections_size();
}
inline void GetDetectionsResponse::clear_detections() {
  _impl_.detections_.Clear();
}
inline ::viam::service::vision::v1::Detection* GetDetectionsResponse::mutable_detections(int index) {
  // @@protoc_insertion_point(field_mutable:viam.service.vision.v1.GetDetectionsResponse.detections)
  return _impl_.detections_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::service::vision::v1::Detection >*
GetDetectionsResponse::mutable_detections() {
  // @@protoc_insertion_point(field_mutable_list:viam.service.vision.v1.GetDetectionsResponse.detections)
  return &_impl_.detections_;
}
inline const ::viam::service::vision::v1::Detection& GetDetectionsResponse::_internal_detections(int index) const {
  return _impl_.detections_.Get(index);
}
inline const ::viam::service::vision::v1::Detection& GetDetectionsResponse::detections(int index) const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.GetDetectionsResponse.detections)
  return _internal_detections(index);
}
inline ::viam::service::vision::v1::Detection* GetDetectionsResponse::_internal_add_detections() {
  return _impl_.detections_.Add();
}
inline ::viam::service::vision::v1::Detection* GetDetectionsResponse::add_detections() {
  ::viam::service::vision::v1::Detection* _add = _internal_add_detections();
  // @@protoc_insertion_point(field_add:viam.service.vision.v1.GetDetectionsResponse.detections)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::service::vision::v1::Detection >&
GetDetectionsResponse::detections() const {
  // @@protoc_insertion_point(field_list:viam.service.vision.v1.GetDetectionsResponse.detections)
  return _impl_.detections_;
}

// -------------------------------------------------------------------

// GetDetectionsFromCameraRequest

// string name = 1 [json_name = "name"];
inline void GetDetectionsFromCameraRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& GetDetectionsFromCameraRequest::name() const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.GetDetectionsFromCameraRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetDetectionsFromCameraRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.service.vision.v1.GetDetectionsFromCameraRequest.name)
}
inline std::string* GetDetectionsFromCameraRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.service.vision.v1.GetDetectionsFromCameraRequest.name)
  return _s;
}
inline const std::string& GetDetectionsFromCameraRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void GetDetectionsFromCameraRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* GetDetectionsFromCameraRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* GetDetectionsFromCameraRequest::release_name() {
  // @@protoc_insertion_point(field_release:viam.service.vision.v1.GetDetectionsFromCameraRequest.name)
  return _impl_.name_.Release();
}
inline void GetDetectionsFromCameraRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.vision.v1.GetDetectionsFromCameraRequest.name)
}

// string camera_name = 2 [json_name = "cameraName"];
inline void GetDetectionsFromCameraRequest::clear_camera_name() {
  _impl_.camera_name_.ClearToEmpty();
}
inline const std::string& GetDetectionsFromCameraRequest::camera_name() const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.GetDetectionsFromCameraRequest.camera_name)
  return _internal_camera_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetDetectionsFromCameraRequest::set_camera_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.camera_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.service.vision.v1.GetDetectionsFromCameraRequest.camera_name)
}
inline std::string* GetDetectionsFromCameraRequest::mutable_camera_name() {
  std::string* _s = _internal_mutable_camera_name();
  // @@protoc_insertion_point(field_mutable:viam.service.vision.v1.GetDetectionsFromCameraRequest.camera_name)
  return _s;
}
inline const std::string& GetDetectionsFromCameraRequest::_internal_camera_name() const {
  return _impl_.camera_name_.Get();
}
inline void GetDetectionsFromCameraRequest::_internal_set_camera_name(const std::string& value) {
  
  _impl_.camera_name_.Set(value, GetArenaForAllocation());
}
inline std::string* GetDetectionsFromCameraRequest::_internal_mutable_camera_name() {
  
  return _impl_.camera_name_.Mutable(GetArenaForAllocation());
}
inline std::string* GetDetectionsFromCameraRequest::release_camera_name() {
  // @@protoc_insertion_point(field_release:viam.service.vision.v1.GetDetectionsFromCameraRequest.camera_name)
  return _impl_.camera_name_.Release();
}
inline void GetDetectionsFromCameraRequest::set_allocated_camera_name(std::string* camera_name) {
  if (camera_name != nullptr) {
    
  } else {
    
  }
  _impl_.camera_name_.SetAllocated(camera_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.camera_name_.IsDefault()) {
    _impl_.camera_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.vision.v1.GetDetectionsFromCameraRequest.camera_name)
}

// string detector_name = 3 [json_name = "detectorName"];
inline void GetDetectionsFromCameraRequest::clear_detector_name() {
  _impl_.detector_name_.ClearToEmpty();
}
inline const std::string& GetDetectionsFromCameraRequest::detector_name() const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.GetDetectionsFromCameraRequest.detector_name)
  return _internal_detector_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetDetectionsFromCameraRequest::set_detector_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.detector_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.service.vision.v1.GetDetectionsFromCameraRequest.detector_name)
}
inline std::string* GetDetectionsFromCameraRequest::mutable_detector_name() {
  std::string* _s = _internal_mutable_detector_name();
  // @@protoc_insertion_point(field_mutable:viam.service.vision.v1.GetDetectionsFromCameraRequest.detector_name)
  return _s;
}
inline const std::string& GetDetectionsFromCameraRequest::_internal_detector_name() const {
  return _impl_.detector_name_.Get();
}
inline void GetDetectionsFromCameraRequest::_internal_set_detector_name(const std::string& value) {
  
  _impl_.detector_name_.Set(value, GetArenaForAllocation());
}
inline std::string* GetDetectionsFromCameraRequest::_internal_mutable_detector_name() {
  
  return _impl_.detector_name_.Mutable(GetArenaForAllocation());
}
inline std::string* GetDetectionsFromCameraRequest::release_detector_name() {
  // @@protoc_insertion_point(field_release:viam.service.vision.v1.GetDetectionsFromCameraRequest.detector_name)
  return _impl_.detector_name_.Release();
}
inline void GetDetectionsFromCameraRequest::set_allocated_detector_name(std::string* detector_name) {
  if (detector_name != nullptr) {
    
  } else {
    
  }
  _impl_.detector_name_.SetAllocated(detector_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.detector_name_.IsDefault()) {
    _impl_.detector_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.vision.v1.GetDetectionsFromCameraRequest.detector_name)
}

// .google.protobuf.Struct extra = 99 [json_name = "extra"];
inline bool GetDetectionsFromCameraRequest::_internal_has_extra() const {
  return this != internal_default_instance() && _impl_.extra_ != nullptr;
}
inline bool GetDetectionsFromCameraRequest::has_extra() const {
  return _internal_has_extra();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& GetDetectionsFromCameraRequest::_internal_extra() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.extra_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& GetDetectionsFromCameraRequest::extra() const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.GetDetectionsFromCameraRequest.extra)
  return _internal_extra();
}
inline void GetDetectionsFromCameraRequest::unsafe_arena_set_allocated_extra(
    ::PROTOBUF_NAMESPACE_ID::Struct* extra) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.extra_);
  }
  _impl_.extra_ = extra;
  if (extra) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.vision.v1.GetDetectionsFromCameraRequest.extra)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* GetDetectionsFromCameraRequest::release_extra() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.extra_;
  _impl_.extra_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* GetDetectionsFromCameraRequest::unsafe_arena_release_extra() {
  // @@protoc_insertion_point(field_release:viam.service.vision.v1.GetDetectionsFromCameraRequest.extra)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.extra_;
  _impl_.extra_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* GetDetectionsFromCameraRequest::_internal_mutable_extra() {
  
  if (_impl_.extra_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.extra_ = p;
  }
  return _impl_.extra_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* GetDetectionsFromCameraRequest::mutable_extra() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_extra();
  // @@protoc_insertion_point(field_mutable:viam.service.vision.v1.GetDetectionsFromCameraRequest.extra)
  return _msg;
}
inline void GetDetectionsFromCameraRequest::set_allocated_extra(::PROTOBUF_NAMESPACE_ID::Struct* extra) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.extra_);
  }
  if (extra) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(extra));
    if (message_arena != submessage_arena) {
      extra = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, extra, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.extra_ = extra;
  // @@protoc_insertion_point(field_set_allocated:viam.service.vision.v1.GetDetectionsFromCameraRequest.extra)
}

// -------------------------------------------------------------------

// GetDetectionsFromCameraResponse

// repeated .viam.service.vision.v1.Detection detections = 1 [json_name = "detections"];
inline int GetDetectionsFromCameraResponse::_internal_detections_size() const {
  return _impl_.detections_.size();
}
inline int GetDetectionsFromCameraResponse::detections_size() const {
  return _internal_detections_size();
}
inline void GetDetectionsFromCameraResponse::clear_detections() {
  _impl_.detections_.Clear();
}
inline ::viam::service::vision::v1::Detection* GetDetectionsFromCameraResponse::mutable_detections(int index) {
  // @@protoc_insertion_point(field_mutable:viam.service.vision.v1.GetDetectionsFromCameraResponse.detections)
  return _impl_.detections_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::service::vision::v1::Detection >*
GetDetectionsFromCameraResponse::mutable_detections() {
  // @@protoc_insertion_point(field_mutable_list:viam.service.vision.v1.GetDetectionsFromCameraResponse.detections)
  return &_impl_.detections_;
}
inline const ::viam::service::vision::v1::Detection& GetDetectionsFromCameraResponse::_internal_detections(int index) const {
  return _impl_.detections_.Get(index);
}
inline const ::viam::service::vision::v1::Detection& GetDetectionsFromCameraResponse::detections(int index) const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.GetDetectionsFromCameraResponse.detections)
  return _internal_detections(index);
}
inline ::viam::service::vision::v1::Detection* GetDetectionsFromCameraResponse::_internal_add_detections() {
  return _impl_.detections_.Add();
}
inline ::viam::service::vision::v1::Detection* GetDetectionsFromCameraResponse::add_detections() {
  ::viam::service::vision::v1::Detection* _add = _internal_add_detections();
  // @@protoc_insertion_point(field_add:viam.service.vision.v1.GetDetectionsFromCameraResponse.detections)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::service::vision::v1::Detection >&
GetDetectionsFromCameraResponse::detections() const {
  // @@protoc_insertion_point(field_list:viam.service.vision.v1.GetDetectionsFromCameraResponse.detections)
  return _impl_.detections_;
}

// -------------------------------------------------------------------

// Detection

// optional int64 x_min = 1 [json_name = "xMin"];
inline bool Detection::_internal_has_x_min() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Detection::has_x_min() const {
  return _internal_has_x_min();
}
inline void Detection::clear_x_min() {
  _impl_.x_min_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t Detection::_internal_x_min() const {
  return _impl_.x_min_;
}
inline int64_t Detection::x_min() const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.Detection.x_min)
  return _internal_x_min();
}
inline void Detection::_internal_set_x_min(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.x_min_ = value;
}
inline void Detection::set_x_min(int64_t value) {
  _internal_set_x_min(value);
  // @@protoc_insertion_point(field_set:viam.service.vision.v1.Detection.x_min)
}

// optional int64 y_min = 2 [json_name = "yMin"];
inline bool Detection::_internal_has_y_min() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Detection::has_y_min() const {
  return _internal_has_y_min();
}
inline void Detection::clear_y_min() {
  _impl_.y_min_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t Detection::_internal_y_min() const {
  return _impl_.y_min_;
}
inline int64_t Detection::y_min() const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.Detection.y_min)
  return _internal_y_min();
}
inline void Detection::_internal_set_y_min(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.y_min_ = value;
}
inline void Detection::set_y_min(int64_t value) {
  _internal_set_y_min(value);
  // @@protoc_insertion_point(field_set:viam.service.vision.v1.Detection.y_min)
}

// optional int64 x_max = 3 [json_name = "xMax"];
inline bool Detection::_internal_has_x_max() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Detection::has_x_max() const {
  return _internal_has_x_max();
}
inline void Detection::clear_x_max() {
  _impl_.x_max_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t Detection::_internal_x_max() const {
  return _impl_.x_max_;
}
inline int64_t Detection::x_max() const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.Detection.x_max)
  return _internal_x_max();
}
inline void Detection::_internal_set_x_max(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.x_max_ = value;
}
inline void Detection::set_x_max(int64_t value) {
  _internal_set_x_max(value);
  // @@protoc_insertion_point(field_set:viam.service.vision.v1.Detection.x_max)
}

// optional int64 y_max = 4 [json_name = "yMax"];
inline bool Detection::_internal_has_y_max() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Detection::has_y_max() const {
  return _internal_has_y_max();
}
inline void Detection::clear_y_max() {
  _impl_.y_max_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int64_t Detection::_internal_y_max() const {
  return _impl_.y_max_;
}
inline int64_t Detection::y_max() const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.Detection.y_max)
  return _internal_y_max();
}
inline void Detection::_internal_set_y_max(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.y_max_ = value;
}
inline void Detection::set_y_max(int64_t value) {
  _internal_set_y_max(value);
  // @@protoc_insertion_point(field_set:viam.service.vision.v1.Detection.y_max)
}

// double confidence = 5 [json_name = "confidence"];
inline void Detection::clear_confidence() {
  _impl_.confidence_ = 0;
}
inline double Detection::_internal_confidence() const {
  return _impl_.confidence_;
}
inline double Detection::confidence() const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.Detection.confidence)
  return _internal_confidence();
}
inline void Detection::_internal_set_confidence(double value) {
  
  _impl_.confidence_ = value;
}
inline void Detection::set_confidence(double value) {
  _internal_set_confidence(value);
  // @@protoc_insertion_point(field_set:viam.service.vision.v1.Detection.confidence)
}

// string class_name = 6 [json_name = "className"];
inline void Detection::clear_class_name() {
  _impl_.class_name_.ClearToEmpty();
}
inline const std::string& Detection::class_name() const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.Detection.class_name)
  return _internal_class_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Detection::set_class_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.class_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.service.vision.v1.Detection.class_name)
}
inline std::string* Detection::mutable_class_name() {
  std::string* _s = _internal_mutable_class_name();
  // @@protoc_insertion_point(field_mutable:viam.service.vision.v1.Detection.class_name)
  return _s;
}
inline const std::string& Detection::_internal_class_name() const {
  return _impl_.class_name_.Get();
}
inline void Detection::_internal_set_class_name(const std::string& value) {
  
  _impl_.class_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Detection::_internal_mutable_class_name() {
  
  return _impl_.class_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Detection::release_class_name() {
  // @@protoc_insertion_point(field_release:viam.service.vision.v1.Detection.class_name)
  return _impl_.class_name_.Release();
}
inline void Detection::set_allocated_class_name(std::string* class_name) {
  if (class_name != nullptr) {
    
  } else {
    
  }
  _impl_.class_name_.SetAllocated(class_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.class_name_.IsDefault()) {
    _impl_.class_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.vision.v1.Detection.class_name)
}

// -------------------------------------------------------------------

// GetClassifierNamesRequest

// string name = 1 [json_name = "name"];
inline void GetClassifierNamesRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& GetClassifierNamesRequest::name() const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.GetClassifierNamesRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetClassifierNamesRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.service.vision.v1.GetClassifierNamesRequest.name)
}
inline std::string* GetClassifierNamesRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.service.vision.v1.GetClassifierNamesRequest.name)
  return _s;
}
inline const std::string& GetClassifierNamesRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void GetClassifierNamesRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* GetClassifierNamesRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* GetClassifierNamesRequest::release_name() {
  // @@protoc_insertion_point(field_release:viam.service.vision.v1.GetClassifierNamesRequest.name)
  return _impl_.name_.Release();
}
inline void GetClassifierNamesRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.vision.v1.GetClassifierNamesRequest.name)
}

// .google.protobuf.Struct extra = 99 [json_name = "extra"];
inline bool GetClassifierNamesRequest::_internal_has_extra() const {
  return this != internal_default_instance() && _impl_.extra_ != nullptr;
}
inline bool GetClassifierNamesRequest::has_extra() const {
  return _internal_has_extra();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& GetClassifierNamesRequest::_internal_extra() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.extra_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& GetClassifierNamesRequest::extra() const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.GetClassifierNamesRequest.extra)
  return _internal_extra();
}
inline void GetClassifierNamesRequest::unsafe_arena_set_allocated_extra(
    ::PROTOBUF_NAMESPACE_ID::Struct* extra) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.extra_);
  }
  _impl_.extra_ = extra;
  if (extra) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.vision.v1.GetClassifierNamesRequest.extra)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* GetClassifierNamesRequest::release_extra() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.extra_;
  _impl_.extra_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* GetClassifierNamesRequest::unsafe_arena_release_extra() {
  // @@protoc_insertion_point(field_release:viam.service.vision.v1.GetClassifierNamesRequest.extra)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.extra_;
  _impl_.extra_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* GetClassifierNamesRequest::_internal_mutable_extra() {
  
  if (_impl_.extra_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.extra_ = p;
  }
  return _impl_.extra_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* GetClassifierNamesRequest::mutable_extra() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_extra();
  // @@protoc_insertion_point(field_mutable:viam.service.vision.v1.GetClassifierNamesRequest.extra)
  return _msg;
}
inline void GetClassifierNamesRequest::set_allocated_extra(::PROTOBUF_NAMESPACE_ID::Struct* extra) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.extra_);
  }
  if (extra) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(extra));
    if (message_arena != submessage_arena) {
      extra = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, extra, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.extra_ = extra;
  // @@protoc_insertion_point(field_set_allocated:viam.service.vision.v1.GetClassifierNamesRequest.extra)
}

// -------------------------------------------------------------------

// GetClassifierNamesResponse

// repeated string classifier_names = 1 [json_name = "classifierNames"];
inline int GetClassifierNamesResponse::_internal_classifier_names_size() const {
  return _impl_.classifier_names_.size();
}
inline int GetClassifierNamesResponse::classifier_names_size() const {
  return _internal_classifier_names_size();
}
inline void GetClassifierNamesResponse::clear_classifier_names() {
  _impl_.classifier_names_.Clear();
}
inline std::string* GetClassifierNamesResponse::add_classifier_names() {
  std::string* _s = _internal_add_classifier_names();
  // @@protoc_insertion_point(field_add_mutable:viam.service.vision.v1.GetClassifierNamesResponse.classifier_names)
  return _s;
}
inline const std::string& GetClassifierNamesResponse::_internal_classifier_names(int index) const {
  return _impl_.classifier_names_.Get(index);
}
inline const std::string& GetClassifierNamesResponse::classifier_names(int index) const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.GetClassifierNamesResponse.classifier_names)
  return _internal_classifier_names(index);
}
inline std::string* GetClassifierNamesResponse::mutable_classifier_names(int index) {
  // @@protoc_insertion_point(field_mutable:viam.service.vision.v1.GetClassifierNamesResponse.classifier_names)
  return _impl_.classifier_names_.Mutable(index);
}
inline void GetClassifierNamesResponse::set_classifier_names(int index, const std::string& value) {
  _impl_.classifier_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:viam.service.vision.v1.GetClassifierNamesResponse.classifier_names)
}
inline void GetClassifierNamesResponse::set_classifier_names(int index, std::string&& value) {
  _impl_.classifier_names_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:viam.service.vision.v1.GetClassifierNamesResponse.classifier_names)
}
inline void GetClassifierNamesResponse::set_classifier_names(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.classifier_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:viam.service.vision.v1.GetClassifierNamesResponse.classifier_names)
}
inline void GetClassifierNamesResponse::set_classifier_names(int index, const char* value, size_t size) {
  _impl_.classifier_names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:viam.service.vision.v1.GetClassifierNamesResponse.classifier_names)
}
inline std::string* GetClassifierNamesResponse::_internal_add_classifier_names() {
  return _impl_.classifier_names_.Add();
}
inline void GetClassifierNamesResponse::add_classifier_names(const std::string& value) {
  _impl_.classifier_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:viam.service.vision.v1.GetClassifierNamesResponse.classifier_names)
}
inline void GetClassifierNamesResponse::add_classifier_names(std::string&& value) {
  _impl_.classifier_names_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:viam.service.vision.v1.GetClassifierNamesResponse.classifier_names)
}
inline void GetClassifierNamesResponse::add_classifier_names(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.classifier_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:viam.service.vision.v1.GetClassifierNamesResponse.classifier_names)
}
inline void GetClassifierNamesResponse::add_classifier_names(const char* value, size_t size) {
  _impl_.classifier_names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:viam.service.vision.v1.GetClassifierNamesResponse.classifier_names)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetClassifierNamesResponse::classifier_names() const {
  // @@protoc_insertion_point(field_list:viam.service.vision.v1.GetClassifierNamesResponse.classifier_names)
  return _impl_.classifier_names_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetClassifierNamesResponse::mutable_classifier_names() {
  // @@protoc_insertion_point(field_mutable_list:viam.service.vision.v1.GetClassifierNamesResponse.classifier_names)
  return &_impl_.classifier_names_;
}

// -------------------------------------------------------------------

// AddClassifierRequest

// string name = 1 [json_name = "name"];
inline void AddClassifierRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& AddClassifierRequest::name() const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.AddClassifierRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddClassifierRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.service.vision.v1.AddClassifierRequest.name)
}
inline std::string* AddClassifierRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.service.vision.v1.AddClassifierRequest.name)
  return _s;
}
inline const std::string& AddClassifierRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void AddClassifierRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* AddClassifierRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* AddClassifierRequest::release_name() {
  // @@protoc_insertion_point(field_release:viam.service.vision.v1.AddClassifierRequest.name)
  return _impl_.name_.Release();
}
inline void AddClassifierRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.vision.v1.AddClassifierRequest.name)
}

// string classifier_name = 2 [json_name = "classifierName"];
inline void AddClassifierRequest::clear_classifier_name() {
  _impl_.classifier_name_.ClearToEmpty();
}
inline const std::string& AddClassifierRequest::classifier_name() const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.AddClassifierRequest.classifier_name)
  return _internal_classifier_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddClassifierRequest::set_classifier_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.classifier_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.service.vision.v1.AddClassifierRequest.classifier_name)
}
inline std::string* AddClassifierRequest::mutable_classifier_name() {
  std::string* _s = _internal_mutable_classifier_name();
  // @@protoc_insertion_point(field_mutable:viam.service.vision.v1.AddClassifierRequest.classifier_name)
  return _s;
}
inline const std::string& AddClassifierRequest::_internal_classifier_name() const {
  return _impl_.classifier_name_.Get();
}
inline void AddClassifierRequest::_internal_set_classifier_name(const std::string& value) {
  
  _impl_.classifier_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AddClassifierRequest::_internal_mutable_classifier_name() {
  
  return _impl_.classifier_name_.Mutable(GetArenaForAllocation());
}
inline std::string* AddClassifierRequest::release_classifier_name() {
  // @@protoc_insertion_point(field_release:viam.service.vision.v1.AddClassifierRequest.classifier_name)
  return _impl_.classifier_name_.Release();
}
inline void AddClassifierRequest::set_allocated_classifier_name(std::string* classifier_name) {
  if (classifier_name != nullptr) {
    
  } else {
    
  }
  _impl_.classifier_name_.SetAllocated(classifier_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.classifier_name_.IsDefault()) {
    _impl_.classifier_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.vision.v1.AddClassifierRequest.classifier_name)
}

// string classifier_model_type = 3 [json_name = "classifierModelType"];
inline void AddClassifierRequest::clear_classifier_model_type() {
  _impl_.classifier_model_type_.ClearToEmpty();
}
inline const std::string& AddClassifierRequest::classifier_model_type() const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.AddClassifierRequest.classifier_model_type)
  return _internal_classifier_model_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddClassifierRequest::set_classifier_model_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.classifier_model_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.service.vision.v1.AddClassifierRequest.classifier_model_type)
}
inline std::string* AddClassifierRequest::mutable_classifier_model_type() {
  std::string* _s = _internal_mutable_classifier_model_type();
  // @@protoc_insertion_point(field_mutable:viam.service.vision.v1.AddClassifierRequest.classifier_model_type)
  return _s;
}
inline const std::string& AddClassifierRequest::_internal_classifier_model_type() const {
  return _impl_.classifier_model_type_.Get();
}
inline void AddClassifierRequest::_internal_set_classifier_model_type(const std::string& value) {
  
  _impl_.classifier_model_type_.Set(value, GetArenaForAllocation());
}
inline std::string* AddClassifierRequest::_internal_mutable_classifier_model_type() {
  
  return _impl_.classifier_model_type_.Mutable(GetArenaForAllocation());
}
inline std::string* AddClassifierRequest::release_classifier_model_type() {
  // @@protoc_insertion_point(field_release:viam.service.vision.v1.AddClassifierRequest.classifier_model_type)
  return _impl_.classifier_model_type_.Release();
}
inline void AddClassifierRequest::set_allocated_classifier_model_type(std::string* classifier_model_type) {
  if (classifier_model_type != nullptr) {
    
  } else {
    
  }
  _impl_.classifier_model_type_.SetAllocated(classifier_model_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.classifier_model_type_.IsDefault()) {
    _impl_.classifier_model_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.vision.v1.AddClassifierRequest.classifier_model_type)
}

// .google.protobuf.Struct classifier_parameters = 4 [json_name = "classifierParameters"];
inline bool AddClassifierRequest::_internal_has_classifier_parameters() const {
  return this != internal_default_instance() && _impl_.classifier_parameters_ != nullptr;
}
inline bool AddClassifierRequest::has_classifier_parameters() const {
  return _internal_has_classifier_parameters();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& AddClassifierRequest::_internal_classifier_parameters() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.classifier_parameters_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& AddClassifierRequest::classifier_parameters() const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.AddClassifierRequest.classifier_parameters)
  return _internal_classifier_parameters();
}
inline void AddClassifierRequest::unsafe_arena_set_allocated_classifier_parameters(
    ::PROTOBUF_NAMESPACE_ID::Struct* classifier_parameters) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.classifier_parameters_);
  }
  _impl_.classifier_parameters_ = classifier_parameters;
  if (classifier_parameters) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.vision.v1.AddClassifierRequest.classifier_parameters)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AddClassifierRequest::release_classifier_parameters() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.classifier_parameters_;
  _impl_.classifier_parameters_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AddClassifierRequest::unsafe_arena_release_classifier_parameters() {
  // @@protoc_insertion_point(field_release:viam.service.vision.v1.AddClassifierRequest.classifier_parameters)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.classifier_parameters_;
  _impl_.classifier_parameters_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AddClassifierRequest::_internal_mutable_classifier_parameters() {
  
  if (_impl_.classifier_parameters_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.classifier_parameters_ = p;
  }
  return _impl_.classifier_parameters_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AddClassifierRequest::mutable_classifier_parameters() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_classifier_parameters();
  // @@protoc_insertion_point(field_mutable:viam.service.vision.v1.AddClassifierRequest.classifier_parameters)
  return _msg;
}
inline void AddClassifierRequest::set_allocated_classifier_parameters(::PROTOBUF_NAMESPACE_ID::Struct* classifier_parameters) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.classifier_parameters_);
  }
  if (classifier_parameters) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(classifier_parameters));
    if (message_arena != submessage_arena) {
      classifier_parameters = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, classifier_parameters, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.classifier_parameters_ = classifier_parameters;
  // @@protoc_insertion_point(field_set_allocated:viam.service.vision.v1.AddClassifierRequest.classifier_parameters)
}

// .google.protobuf.Struct extra = 99 [json_name = "extra"];
inline bool AddClassifierRequest::_internal_has_extra() const {
  return this != internal_default_instance() && _impl_.extra_ != nullptr;
}
inline bool AddClassifierRequest::has_extra() const {
  return _internal_has_extra();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& AddClassifierRequest::_internal_extra() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.extra_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& AddClassifierRequest::extra() const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.AddClassifierRequest.extra)
  return _internal_extra();
}
inline void AddClassifierRequest::unsafe_arena_set_allocated_extra(
    ::PROTOBUF_NAMESPACE_ID::Struct* extra) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.extra_);
  }
  _impl_.extra_ = extra;
  if (extra) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.vision.v1.AddClassifierRequest.extra)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AddClassifierRequest::release_extra() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.extra_;
  _impl_.extra_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AddClassifierRequest::unsafe_arena_release_extra() {
  // @@protoc_insertion_point(field_release:viam.service.vision.v1.AddClassifierRequest.extra)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.extra_;
  _impl_.extra_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AddClassifierRequest::_internal_mutable_extra() {
  
  if (_impl_.extra_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.extra_ = p;
  }
  return _impl_.extra_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AddClassifierRequest::mutable_extra() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_extra();
  // @@protoc_insertion_point(field_mutable:viam.service.vision.v1.AddClassifierRequest.extra)
  return _msg;
}
inline void AddClassifierRequest::set_allocated_extra(::PROTOBUF_NAMESPACE_ID::Struct* extra) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.extra_);
  }
  if (extra) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(extra));
    if (message_arena != submessage_arena) {
      extra = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, extra, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.extra_ = extra;
  // @@protoc_insertion_point(field_set_allocated:viam.service.vision.v1.AddClassifierRequest.extra)
}

// -------------------------------------------------------------------

// AddClassifierResponse

// -------------------------------------------------------------------

// RemoveClassifierRequest

// string name = 1 [json_name = "name"];
inline void RemoveClassifierRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& RemoveClassifierRequest::name() const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.RemoveClassifierRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RemoveClassifierRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.service.vision.v1.RemoveClassifierRequest.name)
}
inline std::string* RemoveClassifierRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.service.vision.v1.RemoveClassifierRequest.name)
  return _s;
}
inline const std::string& RemoveClassifierRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void RemoveClassifierRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* RemoveClassifierRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* RemoveClassifierRequest::release_name() {
  // @@protoc_insertion_point(field_release:viam.service.vision.v1.RemoveClassifierRequest.name)
  return _impl_.name_.Release();
}
inline void RemoveClassifierRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.vision.v1.RemoveClassifierRequest.name)
}

// string classifier_name = 2 [json_name = "classifierName"];
inline void RemoveClassifierRequest::clear_classifier_name() {
  _impl_.classifier_name_.ClearToEmpty();
}
inline const std::string& RemoveClassifierRequest::classifier_name() const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.RemoveClassifierRequest.classifier_name)
  return _internal_classifier_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RemoveClassifierRequest::set_classifier_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.classifier_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.service.vision.v1.RemoveClassifierRequest.classifier_name)
}
inline std::string* RemoveClassifierRequest::mutable_classifier_name() {
  std::string* _s = _internal_mutable_classifier_name();
  // @@protoc_insertion_point(field_mutable:viam.service.vision.v1.RemoveClassifierRequest.classifier_name)
  return _s;
}
inline const std::string& RemoveClassifierRequest::_internal_classifier_name() const {
  return _impl_.classifier_name_.Get();
}
inline void RemoveClassifierRequest::_internal_set_classifier_name(const std::string& value) {
  
  _impl_.classifier_name_.Set(value, GetArenaForAllocation());
}
inline std::string* RemoveClassifierRequest::_internal_mutable_classifier_name() {
  
  return _impl_.classifier_name_.Mutable(GetArenaForAllocation());
}
inline std::string* RemoveClassifierRequest::release_classifier_name() {
  // @@protoc_insertion_point(field_release:viam.service.vision.v1.RemoveClassifierRequest.classifier_name)
  return _impl_.classifier_name_.Release();
}
inline void RemoveClassifierRequest::set_allocated_classifier_name(std::string* classifier_name) {
  if (classifier_name != nullptr) {
    
  } else {
    
  }
  _impl_.classifier_name_.SetAllocated(classifier_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.classifier_name_.IsDefault()) {
    _impl_.classifier_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.vision.v1.RemoveClassifierRequest.classifier_name)
}

// .google.protobuf.Struct extra = 99 [json_name = "extra"];
inline bool RemoveClassifierRequest::_internal_has_extra() const {
  return this != internal_default_instance() && _impl_.extra_ != nullptr;
}
inline bool RemoveClassifierRequest::has_extra() const {
  return _internal_has_extra();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& RemoveClassifierRequest::_internal_extra() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.extra_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& RemoveClassifierRequest::extra() const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.RemoveClassifierRequest.extra)
  return _internal_extra();
}
inline void RemoveClassifierRequest::unsafe_arena_set_allocated_extra(
    ::PROTOBUF_NAMESPACE_ID::Struct* extra) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.extra_);
  }
  _impl_.extra_ = extra;
  if (extra) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.vision.v1.RemoveClassifierRequest.extra)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* RemoveClassifierRequest::release_extra() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.extra_;
  _impl_.extra_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* RemoveClassifierRequest::unsafe_arena_release_extra() {
  // @@protoc_insertion_point(field_release:viam.service.vision.v1.RemoveClassifierRequest.extra)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.extra_;
  _impl_.extra_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* RemoveClassifierRequest::_internal_mutable_extra() {
  
  if (_impl_.extra_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.extra_ = p;
  }
  return _impl_.extra_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* RemoveClassifierRequest::mutable_extra() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_extra();
  // @@protoc_insertion_point(field_mutable:viam.service.vision.v1.RemoveClassifierRequest.extra)
  return _msg;
}
inline void RemoveClassifierRequest::set_allocated_extra(::PROTOBUF_NAMESPACE_ID::Struct* extra) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.extra_);
  }
  if (extra) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(extra));
    if (message_arena != submessage_arena) {
      extra = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, extra, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.extra_ = extra;
  // @@protoc_insertion_point(field_set_allocated:viam.service.vision.v1.RemoveClassifierRequest.extra)
}

// -------------------------------------------------------------------

// RemoveClassifierResponse

// -------------------------------------------------------------------

// GetClassificationsRequest

// string name = 1 [json_name = "name"];
inline void GetClassificationsRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& GetClassificationsRequest::name() const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.GetClassificationsRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetClassificationsRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.service.vision.v1.GetClassificationsRequest.name)
}
inline std::string* GetClassificationsRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.service.vision.v1.GetClassificationsRequest.name)
  return _s;
}
inline const std::string& GetClassificationsRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void GetClassificationsRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* GetClassificationsRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* GetClassificationsRequest::release_name() {
  // @@protoc_insertion_point(field_release:viam.service.vision.v1.GetClassificationsRequest.name)
  return _impl_.name_.Release();
}
inline void GetClassificationsRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.vision.v1.GetClassificationsRequest.name)
}

// bytes image = 2 [json_name = "image"];
inline void GetClassificationsRequest::clear_image() {
  _impl_.image_.ClearToEmpty();
}
inline const std::string& GetClassificationsRequest::image() const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.GetClassificationsRequest.image)
  return _internal_image();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetClassificationsRequest::set_image(ArgT0&& arg0, ArgT... args) {
 
 _impl_.image_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.service.vision.v1.GetClassificationsRequest.image)
}
inline std::string* GetClassificationsRequest::mutable_image() {
  std::string* _s = _internal_mutable_image();
  // @@protoc_insertion_point(field_mutable:viam.service.vision.v1.GetClassificationsRequest.image)
  return _s;
}
inline const std::string& GetClassificationsRequest::_internal_image() const {
  return _impl_.image_.Get();
}
inline void GetClassificationsRequest::_internal_set_image(const std::string& value) {
  
  _impl_.image_.Set(value, GetArenaForAllocation());
}
inline std::string* GetClassificationsRequest::_internal_mutable_image() {
  
  return _impl_.image_.Mutable(GetArenaForAllocation());
}
inline std::string* GetClassificationsRequest::release_image() {
  // @@protoc_insertion_point(field_release:viam.service.vision.v1.GetClassificationsRequest.image)
  return _impl_.image_.Release();
}
inline void GetClassificationsRequest::set_allocated_image(std::string* image) {
  if (image != nullptr) {
    
  } else {
    
  }
  _impl_.image_.SetAllocated(image, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.image_.IsDefault()) {
    _impl_.image_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.vision.v1.GetClassificationsRequest.image)
}

// int32 width = 3 [json_name = "width"];
inline void GetClassificationsRequest::clear_width() {
  _impl_.width_ = 0;
}
inline int32_t GetClassificationsRequest::_internal_width() const {
  return _impl_.width_;
}
inline int32_t GetClassificationsRequest::width() const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.GetClassificationsRequest.width)
  return _internal_width();
}
inline void GetClassificationsRequest::_internal_set_width(int32_t value) {
  
  _impl_.width_ = value;
}
inline void GetClassificationsRequest::set_width(int32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:viam.service.vision.v1.GetClassificationsRequest.width)
}

// int32 height = 4 [json_name = "height"];
inline void GetClassificationsRequest::clear_height() {
  _impl_.height_ = 0;
}
inline int32_t GetClassificationsRequest::_internal_height() const {
  return _impl_.height_;
}
inline int32_t GetClassificationsRequest::height() const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.GetClassificationsRequest.height)
  return _internal_height();
}
inline void GetClassificationsRequest::_internal_set_height(int32_t value) {
  
  _impl_.height_ = value;
}
inline void GetClassificationsRequest::set_height(int32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:viam.service.vision.v1.GetClassificationsRequest.height)
}

// string mime_type = 5 [json_name = "mimeType"];
inline void GetClassificationsRequest::clear_mime_type() {
  _impl_.mime_type_.ClearToEmpty();
}
inline const std::string& GetClassificationsRequest::mime_type() const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.GetClassificationsRequest.mime_type)
  return _internal_mime_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetClassificationsRequest::set_mime_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mime_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.service.vision.v1.GetClassificationsRequest.mime_type)
}
inline std::string* GetClassificationsRequest::mutable_mime_type() {
  std::string* _s = _internal_mutable_mime_type();
  // @@protoc_insertion_point(field_mutable:viam.service.vision.v1.GetClassificationsRequest.mime_type)
  return _s;
}
inline const std::string& GetClassificationsRequest::_internal_mime_type() const {
  return _impl_.mime_type_.Get();
}
inline void GetClassificationsRequest::_internal_set_mime_type(const std::string& value) {
  
  _impl_.mime_type_.Set(value, GetArenaForAllocation());
}
inline std::string* GetClassificationsRequest::_internal_mutable_mime_type() {
  
  return _impl_.mime_type_.Mutable(GetArenaForAllocation());
}
inline std::string* GetClassificationsRequest::release_mime_type() {
  // @@protoc_insertion_point(field_release:viam.service.vision.v1.GetClassificationsRequest.mime_type)
  return _impl_.mime_type_.Release();
}
inline void GetClassificationsRequest::set_allocated_mime_type(std::string* mime_type) {
  if (mime_type != nullptr) {
    
  } else {
    
  }
  _impl_.mime_type_.SetAllocated(mime_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mime_type_.IsDefault()) {
    _impl_.mime_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.vision.v1.GetClassificationsRequest.mime_type)
}

// string classifier_name = 6 [json_name = "classifierName"];
inline void GetClassificationsRequest::clear_classifier_name() {
  _impl_.classifier_name_.ClearToEmpty();
}
inline const std::string& GetClassificationsRequest::classifier_name() const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.GetClassificationsRequest.classifier_name)
  return _internal_classifier_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetClassificationsRequest::set_classifier_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.classifier_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.service.vision.v1.GetClassificationsRequest.classifier_name)
}
inline std::string* GetClassificationsRequest::mutable_classifier_name() {
  std::string* _s = _internal_mutable_classifier_name();
  // @@protoc_insertion_point(field_mutable:viam.service.vision.v1.GetClassificationsRequest.classifier_name)
  return _s;
}
inline const std::string& GetClassificationsRequest::_internal_classifier_name() const {
  return _impl_.classifier_name_.Get();
}
inline void GetClassificationsRequest::_internal_set_classifier_name(const std::string& value) {
  
  _impl_.classifier_name_.Set(value, GetArenaForAllocation());
}
inline std::string* GetClassificationsRequest::_internal_mutable_classifier_name() {
  
  return _impl_.classifier_name_.Mutable(GetArenaForAllocation());
}
inline std::string* GetClassificationsRequest::release_classifier_name() {
  // @@protoc_insertion_point(field_release:viam.service.vision.v1.GetClassificationsRequest.classifier_name)
  return _impl_.classifier_name_.Release();
}
inline void GetClassificationsRequest::set_allocated_classifier_name(std::string* classifier_name) {
  if (classifier_name != nullptr) {
    
  } else {
    
  }
  _impl_.classifier_name_.SetAllocated(classifier_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.classifier_name_.IsDefault()) {
    _impl_.classifier_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.vision.v1.GetClassificationsRequest.classifier_name)
}

// int32 n = 7 [json_name = "n"];
inline void GetClassificationsRequest::clear_n() {
  _impl_.n_ = 0;
}
inline int32_t GetClassificationsRequest::_internal_n() const {
  return _impl_.n_;
}
inline int32_t GetClassificationsRequest::n() const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.GetClassificationsRequest.n)
  return _internal_n();
}
inline void GetClassificationsRequest::_internal_set_n(int32_t value) {
  
  _impl_.n_ = value;
}
inline void GetClassificationsRequest::set_n(int32_t value) {
  _internal_set_n(value);
  // @@protoc_insertion_point(field_set:viam.service.vision.v1.GetClassificationsRequest.n)
}

// .google.protobuf.Struct extra = 99 [json_name = "extra"];
inline bool GetClassificationsRequest::_internal_has_extra() const {
  return this != internal_default_instance() && _impl_.extra_ != nullptr;
}
inline bool GetClassificationsRequest::has_extra() const {
  return _internal_has_extra();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& GetClassificationsRequest::_internal_extra() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.extra_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& GetClassificationsRequest::extra() const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.GetClassificationsRequest.extra)
  return _internal_extra();
}
inline void GetClassificationsRequest::unsafe_arena_set_allocated_extra(
    ::PROTOBUF_NAMESPACE_ID::Struct* extra) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.extra_);
  }
  _impl_.extra_ = extra;
  if (extra) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.vision.v1.GetClassificationsRequest.extra)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* GetClassificationsRequest::release_extra() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.extra_;
  _impl_.extra_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* GetClassificationsRequest::unsafe_arena_release_extra() {
  // @@protoc_insertion_point(field_release:viam.service.vision.v1.GetClassificationsRequest.extra)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.extra_;
  _impl_.extra_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* GetClassificationsRequest::_internal_mutable_extra() {
  
  if (_impl_.extra_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.extra_ = p;
  }
  return _impl_.extra_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* GetClassificationsRequest::mutable_extra() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_extra();
  // @@protoc_insertion_point(field_mutable:viam.service.vision.v1.GetClassificationsRequest.extra)
  return _msg;
}
inline void GetClassificationsRequest::set_allocated_extra(::PROTOBUF_NAMESPACE_ID::Struct* extra) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.extra_);
  }
  if (extra) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(extra));
    if (message_arena != submessage_arena) {
      extra = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, extra, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.extra_ = extra;
  // @@protoc_insertion_point(field_set_allocated:viam.service.vision.v1.GetClassificationsRequest.extra)
}

// -------------------------------------------------------------------

// GetClassificationsResponse

// repeated .viam.service.vision.v1.Classification classifications = 1 [json_name = "classifications"];
inline int GetClassificationsResponse::_internal_classifications_size() const {
  return _impl_.classifications_.size();
}
inline int GetClassificationsResponse::classifications_size() const {
  return _internal_classifications_size();
}
inline void GetClassificationsResponse::clear_classifications() {
  _impl_.classifications_.Clear();
}
inline ::viam::service::vision::v1::Classification* GetClassificationsResponse::mutable_classifications(int index) {
  // @@protoc_insertion_point(field_mutable:viam.service.vision.v1.GetClassificationsResponse.classifications)
  return _impl_.classifications_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::service::vision::v1::Classification >*
GetClassificationsResponse::mutable_classifications() {
  // @@protoc_insertion_point(field_mutable_list:viam.service.vision.v1.GetClassificationsResponse.classifications)
  return &_impl_.classifications_;
}
inline const ::viam::service::vision::v1::Classification& GetClassificationsResponse::_internal_classifications(int index) const {
  return _impl_.classifications_.Get(index);
}
inline const ::viam::service::vision::v1::Classification& GetClassificationsResponse::classifications(int index) const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.GetClassificationsResponse.classifications)
  return _internal_classifications(index);
}
inline ::viam::service::vision::v1::Classification* GetClassificationsResponse::_internal_add_classifications() {
  return _impl_.classifications_.Add();
}
inline ::viam::service::vision::v1::Classification* GetClassificationsResponse::add_classifications() {
  ::viam::service::vision::v1::Classification* _add = _internal_add_classifications();
  // @@protoc_insertion_point(field_add:viam.service.vision.v1.GetClassificationsResponse.classifications)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::service::vision::v1::Classification >&
GetClassificationsResponse::classifications() const {
  // @@protoc_insertion_point(field_list:viam.service.vision.v1.GetClassificationsResponse.classifications)
  return _impl_.classifications_;
}

// -------------------------------------------------------------------

// GetClassificationsFromCameraRequest

// string name = 1 [json_name = "name"];
inline void GetClassificationsFromCameraRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& GetClassificationsFromCameraRequest::name() const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.GetClassificationsFromCameraRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetClassificationsFromCameraRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.service.vision.v1.GetClassificationsFromCameraRequest.name)
}
inline std::string* GetClassificationsFromCameraRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.service.vision.v1.GetClassificationsFromCameraRequest.name)
  return _s;
}
inline const std::string& GetClassificationsFromCameraRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void GetClassificationsFromCameraRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* GetClassificationsFromCameraRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* GetClassificationsFromCameraRequest::release_name() {
  // @@protoc_insertion_point(field_release:viam.service.vision.v1.GetClassificationsFromCameraRequest.name)
  return _impl_.name_.Release();
}
inline void GetClassificationsFromCameraRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.vision.v1.GetClassificationsFromCameraRequest.name)
}

// string camera_name = 2 [json_name = "cameraName"];
inline void GetClassificationsFromCameraRequest::clear_camera_name() {
  _impl_.camera_name_.ClearToEmpty();
}
inline const std::string& GetClassificationsFromCameraRequest::camera_name() const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.GetClassificationsFromCameraRequest.camera_name)
  return _internal_camera_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetClassificationsFromCameraRequest::set_camera_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.camera_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.service.vision.v1.GetClassificationsFromCameraRequest.camera_name)
}
inline std::string* GetClassificationsFromCameraRequest::mutable_camera_name() {
  std::string* _s = _internal_mutable_camera_name();
  // @@protoc_insertion_point(field_mutable:viam.service.vision.v1.GetClassificationsFromCameraRequest.camera_name)
  return _s;
}
inline const std::string& GetClassificationsFromCameraRequest::_internal_camera_name() const {
  return _impl_.camera_name_.Get();
}
inline void GetClassificationsFromCameraRequest::_internal_set_camera_name(const std::string& value) {
  
  _impl_.camera_name_.Set(value, GetArenaForAllocation());
}
inline std::string* GetClassificationsFromCameraRequest::_internal_mutable_camera_name() {
  
  return _impl_.camera_name_.Mutable(GetArenaForAllocation());
}
inline std::string* GetClassificationsFromCameraRequest::release_camera_name() {
  // @@protoc_insertion_point(field_release:viam.service.vision.v1.GetClassificationsFromCameraRequest.camera_name)
  return _impl_.camera_name_.Release();
}
inline void GetClassificationsFromCameraRequest::set_allocated_camera_name(std::string* camera_name) {
  if (camera_name != nullptr) {
    
  } else {
    
  }
  _impl_.camera_name_.SetAllocated(camera_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.camera_name_.IsDefault()) {
    _impl_.camera_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.vision.v1.GetClassificationsFromCameraRequest.camera_name)
}

// string classifier_name = 3 [json_name = "classifierName"];
inline void GetClassificationsFromCameraRequest::clear_classifier_name() {
  _impl_.classifier_name_.ClearToEmpty();
}
inline const std::string& GetClassificationsFromCameraRequest::classifier_name() const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.GetClassificationsFromCameraRequest.classifier_name)
  return _internal_classifier_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetClassificationsFromCameraRequest::set_classifier_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.classifier_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.service.vision.v1.GetClassificationsFromCameraRequest.classifier_name)
}
inline std::string* GetClassificationsFromCameraRequest::mutable_classifier_name() {
  std::string* _s = _internal_mutable_classifier_name();
  // @@protoc_insertion_point(field_mutable:viam.service.vision.v1.GetClassificationsFromCameraRequest.classifier_name)
  return _s;
}
inline const std::string& GetClassificationsFromCameraRequest::_internal_classifier_name() const {
  return _impl_.classifier_name_.Get();
}
inline void GetClassificationsFromCameraRequest::_internal_set_classifier_name(const std::string& value) {
  
  _impl_.classifier_name_.Set(value, GetArenaForAllocation());
}
inline std::string* GetClassificationsFromCameraRequest::_internal_mutable_classifier_name() {
  
  return _impl_.classifier_name_.Mutable(GetArenaForAllocation());
}
inline std::string* GetClassificationsFromCameraRequest::release_classifier_name() {
  // @@protoc_insertion_point(field_release:viam.service.vision.v1.GetClassificationsFromCameraRequest.classifier_name)
  return _impl_.classifier_name_.Release();
}
inline void GetClassificationsFromCameraRequest::set_allocated_classifier_name(std::string* classifier_name) {
  if (classifier_name != nullptr) {
    
  } else {
    
  }
  _impl_.classifier_name_.SetAllocated(classifier_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.classifier_name_.IsDefault()) {
    _impl_.classifier_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.vision.v1.GetClassificationsFromCameraRequest.classifier_name)
}

// int32 n = 4 [json_name = "n"];
inline void GetClassificationsFromCameraRequest::clear_n() {
  _impl_.n_ = 0;
}
inline int32_t GetClassificationsFromCameraRequest::_internal_n() const {
  return _impl_.n_;
}
inline int32_t GetClassificationsFromCameraRequest::n() const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.GetClassificationsFromCameraRequest.n)
  return _internal_n();
}
inline void GetClassificationsFromCameraRequest::_internal_set_n(int32_t value) {
  
  _impl_.n_ = value;
}
inline void GetClassificationsFromCameraRequest::set_n(int32_t value) {
  _internal_set_n(value);
  // @@protoc_insertion_point(field_set:viam.service.vision.v1.GetClassificationsFromCameraRequest.n)
}

// .google.protobuf.Struct extra = 99 [json_name = "extra"];
inline bool GetClassificationsFromCameraRequest::_internal_has_extra() const {
  return this != internal_default_instance() && _impl_.extra_ != nullptr;
}
inline bool GetClassificationsFromCameraRequest::has_extra() const {
  return _internal_has_extra();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& GetClassificationsFromCameraRequest::_internal_extra() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.extra_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& GetClassificationsFromCameraRequest::extra() const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.GetClassificationsFromCameraRequest.extra)
  return _internal_extra();
}
inline void GetClassificationsFromCameraRequest::unsafe_arena_set_allocated_extra(
    ::PROTOBUF_NAMESPACE_ID::Struct* extra) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.extra_);
  }
  _impl_.extra_ = extra;
  if (extra) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.vision.v1.GetClassificationsFromCameraRequest.extra)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* GetClassificationsFromCameraRequest::release_extra() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.extra_;
  _impl_.extra_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* GetClassificationsFromCameraRequest::unsafe_arena_release_extra() {
  // @@protoc_insertion_point(field_release:viam.service.vision.v1.GetClassificationsFromCameraRequest.extra)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.extra_;
  _impl_.extra_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* GetClassificationsFromCameraRequest::_internal_mutable_extra() {
  
  if (_impl_.extra_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.extra_ = p;
  }
  return _impl_.extra_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* GetClassificationsFromCameraRequest::mutable_extra() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_extra();
  // @@protoc_insertion_point(field_mutable:viam.service.vision.v1.GetClassificationsFromCameraRequest.extra)
  return _msg;
}
inline void GetClassificationsFromCameraRequest::set_allocated_extra(::PROTOBUF_NAMESPACE_ID::Struct* extra) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.extra_);
  }
  if (extra) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(extra));
    if (message_arena != submessage_arena) {
      extra = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, extra, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.extra_ = extra;
  // @@protoc_insertion_point(field_set_allocated:viam.service.vision.v1.GetClassificationsFromCameraRequest.extra)
}

// -------------------------------------------------------------------

// GetClassificationsFromCameraResponse

// repeated .viam.service.vision.v1.Classification classifications = 1 [json_name = "classifications"];
inline int GetClassificationsFromCameraResponse::_internal_classifications_size() const {
  return _impl_.classifications_.size();
}
inline int GetClassificationsFromCameraResponse::classifications_size() const {
  return _internal_classifications_size();
}
inline void GetClassificationsFromCameraResponse::clear_classifications() {
  _impl_.classifications_.Clear();
}
inline ::viam::service::vision::v1::Classification* GetClassificationsFromCameraResponse::mutable_classifications(int index) {
  // @@protoc_insertion_point(field_mutable:viam.service.vision.v1.GetClassificationsFromCameraResponse.classifications)
  return _impl_.classifications_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::service::vision::v1::Classification >*
GetClassificationsFromCameraResponse::mutable_classifications() {
  // @@protoc_insertion_point(field_mutable_list:viam.service.vision.v1.GetClassificationsFromCameraResponse.classifications)
  return &_impl_.classifications_;
}
inline const ::viam::service::vision::v1::Classification& GetClassificationsFromCameraResponse::_internal_classifications(int index) const {
  return _impl_.classifications_.Get(index);
}
inline const ::viam::service::vision::v1::Classification& GetClassificationsFromCameraResponse::classifications(int index) const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.GetClassificationsFromCameraResponse.classifications)
  return _internal_classifications(index);
}
inline ::viam::service::vision::v1::Classification* GetClassificationsFromCameraResponse::_internal_add_classifications() {
  return _impl_.classifications_.Add();
}
inline ::viam::service::vision::v1::Classification* GetClassificationsFromCameraResponse::add_classifications() {
  ::viam::service::vision::v1::Classification* _add = _internal_add_classifications();
  // @@protoc_insertion_point(field_add:viam.service.vision.v1.GetClassificationsFromCameraResponse.classifications)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::service::vision::v1::Classification >&
GetClassificationsFromCameraResponse::classifications() const {
  // @@protoc_insertion_point(field_list:viam.service.vision.v1.GetClassificationsFromCameraResponse.classifications)
  return _impl_.classifications_;
}

// -------------------------------------------------------------------

// Classification

// string class_name = 1 [json_name = "className"];
inline void Classification::clear_class_name() {
  _impl_.class_name_.ClearToEmpty();
}
inline const std::string& Classification::class_name() const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.Classification.class_name)
  return _internal_class_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Classification::set_class_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.class_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.service.vision.v1.Classification.class_name)
}
inline std::string* Classification::mutable_class_name() {
  std::string* _s = _internal_mutable_class_name();
  // @@protoc_insertion_point(field_mutable:viam.service.vision.v1.Classification.class_name)
  return _s;
}
inline const std::string& Classification::_internal_class_name() const {
  return _impl_.class_name_.Get();
}
inline void Classification::_internal_set_class_name(const std::string& value) {
  
  _impl_.class_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Classification::_internal_mutable_class_name() {
  
  return _impl_.class_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Classification::release_class_name() {
  // @@protoc_insertion_point(field_release:viam.service.vision.v1.Classification.class_name)
  return _impl_.class_name_.Release();
}
inline void Classification::set_allocated_class_name(std::string* class_name) {
  if (class_name != nullptr) {
    
  } else {
    
  }
  _impl_.class_name_.SetAllocated(class_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.class_name_.IsDefault()) {
    _impl_.class_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.vision.v1.Classification.class_name)
}

// double confidence = 2 [json_name = "confidence"];
inline void Classification::clear_confidence() {
  _impl_.confidence_ = 0;
}
inline double Classification::_internal_confidence() const {
  return _impl_.confidence_;
}
inline double Classification::confidence() const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.Classification.confidence)
  return _internal_confidence();
}
inline void Classification::_internal_set_confidence(double value) {
  
  _impl_.confidence_ = value;
}
inline void Classification::set_confidence(double value) {
  _internal_set_confidence(value);
  // @@protoc_insertion_point(field_set:viam.service.vision.v1.Classification.confidence)
}

// -------------------------------------------------------------------

// GetSegmenterNamesRequest

// string name = 1 [json_name = "name"];
inline void GetSegmenterNamesRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& GetSegmenterNamesRequest::name() const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.GetSegmenterNamesRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetSegmenterNamesRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.service.vision.v1.GetSegmenterNamesRequest.name)
}
inline std::string* GetSegmenterNamesRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.service.vision.v1.GetSegmenterNamesRequest.name)
  return _s;
}
inline const std::string& GetSegmenterNamesRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void GetSegmenterNamesRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* GetSegmenterNamesRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* GetSegmenterNamesRequest::release_name() {
  // @@protoc_insertion_point(field_release:viam.service.vision.v1.GetSegmenterNamesRequest.name)
  return _impl_.name_.Release();
}
inline void GetSegmenterNamesRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.vision.v1.GetSegmenterNamesRequest.name)
}

// .google.protobuf.Struct extra = 99 [json_name = "extra"];
inline bool GetSegmenterNamesRequest::_internal_has_extra() const {
  return this != internal_default_instance() && _impl_.extra_ != nullptr;
}
inline bool GetSegmenterNamesRequest::has_extra() const {
  return _internal_has_extra();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& GetSegmenterNamesRequest::_internal_extra() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.extra_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& GetSegmenterNamesRequest::extra() const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.GetSegmenterNamesRequest.extra)
  return _internal_extra();
}
inline void GetSegmenterNamesRequest::unsafe_arena_set_allocated_extra(
    ::PROTOBUF_NAMESPACE_ID::Struct* extra) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.extra_);
  }
  _impl_.extra_ = extra;
  if (extra) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.vision.v1.GetSegmenterNamesRequest.extra)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* GetSegmenterNamesRequest::release_extra() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.extra_;
  _impl_.extra_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* GetSegmenterNamesRequest::unsafe_arena_release_extra() {
  // @@protoc_insertion_point(field_release:viam.service.vision.v1.GetSegmenterNamesRequest.extra)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.extra_;
  _impl_.extra_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* GetSegmenterNamesRequest::_internal_mutable_extra() {
  
  if (_impl_.extra_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.extra_ = p;
  }
  return _impl_.extra_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* GetSegmenterNamesRequest::mutable_extra() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_extra();
  // @@protoc_insertion_point(field_mutable:viam.service.vision.v1.GetSegmenterNamesRequest.extra)
  return _msg;
}
inline void GetSegmenterNamesRequest::set_allocated_extra(::PROTOBUF_NAMESPACE_ID::Struct* extra) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.extra_);
  }
  if (extra) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(extra));
    if (message_arena != submessage_arena) {
      extra = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, extra, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.extra_ = extra;
  // @@protoc_insertion_point(field_set_allocated:viam.service.vision.v1.GetSegmenterNamesRequest.extra)
}

// -------------------------------------------------------------------

// GetSegmenterNamesResponse

// repeated string segmenter_names = 1 [json_name = "segmenterNames"];
inline int GetSegmenterNamesResponse::_internal_segmenter_names_size() const {
  return _impl_.segmenter_names_.size();
}
inline int GetSegmenterNamesResponse::segmenter_names_size() const {
  return _internal_segmenter_names_size();
}
inline void GetSegmenterNamesResponse::clear_segmenter_names() {
  _impl_.segmenter_names_.Clear();
}
inline std::string* GetSegmenterNamesResponse::add_segmenter_names() {
  std::string* _s = _internal_add_segmenter_names();
  // @@protoc_insertion_point(field_add_mutable:viam.service.vision.v1.GetSegmenterNamesResponse.segmenter_names)
  return _s;
}
inline const std::string& GetSegmenterNamesResponse::_internal_segmenter_names(int index) const {
  return _impl_.segmenter_names_.Get(index);
}
inline const std::string& GetSegmenterNamesResponse::segmenter_names(int index) const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.GetSegmenterNamesResponse.segmenter_names)
  return _internal_segmenter_names(index);
}
inline std::string* GetSegmenterNamesResponse::mutable_segmenter_names(int index) {
  // @@protoc_insertion_point(field_mutable:viam.service.vision.v1.GetSegmenterNamesResponse.segmenter_names)
  return _impl_.segmenter_names_.Mutable(index);
}
inline void GetSegmenterNamesResponse::set_segmenter_names(int index, const std::string& value) {
  _impl_.segmenter_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:viam.service.vision.v1.GetSegmenterNamesResponse.segmenter_names)
}
inline void GetSegmenterNamesResponse::set_segmenter_names(int index, std::string&& value) {
  _impl_.segmenter_names_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:viam.service.vision.v1.GetSegmenterNamesResponse.segmenter_names)
}
inline void GetSegmenterNamesResponse::set_segmenter_names(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.segmenter_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:viam.service.vision.v1.GetSegmenterNamesResponse.segmenter_names)
}
inline void GetSegmenterNamesResponse::set_segmenter_names(int index, const char* value, size_t size) {
  _impl_.segmenter_names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:viam.service.vision.v1.GetSegmenterNamesResponse.segmenter_names)
}
inline std::string* GetSegmenterNamesResponse::_internal_add_segmenter_names() {
  return _impl_.segmenter_names_.Add();
}
inline void GetSegmenterNamesResponse::add_segmenter_names(const std::string& value) {
  _impl_.segmenter_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:viam.service.vision.v1.GetSegmenterNamesResponse.segmenter_names)
}
inline void GetSegmenterNamesResponse::add_segmenter_names(std::string&& value) {
  _impl_.segmenter_names_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:viam.service.vision.v1.GetSegmenterNamesResponse.segmenter_names)
}
inline void GetSegmenterNamesResponse::add_segmenter_names(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.segmenter_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:viam.service.vision.v1.GetSegmenterNamesResponse.segmenter_names)
}
inline void GetSegmenterNamesResponse::add_segmenter_names(const char* value, size_t size) {
  _impl_.segmenter_names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:viam.service.vision.v1.GetSegmenterNamesResponse.segmenter_names)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetSegmenterNamesResponse::segmenter_names() const {
  // @@protoc_insertion_point(field_list:viam.service.vision.v1.GetSegmenterNamesResponse.segmenter_names)
  return _impl_.segmenter_names_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetSegmenterNamesResponse::mutable_segmenter_names() {
  // @@protoc_insertion_point(field_mutable_list:viam.service.vision.v1.GetSegmenterNamesResponse.segmenter_names)
  return &_impl_.segmenter_names_;
}

// -------------------------------------------------------------------

// AddSegmenterRequest

// string name = 1 [json_name = "name"];
inline void AddSegmenterRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& AddSegmenterRequest::name() const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.AddSegmenterRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddSegmenterRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.service.vision.v1.AddSegmenterRequest.name)
}
inline std::string* AddSegmenterRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.service.vision.v1.AddSegmenterRequest.name)
  return _s;
}
inline const std::string& AddSegmenterRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void AddSegmenterRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* AddSegmenterRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* AddSegmenterRequest::release_name() {
  // @@protoc_insertion_point(field_release:viam.service.vision.v1.AddSegmenterRequest.name)
  return _impl_.name_.Release();
}
inline void AddSegmenterRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.vision.v1.AddSegmenterRequest.name)
}

// string segmenter_name = 2 [json_name = "segmenterName"];
inline void AddSegmenterRequest::clear_segmenter_name() {
  _impl_.segmenter_name_.ClearToEmpty();
}
inline const std::string& AddSegmenterRequest::segmenter_name() const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.AddSegmenterRequest.segmenter_name)
  return _internal_segmenter_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddSegmenterRequest::set_segmenter_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.segmenter_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.service.vision.v1.AddSegmenterRequest.segmenter_name)
}
inline std::string* AddSegmenterRequest::mutable_segmenter_name() {
  std::string* _s = _internal_mutable_segmenter_name();
  // @@protoc_insertion_point(field_mutable:viam.service.vision.v1.AddSegmenterRequest.segmenter_name)
  return _s;
}
inline const std::string& AddSegmenterRequest::_internal_segmenter_name() const {
  return _impl_.segmenter_name_.Get();
}
inline void AddSegmenterRequest::_internal_set_segmenter_name(const std::string& value) {
  
  _impl_.segmenter_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AddSegmenterRequest::_internal_mutable_segmenter_name() {
  
  return _impl_.segmenter_name_.Mutable(GetArenaForAllocation());
}
inline std::string* AddSegmenterRequest::release_segmenter_name() {
  // @@protoc_insertion_point(field_release:viam.service.vision.v1.AddSegmenterRequest.segmenter_name)
  return _impl_.segmenter_name_.Release();
}
inline void AddSegmenterRequest::set_allocated_segmenter_name(std::string* segmenter_name) {
  if (segmenter_name != nullptr) {
    
  } else {
    
  }
  _impl_.segmenter_name_.SetAllocated(segmenter_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.segmenter_name_.IsDefault()) {
    _impl_.segmenter_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.vision.v1.AddSegmenterRequest.segmenter_name)
}

// string segmenter_model_type = 3 [json_name = "segmenterModelType"];
inline void AddSegmenterRequest::clear_segmenter_model_type() {
  _impl_.segmenter_model_type_.ClearToEmpty();
}
inline const std::string& AddSegmenterRequest::segmenter_model_type() const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.AddSegmenterRequest.segmenter_model_type)
  return _internal_segmenter_model_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddSegmenterRequest::set_segmenter_model_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.segmenter_model_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.service.vision.v1.AddSegmenterRequest.segmenter_model_type)
}
inline std::string* AddSegmenterRequest::mutable_segmenter_model_type() {
  std::string* _s = _internal_mutable_segmenter_model_type();
  // @@protoc_insertion_point(field_mutable:viam.service.vision.v1.AddSegmenterRequest.segmenter_model_type)
  return _s;
}
inline const std::string& AddSegmenterRequest::_internal_segmenter_model_type() const {
  return _impl_.segmenter_model_type_.Get();
}
inline void AddSegmenterRequest::_internal_set_segmenter_model_type(const std::string& value) {
  
  _impl_.segmenter_model_type_.Set(value, GetArenaForAllocation());
}
inline std::string* AddSegmenterRequest::_internal_mutable_segmenter_model_type() {
  
  return _impl_.segmenter_model_type_.Mutable(GetArenaForAllocation());
}
inline std::string* AddSegmenterRequest::release_segmenter_model_type() {
  // @@protoc_insertion_point(field_release:viam.service.vision.v1.AddSegmenterRequest.segmenter_model_type)
  return _impl_.segmenter_model_type_.Release();
}
inline void AddSegmenterRequest::set_allocated_segmenter_model_type(std::string* segmenter_model_type) {
  if (segmenter_model_type != nullptr) {
    
  } else {
    
  }
  _impl_.segmenter_model_type_.SetAllocated(segmenter_model_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.segmenter_model_type_.IsDefault()) {
    _impl_.segmenter_model_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.vision.v1.AddSegmenterRequest.segmenter_model_type)
}

// .google.protobuf.Struct segmenter_parameters = 4 [json_name = "segmenterParameters"];
inline bool AddSegmenterRequest::_internal_has_segmenter_parameters() const {
  return this != internal_default_instance() && _impl_.segmenter_parameters_ != nullptr;
}
inline bool AddSegmenterRequest::has_segmenter_parameters() const {
  return _internal_has_segmenter_parameters();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& AddSegmenterRequest::_internal_segmenter_parameters() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.segmenter_parameters_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& AddSegmenterRequest::segmenter_parameters() const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.AddSegmenterRequest.segmenter_parameters)
  return _internal_segmenter_parameters();
}
inline void AddSegmenterRequest::unsafe_arena_set_allocated_segmenter_parameters(
    ::PROTOBUF_NAMESPACE_ID::Struct* segmenter_parameters) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.segmenter_parameters_);
  }
  _impl_.segmenter_parameters_ = segmenter_parameters;
  if (segmenter_parameters) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.vision.v1.AddSegmenterRequest.segmenter_parameters)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AddSegmenterRequest::release_segmenter_parameters() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.segmenter_parameters_;
  _impl_.segmenter_parameters_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AddSegmenterRequest::unsafe_arena_release_segmenter_parameters() {
  // @@protoc_insertion_point(field_release:viam.service.vision.v1.AddSegmenterRequest.segmenter_parameters)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.segmenter_parameters_;
  _impl_.segmenter_parameters_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AddSegmenterRequest::_internal_mutable_segmenter_parameters() {
  
  if (_impl_.segmenter_parameters_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.segmenter_parameters_ = p;
  }
  return _impl_.segmenter_parameters_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AddSegmenterRequest::mutable_segmenter_parameters() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_segmenter_parameters();
  // @@protoc_insertion_point(field_mutable:viam.service.vision.v1.AddSegmenterRequest.segmenter_parameters)
  return _msg;
}
inline void AddSegmenterRequest::set_allocated_segmenter_parameters(::PROTOBUF_NAMESPACE_ID::Struct* segmenter_parameters) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.segmenter_parameters_);
  }
  if (segmenter_parameters) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(segmenter_parameters));
    if (message_arena != submessage_arena) {
      segmenter_parameters = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, segmenter_parameters, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.segmenter_parameters_ = segmenter_parameters;
  // @@protoc_insertion_point(field_set_allocated:viam.service.vision.v1.AddSegmenterRequest.segmenter_parameters)
}

// .google.protobuf.Struct extra = 99 [json_name = "extra"];
inline bool AddSegmenterRequest::_internal_has_extra() const {
  return this != internal_default_instance() && _impl_.extra_ != nullptr;
}
inline bool AddSegmenterRequest::has_extra() const {
  return _internal_has_extra();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& AddSegmenterRequest::_internal_extra() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.extra_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& AddSegmenterRequest::extra() const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.AddSegmenterRequest.extra)
  return _internal_extra();
}
inline void AddSegmenterRequest::unsafe_arena_set_allocated_extra(
    ::PROTOBUF_NAMESPACE_ID::Struct* extra) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.extra_);
  }
  _impl_.extra_ = extra;
  if (extra) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.vision.v1.AddSegmenterRequest.extra)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AddSegmenterRequest::release_extra() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.extra_;
  _impl_.extra_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AddSegmenterRequest::unsafe_arena_release_extra() {
  // @@protoc_insertion_point(field_release:viam.service.vision.v1.AddSegmenterRequest.extra)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.extra_;
  _impl_.extra_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AddSegmenterRequest::_internal_mutable_extra() {
  
  if (_impl_.extra_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.extra_ = p;
  }
  return _impl_.extra_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AddSegmenterRequest::mutable_extra() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_extra();
  // @@protoc_insertion_point(field_mutable:viam.service.vision.v1.AddSegmenterRequest.extra)
  return _msg;
}
inline void AddSegmenterRequest::set_allocated_extra(::PROTOBUF_NAMESPACE_ID::Struct* extra) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.extra_);
  }
  if (extra) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(extra));
    if (message_arena != submessage_arena) {
      extra = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, extra, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.extra_ = extra;
  // @@protoc_insertion_point(field_set_allocated:viam.service.vision.v1.AddSegmenterRequest.extra)
}

// -------------------------------------------------------------------

// AddSegmenterResponse

// -------------------------------------------------------------------

// RemoveSegmenterRequest

// string name = 1 [json_name = "name"];
inline void RemoveSegmenterRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& RemoveSegmenterRequest::name() const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.RemoveSegmenterRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RemoveSegmenterRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.service.vision.v1.RemoveSegmenterRequest.name)
}
inline std::string* RemoveSegmenterRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.service.vision.v1.RemoveSegmenterRequest.name)
  return _s;
}
inline const std::string& RemoveSegmenterRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void RemoveSegmenterRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* RemoveSegmenterRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* RemoveSegmenterRequest::release_name() {
  // @@protoc_insertion_point(field_release:viam.service.vision.v1.RemoveSegmenterRequest.name)
  return _impl_.name_.Release();
}
inline void RemoveSegmenterRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.vision.v1.RemoveSegmenterRequest.name)
}

// string segmenter_name = 2 [json_name = "segmenterName"];
inline void RemoveSegmenterRequest::clear_segmenter_name() {
  _impl_.segmenter_name_.ClearToEmpty();
}
inline const std::string& RemoveSegmenterRequest::segmenter_name() const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.RemoveSegmenterRequest.segmenter_name)
  return _internal_segmenter_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RemoveSegmenterRequest::set_segmenter_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.segmenter_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.service.vision.v1.RemoveSegmenterRequest.segmenter_name)
}
inline std::string* RemoveSegmenterRequest::mutable_segmenter_name() {
  std::string* _s = _internal_mutable_segmenter_name();
  // @@protoc_insertion_point(field_mutable:viam.service.vision.v1.RemoveSegmenterRequest.segmenter_name)
  return _s;
}
inline const std::string& RemoveSegmenterRequest::_internal_segmenter_name() const {
  return _impl_.segmenter_name_.Get();
}
inline void RemoveSegmenterRequest::_internal_set_segmenter_name(const std::string& value) {
  
  _impl_.segmenter_name_.Set(value, GetArenaForAllocation());
}
inline std::string* RemoveSegmenterRequest::_internal_mutable_segmenter_name() {
  
  return _impl_.segmenter_name_.Mutable(GetArenaForAllocation());
}
inline std::string* RemoveSegmenterRequest::release_segmenter_name() {
  // @@protoc_insertion_point(field_release:viam.service.vision.v1.RemoveSegmenterRequest.segmenter_name)
  return _impl_.segmenter_name_.Release();
}
inline void RemoveSegmenterRequest::set_allocated_segmenter_name(std::string* segmenter_name) {
  if (segmenter_name != nullptr) {
    
  } else {
    
  }
  _impl_.segmenter_name_.SetAllocated(segmenter_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.segmenter_name_.IsDefault()) {
    _impl_.segmenter_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.vision.v1.RemoveSegmenterRequest.segmenter_name)
}

// .google.protobuf.Struct extra = 99 [json_name = "extra"];
inline bool RemoveSegmenterRequest::_internal_has_extra() const {
  return this != internal_default_instance() && _impl_.extra_ != nullptr;
}
inline bool RemoveSegmenterRequest::has_extra() const {
  return _internal_has_extra();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& RemoveSegmenterRequest::_internal_extra() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.extra_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& RemoveSegmenterRequest::extra() const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.RemoveSegmenterRequest.extra)
  return _internal_extra();
}
inline void RemoveSegmenterRequest::unsafe_arena_set_allocated_extra(
    ::PROTOBUF_NAMESPACE_ID::Struct* extra) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.extra_);
  }
  _impl_.extra_ = extra;
  if (extra) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.vision.v1.RemoveSegmenterRequest.extra)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* RemoveSegmenterRequest::release_extra() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.extra_;
  _impl_.extra_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* RemoveSegmenterRequest::unsafe_arena_release_extra() {
  // @@protoc_insertion_point(field_release:viam.service.vision.v1.RemoveSegmenterRequest.extra)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.extra_;
  _impl_.extra_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* RemoveSegmenterRequest::_internal_mutable_extra() {
  
  if (_impl_.extra_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.extra_ = p;
  }
  return _impl_.extra_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* RemoveSegmenterRequest::mutable_extra() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_extra();
  // @@protoc_insertion_point(field_mutable:viam.service.vision.v1.RemoveSegmenterRequest.extra)
  return _msg;
}
inline void RemoveSegmenterRequest::set_allocated_extra(::PROTOBUF_NAMESPACE_ID::Struct* extra) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.extra_);
  }
  if (extra) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(extra));
    if (message_arena != submessage_arena) {
      extra = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, extra, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.extra_ = extra;
  // @@protoc_insertion_point(field_set_allocated:viam.service.vision.v1.RemoveSegmenterRequest.extra)
}

// -------------------------------------------------------------------

// RemoveSegmenterResponse

// -------------------------------------------------------------------

// GetObjectPointCloudsRequest

// string name = 1 [json_name = "name"];
inline void GetObjectPointCloudsRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& GetObjectPointCloudsRequest::name() const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.GetObjectPointCloudsRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetObjectPointCloudsRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.service.vision.v1.GetObjectPointCloudsRequest.name)
}
inline std::string* GetObjectPointCloudsRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.service.vision.v1.GetObjectPointCloudsRequest.name)
  return _s;
}
inline const std::string& GetObjectPointCloudsRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void GetObjectPointCloudsRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* GetObjectPointCloudsRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* GetObjectPointCloudsRequest::release_name() {
  // @@protoc_insertion_point(field_release:viam.service.vision.v1.GetObjectPointCloudsRequest.name)
  return _impl_.name_.Release();
}
inline void GetObjectPointCloudsRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.vision.v1.GetObjectPointCloudsRequest.name)
}

// string camera_name = 2 [json_name = "cameraName"];
inline void GetObjectPointCloudsRequest::clear_camera_name() {
  _impl_.camera_name_.ClearToEmpty();
}
inline const std::string& GetObjectPointCloudsRequest::camera_name() const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.GetObjectPointCloudsRequest.camera_name)
  return _internal_camera_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetObjectPointCloudsRequest::set_camera_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.camera_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.service.vision.v1.GetObjectPointCloudsRequest.camera_name)
}
inline std::string* GetObjectPointCloudsRequest::mutable_camera_name() {
  std::string* _s = _internal_mutable_camera_name();
  // @@protoc_insertion_point(field_mutable:viam.service.vision.v1.GetObjectPointCloudsRequest.camera_name)
  return _s;
}
inline const std::string& GetObjectPointCloudsRequest::_internal_camera_name() const {
  return _impl_.camera_name_.Get();
}
inline void GetObjectPointCloudsRequest::_internal_set_camera_name(const std::string& value) {
  
  _impl_.camera_name_.Set(value, GetArenaForAllocation());
}
inline std::string* GetObjectPointCloudsRequest::_internal_mutable_camera_name() {
  
  return _impl_.camera_name_.Mutable(GetArenaForAllocation());
}
inline std::string* GetObjectPointCloudsRequest::release_camera_name() {
  // @@protoc_insertion_point(field_release:viam.service.vision.v1.GetObjectPointCloudsRequest.camera_name)
  return _impl_.camera_name_.Release();
}
inline void GetObjectPointCloudsRequest::set_allocated_camera_name(std::string* camera_name) {
  if (camera_name != nullptr) {
    
  } else {
    
  }
  _impl_.camera_name_.SetAllocated(camera_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.camera_name_.IsDefault()) {
    _impl_.camera_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.vision.v1.GetObjectPointCloudsRequest.camera_name)
}

// string segmenter_name = 3 [json_name = "segmenterName"];
inline void GetObjectPointCloudsRequest::clear_segmenter_name() {
  _impl_.segmenter_name_.ClearToEmpty();
}
inline const std::string& GetObjectPointCloudsRequest::segmenter_name() const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.GetObjectPointCloudsRequest.segmenter_name)
  return _internal_segmenter_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetObjectPointCloudsRequest::set_segmenter_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.segmenter_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.service.vision.v1.GetObjectPointCloudsRequest.segmenter_name)
}
inline std::string* GetObjectPointCloudsRequest::mutable_segmenter_name() {
  std::string* _s = _internal_mutable_segmenter_name();
  // @@protoc_insertion_point(field_mutable:viam.service.vision.v1.GetObjectPointCloudsRequest.segmenter_name)
  return _s;
}
inline const std::string& GetObjectPointCloudsRequest::_internal_segmenter_name() const {
  return _impl_.segmenter_name_.Get();
}
inline void GetObjectPointCloudsRequest::_internal_set_segmenter_name(const std::string& value) {
  
  _impl_.segmenter_name_.Set(value, GetArenaForAllocation());
}
inline std::string* GetObjectPointCloudsRequest::_internal_mutable_segmenter_name() {
  
  return _impl_.segmenter_name_.Mutable(GetArenaForAllocation());
}
inline std::string* GetObjectPointCloudsRequest::release_segmenter_name() {
  // @@protoc_insertion_point(field_release:viam.service.vision.v1.GetObjectPointCloudsRequest.segmenter_name)
  return _impl_.segmenter_name_.Release();
}
inline void GetObjectPointCloudsRequest::set_allocated_segmenter_name(std::string* segmenter_name) {
  if (segmenter_name != nullptr) {
    
  } else {
    
  }
  _impl_.segmenter_name_.SetAllocated(segmenter_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.segmenter_name_.IsDefault()) {
    _impl_.segmenter_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.vision.v1.GetObjectPointCloudsRequest.segmenter_name)
}

// string mime_type = 4 [json_name = "mimeType"];
inline void GetObjectPointCloudsRequest::clear_mime_type() {
  _impl_.mime_type_.ClearToEmpty();
}
inline const std::string& GetObjectPointCloudsRequest::mime_type() const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.GetObjectPointCloudsRequest.mime_type)
  return _internal_mime_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetObjectPointCloudsRequest::set_mime_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mime_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.service.vision.v1.GetObjectPointCloudsRequest.mime_type)
}
inline std::string* GetObjectPointCloudsRequest::mutable_mime_type() {
  std::string* _s = _internal_mutable_mime_type();
  // @@protoc_insertion_point(field_mutable:viam.service.vision.v1.GetObjectPointCloudsRequest.mime_type)
  return _s;
}
inline const std::string& GetObjectPointCloudsRequest::_internal_mime_type() const {
  return _impl_.mime_type_.Get();
}
inline void GetObjectPointCloudsRequest::_internal_set_mime_type(const std::string& value) {
  
  _impl_.mime_type_.Set(value, GetArenaForAllocation());
}
inline std::string* GetObjectPointCloudsRequest::_internal_mutable_mime_type() {
  
  return _impl_.mime_type_.Mutable(GetArenaForAllocation());
}
inline std::string* GetObjectPointCloudsRequest::release_mime_type() {
  // @@protoc_insertion_point(field_release:viam.service.vision.v1.GetObjectPointCloudsRequest.mime_type)
  return _impl_.mime_type_.Release();
}
inline void GetObjectPointCloudsRequest::set_allocated_mime_type(std::string* mime_type) {
  if (mime_type != nullptr) {
    
  } else {
    
  }
  _impl_.mime_type_.SetAllocated(mime_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mime_type_.IsDefault()) {
    _impl_.mime_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.vision.v1.GetObjectPointCloudsRequest.mime_type)
}

// .google.protobuf.Struct extra = 99 [json_name = "extra"];
inline bool GetObjectPointCloudsRequest::_internal_has_extra() const {
  return this != internal_default_instance() && _impl_.extra_ != nullptr;
}
inline bool GetObjectPointCloudsRequest::has_extra() const {
  return _internal_has_extra();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& GetObjectPointCloudsRequest::_internal_extra() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.extra_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& GetObjectPointCloudsRequest::extra() const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.GetObjectPointCloudsRequest.extra)
  return _internal_extra();
}
inline void GetObjectPointCloudsRequest::unsafe_arena_set_allocated_extra(
    ::PROTOBUF_NAMESPACE_ID::Struct* extra) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.extra_);
  }
  _impl_.extra_ = extra;
  if (extra) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.service.vision.v1.GetObjectPointCloudsRequest.extra)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* GetObjectPointCloudsRequest::release_extra() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.extra_;
  _impl_.extra_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* GetObjectPointCloudsRequest::unsafe_arena_release_extra() {
  // @@protoc_insertion_point(field_release:viam.service.vision.v1.GetObjectPointCloudsRequest.extra)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.extra_;
  _impl_.extra_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* GetObjectPointCloudsRequest::_internal_mutable_extra() {
  
  if (_impl_.extra_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.extra_ = p;
  }
  return _impl_.extra_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* GetObjectPointCloudsRequest::mutable_extra() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_extra();
  // @@protoc_insertion_point(field_mutable:viam.service.vision.v1.GetObjectPointCloudsRequest.extra)
  return _msg;
}
inline void GetObjectPointCloudsRequest::set_allocated_extra(::PROTOBUF_NAMESPACE_ID::Struct* extra) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.extra_);
  }
  if (extra) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(extra));
    if (message_arena != submessage_arena) {
      extra = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, extra, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.extra_ = extra;
  // @@protoc_insertion_point(field_set_allocated:viam.service.vision.v1.GetObjectPointCloudsRequest.extra)
}

// -------------------------------------------------------------------

// GetObjectPointCloudsResponse

// string mime_type = 1 [json_name = "mimeType"];
inline void GetObjectPointCloudsResponse::clear_mime_type() {
  _impl_.mime_type_.ClearToEmpty();
}
inline const std::string& GetObjectPointCloudsResponse::mime_type() const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.GetObjectPointCloudsResponse.mime_type)
  return _internal_mime_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetObjectPointCloudsResponse::set_mime_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mime_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.service.vision.v1.GetObjectPointCloudsResponse.mime_type)
}
inline std::string* GetObjectPointCloudsResponse::mutable_mime_type() {
  std::string* _s = _internal_mutable_mime_type();
  // @@protoc_insertion_point(field_mutable:viam.service.vision.v1.GetObjectPointCloudsResponse.mime_type)
  return _s;
}
inline const std::string& GetObjectPointCloudsResponse::_internal_mime_type() const {
  return _impl_.mime_type_.Get();
}
inline void GetObjectPointCloudsResponse::_internal_set_mime_type(const std::string& value) {
  
  _impl_.mime_type_.Set(value, GetArenaForAllocation());
}
inline std::string* GetObjectPointCloudsResponse::_internal_mutable_mime_type() {
  
  return _impl_.mime_type_.Mutable(GetArenaForAllocation());
}
inline std::string* GetObjectPointCloudsResponse::release_mime_type() {
  // @@protoc_insertion_point(field_release:viam.service.vision.v1.GetObjectPointCloudsResponse.mime_type)
  return _impl_.mime_type_.Release();
}
inline void GetObjectPointCloudsResponse::set_allocated_mime_type(std::string* mime_type) {
  if (mime_type != nullptr) {
    
  } else {
    
  }
  _impl_.mime_type_.SetAllocated(mime_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mime_type_.IsDefault()) {
    _impl_.mime_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.service.vision.v1.GetObjectPointCloudsResponse.mime_type)
}

// repeated .viam.common.v1.PointCloudObject objects = 2 [json_name = "objects"];
inline int GetObjectPointCloudsResponse::_internal_objects_size() const {
  return _impl_.objects_.size();
}
inline int GetObjectPointCloudsResponse::objects_size() const {
  return _internal_objects_size();
}
inline ::viam::common::v1::PointCloudObject* GetObjectPointCloudsResponse::mutable_objects(int index) {
  // @@protoc_insertion_point(field_mutable:viam.service.vision.v1.GetObjectPointCloudsResponse.objects)
  return _impl_.objects_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::common::v1::PointCloudObject >*
GetObjectPointCloudsResponse::mutable_objects() {
  // @@protoc_insertion_point(field_mutable_list:viam.service.vision.v1.GetObjectPointCloudsResponse.objects)
  return &_impl_.objects_;
}
inline const ::viam::common::v1::PointCloudObject& GetObjectPointCloudsResponse::_internal_objects(int index) const {
  return _impl_.objects_.Get(index);
}
inline const ::viam::common::v1::PointCloudObject& GetObjectPointCloudsResponse::objects(int index) const {
  // @@protoc_insertion_point(field_get:viam.service.vision.v1.GetObjectPointCloudsResponse.objects)
  return _internal_objects(index);
}
inline ::viam::common::v1::PointCloudObject* GetObjectPointCloudsResponse::_internal_add_objects() {
  return _impl_.objects_.Add();
}
inline ::viam::common::v1::PointCloudObject* GetObjectPointCloudsResponse::add_objects() {
  ::viam::common::v1::PointCloudObject* _add = _internal_add_objects();
  // @@protoc_insertion_point(field_add:viam.service.vision.v1.GetObjectPointCloudsResponse.objects)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::common::v1::PointCloudObject >&
GetObjectPointCloudsResponse::objects() const {
  // @@protoc_insertion_point(field_list:viam.service.vision.v1.GetObjectPointCloudsResponse.objects)
  return _impl_.objects_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace vision
}  // namespace service
}  // namespace viam

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_service_2fvision_2fv1_2fvision_2eproto
