// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: robot/v1/robot.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_robot_2fv1_2frobot_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_robot_2fv1_2frobot_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021011 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "common/v1/common.pb.h"
#include "google/api/annotations.pb.h"
#include <google/protobuf/duration.pb.h>
#include <google/protobuf/struct.pb.h>
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_robot_2fv1_2frobot_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_robot_2fv1_2frobot_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_robot_2fv1_2frobot_2eproto;
namespace viam {
namespace robot {
namespace v1 {
class BlockForOperationRequest;
struct BlockForOperationRequestDefaultTypeInternal;
extern BlockForOperationRequestDefaultTypeInternal _BlockForOperationRequest_default_instance_;
class BlockForOperationResponse;
struct BlockForOperationResponseDefaultTypeInternal;
extern BlockForOperationResponseDefaultTypeInternal _BlockForOperationResponse_default_instance_;
class CancelOperationRequest;
struct CancelOperationRequestDefaultTypeInternal;
extern CancelOperationRequestDefaultTypeInternal _CancelOperationRequest_default_instance_;
class CancelOperationResponse;
struct CancelOperationResponseDefaultTypeInternal;
extern CancelOperationResponseDefaultTypeInternal _CancelOperationResponse_default_instance_;
class DiscoverComponentsRequest;
struct DiscoverComponentsRequestDefaultTypeInternal;
extern DiscoverComponentsRequestDefaultTypeInternal _DiscoverComponentsRequest_default_instance_;
class DiscoverComponentsResponse;
struct DiscoverComponentsResponseDefaultTypeInternal;
extern DiscoverComponentsResponseDefaultTypeInternal _DiscoverComponentsResponse_default_instance_;
class Discovery;
struct DiscoveryDefaultTypeInternal;
extern DiscoveryDefaultTypeInternal _Discovery_default_instance_;
class DiscoveryQuery;
struct DiscoveryQueryDefaultTypeInternal;
extern DiscoveryQueryDefaultTypeInternal _DiscoveryQuery_default_instance_;
class FrameSystemConfig;
struct FrameSystemConfigDefaultTypeInternal;
extern FrameSystemConfigDefaultTypeInternal _FrameSystemConfig_default_instance_;
class FrameSystemConfigRequest;
struct FrameSystemConfigRequestDefaultTypeInternal;
extern FrameSystemConfigRequestDefaultTypeInternal _FrameSystemConfigRequest_default_instance_;
class FrameSystemConfigResponse;
struct FrameSystemConfigResponseDefaultTypeInternal;
extern FrameSystemConfigResponseDefaultTypeInternal _FrameSystemConfigResponse_default_instance_;
class GetOperationsRequest;
struct GetOperationsRequestDefaultTypeInternal;
extern GetOperationsRequestDefaultTypeInternal _GetOperationsRequest_default_instance_;
class GetOperationsResponse;
struct GetOperationsResponseDefaultTypeInternal;
extern GetOperationsResponseDefaultTypeInternal _GetOperationsResponse_default_instance_;
class GetSessionsRequest;
struct GetSessionsRequestDefaultTypeInternal;
extern GetSessionsRequestDefaultTypeInternal _GetSessionsRequest_default_instance_;
class GetSessionsResponse;
struct GetSessionsResponseDefaultTypeInternal;
extern GetSessionsResponseDefaultTypeInternal _GetSessionsResponse_default_instance_;
class GetStatusRequest;
struct GetStatusRequestDefaultTypeInternal;
extern GetStatusRequestDefaultTypeInternal _GetStatusRequest_default_instance_;
class GetStatusResponse;
struct GetStatusResponseDefaultTypeInternal;
extern GetStatusResponseDefaultTypeInternal _GetStatusResponse_default_instance_;
class Operation;
struct OperationDefaultTypeInternal;
extern OperationDefaultTypeInternal _Operation_default_instance_;
class PeerConnectionInfo;
struct PeerConnectionInfoDefaultTypeInternal;
extern PeerConnectionInfoDefaultTypeInternal _PeerConnectionInfo_default_instance_;
class ResourceNamesRequest;
struct ResourceNamesRequestDefaultTypeInternal;
extern ResourceNamesRequestDefaultTypeInternal _ResourceNamesRequest_default_instance_;
class ResourceNamesResponse;
struct ResourceNamesResponseDefaultTypeInternal;
extern ResourceNamesResponseDefaultTypeInternal _ResourceNamesResponse_default_instance_;
class ResourceRPCSubtype;
struct ResourceRPCSubtypeDefaultTypeInternal;
extern ResourceRPCSubtypeDefaultTypeInternal _ResourceRPCSubtype_default_instance_;
class ResourceRPCSubtypesRequest;
struct ResourceRPCSubtypesRequestDefaultTypeInternal;
extern ResourceRPCSubtypesRequestDefaultTypeInternal _ResourceRPCSubtypesRequest_default_instance_;
class ResourceRPCSubtypesResponse;
struct ResourceRPCSubtypesResponseDefaultTypeInternal;
extern ResourceRPCSubtypesResponseDefaultTypeInternal _ResourceRPCSubtypesResponse_default_instance_;
class SendSessionHeartbeatRequest;
struct SendSessionHeartbeatRequestDefaultTypeInternal;
extern SendSessionHeartbeatRequestDefaultTypeInternal _SendSessionHeartbeatRequest_default_instance_;
class SendSessionHeartbeatResponse;
struct SendSessionHeartbeatResponseDefaultTypeInternal;
extern SendSessionHeartbeatResponseDefaultTypeInternal _SendSessionHeartbeatResponse_default_instance_;
class Session;
struct SessionDefaultTypeInternal;
extern SessionDefaultTypeInternal _Session_default_instance_;
class StartSessionRequest;
struct StartSessionRequestDefaultTypeInternal;
extern StartSessionRequestDefaultTypeInternal _StartSessionRequest_default_instance_;
class StartSessionResponse;
struct StartSessionResponseDefaultTypeInternal;
extern StartSessionResponseDefaultTypeInternal _StartSessionResponse_default_instance_;
class Status;
struct StatusDefaultTypeInternal;
extern StatusDefaultTypeInternal _Status_default_instance_;
class StopAllRequest;
struct StopAllRequestDefaultTypeInternal;
extern StopAllRequestDefaultTypeInternal _StopAllRequest_default_instance_;
class StopAllResponse;
struct StopAllResponseDefaultTypeInternal;
extern StopAllResponseDefaultTypeInternal _StopAllResponse_default_instance_;
class StopExtraParameters;
struct StopExtraParametersDefaultTypeInternal;
extern StopExtraParametersDefaultTypeInternal _StopExtraParameters_default_instance_;
class StreamStatusRequest;
struct StreamStatusRequestDefaultTypeInternal;
extern StreamStatusRequestDefaultTypeInternal _StreamStatusRequest_default_instance_;
class StreamStatusResponse;
struct StreamStatusResponseDefaultTypeInternal;
extern StreamStatusResponseDefaultTypeInternal _StreamStatusResponse_default_instance_;
class TransformPoseRequest;
struct TransformPoseRequestDefaultTypeInternal;
extern TransformPoseRequestDefaultTypeInternal _TransformPoseRequest_default_instance_;
class TransformPoseResponse;
struct TransformPoseResponseDefaultTypeInternal;
extern TransformPoseResponseDefaultTypeInternal _TransformPoseResponse_default_instance_;
}  // namespace v1
}  // namespace robot
}  // namespace viam
PROTOBUF_NAMESPACE_OPEN
template<> ::viam::robot::v1::BlockForOperationRequest* Arena::CreateMaybeMessage<::viam::robot::v1::BlockForOperationRequest>(Arena*);
template<> ::viam::robot::v1::BlockForOperationResponse* Arena::CreateMaybeMessage<::viam::robot::v1::BlockForOperationResponse>(Arena*);
template<> ::viam::robot::v1::CancelOperationRequest* Arena::CreateMaybeMessage<::viam::robot::v1::CancelOperationRequest>(Arena*);
template<> ::viam::robot::v1::CancelOperationResponse* Arena::CreateMaybeMessage<::viam::robot::v1::CancelOperationResponse>(Arena*);
template<> ::viam::robot::v1::DiscoverComponentsRequest* Arena::CreateMaybeMessage<::viam::robot::v1::DiscoverComponentsRequest>(Arena*);
template<> ::viam::robot::v1::DiscoverComponentsResponse* Arena::CreateMaybeMessage<::viam::robot::v1::DiscoverComponentsResponse>(Arena*);
template<> ::viam::robot::v1::Discovery* Arena::CreateMaybeMessage<::viam::robot::v1::Discovery>(Arena*);
template<> ::viam::robot::v1::DiscoveryQuery* Arena::CreateMaybeMessage<::viam::robot::v1::DiscoveryQuery>(Arena*);
template<> ::viam::robot::v1::FrameSystemConfig* Arena::CreateMaybeMessage<::viam::robot::v1::FrameSystemConfig>(Arena*);
template<> ::viam::robot::v1::FrameSystemConfigRequest* Arena::CreateMaybeMessage<::viam::robot::v1::FrameSystemConfigRequest>(Arena*);
template<> ::viam::robot::v1::FrameSystemConfigResponse* Arena::CreateMaybeMessage<::viam::robot::v1::FrameSystemConfigResponse>(Arena*);
template<> ::viam::robot::v1::GetOperationsRequest* Arena::CreateMaybeMessage<::viam::robot::v1::GetOperationsRequest>(Arena*);
template<> ::viam::robot::v1::GetOperationsResponse* Arena::CreateMaybeMessage<::viam::robot::v1::GetOperationsResponse>(Arena*);
template<> ::viam::robot::v1::GetSessionsRequest* Arena::CreateMaybeMessage<::viam::robot::v1::GetSessionsRequest>(Arena*);
template<> ::viam::robot::v1::GetSessionsResponse* Arena::CreateMaybeMessage<::viam::robot::v1::GetSessionsResponse>(Arena*);
template<> ::viam::robot::v1::GetStatusRequest* Arena::CreateMaybeMessage<::viam::robot::v1::GetStatusRequest>(Arena*);
template<> ::viam::robot::v1::GetStatusResponse* Arena::CreateMaybeMessage<::viam::robot::v1::GetStatusResponse>(Arena*);
template<> ::viam::robot::v1::Operation* Arena::CreateMaybeMessage<::viam::robot::v1::Operation>(Arena*);
template<> ::viam::robot::v1::PeerConnectionInfo* Arena::CreateMaybeMessage<::viam::robot::v1::PeerConnectionInfo>(Arena*);
template<> ::viam::robot::v1::ResourceNamesRequest* Arena::CreateMaybeMessage<::viam::robot::v1::ResourceNamesRequest>(Arena*);
template<> ::viam::robot::v1::ResourceNamesResponse* Arena::CreateMaybeMessage<::viam::robot::v1::ResourceNamesResponse>(Arena*);
template<> ::viam::robot::v1::ResourceRPCSubtype* Arena::CreateMaybeMessage<::viam::robot::v1::ResourceRPCSubtype>(Arena*);
template<> ::viam::robot::v1::ResourceRPCSubtypesRequest* Arena::CreateMaybeMessage<::viam::robot::v1::ResourceRPCSubtypesRequest>(Arena*);
template<> ::viam::robot::v1::ResourceRPCSubtypesResponse* Arena::CreateMaybeMessage<::viam::robot::v1::ResourceRPCSubtypesResponse>(Arena*);
template<> ::viam::robot::v1::SendSessionHeartbeatRequest* Arena::CreateMaybeMessage<::viam::robot::v1::SendSessionHeartbeatRequest>(Arena*);
template<> ::viam::robot::v1::SendSessionHeartbeatResponse* Arena::CreateMaybeMessage<::viam::robot::v1::SendSessionHeartbeatResponse>(Arena*);
template<> ::viam::robot::v1::Session* Arena::CreateMaybeMessage<::viam::robot::v1::Session>(Arena*);
template<> ::viam::robot::v1::StartSessionRequest* Arena::CreateMaybeMessage<::viam::robot::v1::StartSessionRequest>(Arena*);
template<> ::viam::robot::v1::StartSessionResponse* Arena::CreateMaybeMessage<::viam::robot::v1::StartSessionResponse>(Arena*);
template<> ::viam::robot::v1::Status* Arena::CreateMaybeMessage<::viam::robot::v1::Status>(Arena*);
template<> ::viam::robot::v1::StopAllRequest* Arena::CreateMaybeMessage<::viam::robot::v1::StopAllRequest>(Arena*);
template<> ::viam::robot::v1::StopAllResponse* Arena::CreateMaybeMessage<::viam::robot::v1::StopAllResponse>(Arena*);
template<> ::viam::robot::v1::StopExtraParameters* Arena::CreateMaybeMessage<::viam::robot::v1::StopExtraParameters>(Arena*);
template<> ::viam::robot::v1::StreamStatusRequest* Arena::CreateMaybeMessage<::viam::robot::v1::StreamStatusRequest>(Arena*);
template<> ::viam::robot::v1::StreamStatusResponse* Arena::CreateMaybeMessage<::viam::robot::v1::StreamStatusResponse>(Arena*);
template<> ::viam::robot::v1::TransformPoseRequest* Arena::CreateMaybeMessage<::viam::robot::v1::TransformPoseRequest>(Arena*);
template<> ::viam::robot::v1::TransformPoseResponse* Arena::CreateMaybeMessage<::viam::robot::v1::TransformPoseResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace viam {
namespace robot {
namespace v1 {

enum PeerConnectionType : int {
  PEER_CONNECTION_TYPE_UNSPECIFIED = 0,
  PEER_CONNECTION_TYPE_GRPC = 1,
  PEER_CONNECTION_TYPE_WEBRTC = 2,
  PeerConnectionType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PeerConnectionType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PeerConnectionType_IsValid(int value);
constexpr PeerConnectionType PeerConnectionType_MIN = PEER_CONNECTION_TYPE_UNSPECIFIED;
constexpr PeerConnectionType PeerConnectionType_MAX = PEER_CONNECTION_TYPE_WEBRTC;
constexpr int PeerConnectionType_ARRAYSIZE = PeerConnectionType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PeerConnectionType_descriptor();
template<typename T>
inline const std::string& PeerConnectionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PeerConnectionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PeerConnectionType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PeerConnectionType_descriptor(), enum_t_value);
}
inline bool PeerConnectionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PeerConnectionType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PeerConnectionType>(
    PeerConnectionType_descriptor(), name, value);
}
// ===================================================================

class FrameSystemConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.robot.v1.FrameSystemConfig) */ {
 public:
  inline FrameSystemConfig() : FrameSystemConfig(nullptr) {}
  ~FrameSystemConfig() override;
  explicit PROTOBUF_CONSTEXPR FrameSystemConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FrameSystemConfig(const FrameSystemConfig& from);
  FrameSystemConfig(FrameSystemConfig&& from) noexcept
    : FrameSystemConfig() {
    *this = ::std::move(from);
  }

  inline FrameSystemConfig& operator=(const FrameSystemConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline FrameSystemConfig& operator=(FrameSystemConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FrameSystemConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const FrameSystemConfig* internal_default_instance() {
    return reinterpret_cast<const FrameSystemConfig*>(
               &_FrameSystemConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(FrameSystemConfig& a, FrameSystemConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(FrameSystemConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FrameSystemConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FrameSystemConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FrameSystemConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FrameSystemConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FrameSystemConfig& from) {
    FrameSystemConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FrameSystemConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.robot.v1.FrameSystemConfig";
  }
  protected:
  explicit FrameSystemConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFrameFieldNumber = 1,
    kKinematicsFieldNumber = 2,
  };
  // .viam.common.v1.Transform frame = 1 [json_name = "frame"];
  bool has_frame() const;
  private:
  bool _internal_has_frame() const;
  public:
  void clear_frame();
  const ::viam::common::v1::Transform& frame() const;
  PROTOBUF_NODISCARD ::viam::common::v1::Transform* release_frame();
  ::viam::common::v1::Transform* mutable_frame();
  void set_allocated_frame(::viam::common::v1::Transform* frame);
  private:
  const ::viam::common::v1::Transform& _internal_frame() const;
  ::viam::common::v1::Transform* _internal_mutable_frame();
  public:
  void unsafe_arena_set_allocated_frame(
      ::viam::common::v1::Transform* frame);
  ::viam::common::v1::Transform* unsafe_arena_release_frame();

  // .google.protobuf.Struct kinematics = 2 [json_name = "kinematics"];
  bool has_kinematics() const;
  private:
  bool _internal_has_kinematics() const;
  public:
  void clear_kinematics();
  const ::PROTOBUF_NAMESPACE_ID::Struct& kinematics() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_kinematics();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_kinematics();
  void set_allocated_kinematics(::PROTOBUF_NAMESPACE_ID::Struct* kinematics);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_kinematics() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_kinematics();
  public:
  void unsafe_arena_set_allocated_kinematics(
      ::PROTOBUF_NAMESPACE_ID::Struct* kinematics);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_kinematics();

  // @@protoc_insertion_point(class_scope:viam.robot.v1.FrameSystemConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::viam::common::v1::Transform* frame_;
    ::PROTOBUF_NAMESPACE_ID::Struct* kinematics_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class FrameSystemConfigRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.robot.v1.FrameSystemConfigRequest) */ {
 public:
  inline FrameSystemConfigRequest() : FrameSystemConfigRequest(nullptr) {}
  ~FrameSystemConfigRequest() override;
  explicit PROTOBUF_CONSTEXPR FrameSystemConfigRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FrameSystemConfigRequest(const FrameSystemConfigRequest& from);
  FrameSystemConfigRequest(FrameSystemConfigRequest&& from) noexcept
    : FrameSystemConfigRequest() {
    *this = ::std::move(from);
  }

  inline FrameSystemConfigRequest& operator=(const FrameSystemConfigRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FrameSystemConfigRequest& operator=(FrameSystemConfigRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FrameSystemConfigRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FrameSystemConfigRequest* internal_default_instance() {
    return reinterpret_cast<const FrameSystemConfigRequest*>(
               &_FrameSystemConfigRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(FrameSystemConfigRequest& a, FrameSystemConfigRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FrameSystemConfigRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FrameSystemConfigRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FrameSystemConfigRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FrameSystemConfigRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FrameSystemConfigRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FrameSystemConfigRequest& from) {
    FrameSystemConfigRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FrameSystemConfigRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.robot.v1.FrameSystemConfigRequest";
  }
  protected:
  explicit FrameSystemConfigRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSupplementalTransformsFieldNumber = 1,
  };
  // repeated .viam.common.v1.Transform supplemental_transforms = 1 [json_name = "supplementalTransforms"];
  int supplemental_transforms_size() const;
  private:
  int _internal_supplemental_transforms_size() const;
  public:
  void clear_supplemental_transforms();
  ::viam::common::v1::Transform* mutable_supplemental_transforms(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::common::v1::Transform >*
      mutable_supplemental_transforms();
  private:
  const ::viam::common::v1::Transform& _internal_supplemental_transforms(int index) const;
  ::viam::common::v1::Transform* _internal_add_supplemental_transforms();
  public:
  const ::viam::common::v1::Transform& supplemental_transforms(int index) const;
  ::viam::common::v1::Transform* add_supplemental_transforms();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::common::v1::Transform >&
      supplemental_transforms() const;

  // @@protoc_insertion_point(class_scope:viam.robot.v1.FrameSystemConfigRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::common::v1::Transform > supplemental_transforms_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class FrameSystemConfigResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.robot.v1.FrameSystemConfigResponse) */ {
 public:
  inline FrameSystemConfigResponse() : FrameSystemConfigResponse(nullptr) {}
  ~FrameSystemConfigResponse() override;
  explicit PROTOBUF_CONSTEXPR FrameSystemConfigResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FrameSystemConfigResponse(const FrameSystemConfigResponse& from);
  FrameSystemConfigResponse(FrameSystemConfigResponse&& from) noexcept
    : FrameSystemConfigResponse() {
    *this = ::std::move(from);
  }

  inline FrameSystemConfigResponse& operator=(const FrameSystemConfigResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline FrameSystemConfigResponse& operator=(FrameSystemConfigResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FrameSystemConfigResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const FrameSystemConfigResponse* internal_default_instance() {
    return reinterpret_cast<const FrameSystemConfigResponse*>(
               &_FrameSystemConfigResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(FrameSystemConfigResponse& a, FrameSystemConfigResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(FrameSystemConfigResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FrameSystemConfigResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FrameSystemConfigResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FrameSystemConfigResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FrameSystemConfigResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FrameSystemConfigResponse& from) {
    FrameSystemConfigResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FrameSystemConfigResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.robot.v1.FrameSystemConfigResponse";
  }
  protected:
  explicit FrameSystemConfigResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFrameSystemConfigsFieldNumber = 1,
  };
  // repeated .viam.robot.v1.FrameSystemConfig frame_system_configs = 1 [json_name = "frameSystemConfigs"];
  int frame_system_configs_size() const;
  private:
  int _internal_frame_system_configs_size() const;
  public:
  void clear_frame_system_configs();
  ::viam::robot::v1::FrameSystemConfig* mutable_frame_system_configs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::robot::v1::FrameSystemConfig >*
      mutable_frame_system_configs();
  private:
  const ::viam::robot::v1::FrameSystemConfig& _internal_frame_system_configs(int index) const;
  ::viam::robot::v1::FrameSystemConfig* _internal_add_frame_system_configs();
  public:
  const ::viam::robot::v1::FrameSystemConfig& frame_system_configs(int index) const;
  ::viam::robot::v1::FrameSystemConfig* add_frame_system_configs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::robot::v1::FrameSystemConfig >&
      frame_system_configs() const;

  // @@protoc_insertion_point(class_scope:viam.robot.v1.FrameSystemConfigResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::robot::v1::FrameSystemConfig > frame_system_configs_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class TransformPoseRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.robot.v1.TransformPoseRequest) */ {
 public:
  inline TransformPoseRequest() : TransformPoseRequest(nullptr) {}
  ~TransformPoseRequest() override;
  explicit PROTOBUF_CONSTEXPR TransformPoseRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransformPoseRequest(const TransformPoseRequest& from);
  TransformPoseRequest(TransformPoseRequest&& from) noexcept
    : TransformPoseRequest() {
    *this = ::std::move(from);
  }

  inline TransformPoseRequest& operator=(const TransformPoseRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransformPoseRequest& operator=(TransformPoseRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransformPoseRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransformPoseRequest* internal_default_instance() {
    return reinterpret_cast<const TransformPoseRequest*>(
               &_TransformPoseRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(TransformPoseRequest& a, TransformPoseRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TransformPoseRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransformPoseRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransformPoseRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransformPoseRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransformPoseRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TransformPoseRequest& from) {
    TransformPoseRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransformPoseRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.robot.v1.TransformPoseRequest";
  }
  protected:
  explicit TransformPoseRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSupplementalTransformsFieldNumber = 3,
    kDestinationFieldNumber = 2,
    kSourceFieldNumber = 1,
  };
  // repeated .viam.common.v1.Transform supplemental_transforms = 3 [json_name = "supplementalTransforms"];
  int supplemental_transforms_size() const;
  private:
  int _internal_supplemental_transforms_size() const;
  public:
  void clear_supplemental_transforms();
  ::viam::common::v1::Transform* mutable_supplemental_transforms(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::common::v1::Transform >*
      mutable_supplemental_transforms();
  private:
  const ::viam::common::v1::Transform& _internal_supplemental_transforms(int index) const;
  ::viam::common::v1::Transform* _internal_add_supplemental_transforms();
  public:
  const ::viam::common::v1::Transform& supplemental_transforms(int index) const;
  ::viam::common::v1::Transform* add_supplemental_transforms();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::common::v1::Transform >&
      supplemental_transforms() const;

  // string destination = 2 [json_name = "destination"];
  void clear_destination();
  const std::string& destination() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_destination(ArgT0&& arg0, ArgT... args);
  std::string* mutable_destination();
  PROTOBUF_NODISCARD std::string* release_destination();
  void set_allocated_destination(std::string* destination);
  private:
  const std::string& _internal_destination() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_destination(const std::string& value);
  std::string* _internal_mutable_destination();
  public:

  // .viam.common.v1.PoseInFrame source = 1 [json_name = "source"];
  bool has_source() const;
  private:
  bool _internal_has_source() const;
  public:
  void clear_source();
  const ::viam::common::v1::PoseInFrame& source() const;
  PROTOBUF_NODISCARD ::viam::common::v1::PoseInFrame* release_source();
  ::viam::common::v1::PoseInFrame* mutable_source();
  void set_allocated_source(::viam::common::v1::PoseInFrame* source);
  private:
  const ::viam::common::v1::PoseInFrame& _internal_source() const;
  ::viam::common::v1::PoseInFrame* _internal_mutable_source();
  public:
  void unsafe_arena_set_allocated_source(
      ::viam::common::v1::PoseInFrame* source);
  ::viam::common::v1::PoseInFrame* unsafe_arena_release_source();

  // @@protoc_insertion_point(class_scope:viam.robot.v1.TransformPoseRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::common::v1::Transform > supplemental_transforms_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr destination_;
    ::viam::common::v1::PoseInFrame* source_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class TransformPoseResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.robot.v1.TransformPoseResponse) */ {
 public:
  inline TransformPoseResponse() : TransformPoseResponse(nullptr) {}
  ~TransformPoseResponse() override;
  explicit PROTOBUF_CONSTEXPR TransformPoseResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransformPoseResponse(const TransformPoseResponse& from);
  TransformPoseResponse(TransformPoseResponse&& from) noexcept
    : TransformPoseResponse() {
    *this = ::std::move(from);
  }

  inline TransformPoseResponse& operator=(const TransformPoseResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransformPoseResponse& operator=(TransformPoseResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransformPoseResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransformPoseResponse* internal_default_instance() {
    return reinterpret_cast<const TransformPoseResponse*>(
               &_TransformPoseResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(TransformPoseResponse& a, TransformPoseResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(TransformPoseResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransformPoseResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransformPoseResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransformPoseResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransformPoseResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TransformPoseResponse& from) {
    TransformPoseResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransformPoseResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.robot.v1.TransformPoseResponse";
  }
  protected:
  explicit TransformPoseResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPoseFieldNumber = 1,
  };
  // .viam.common.v1.PoseInFrame pose = 1 [json_name = "pose"];
  bool has_pose() const;
  private:
  bool _internal_has_pose() const;
  public:
  void clear_pose();
  const ::viam::common::v1::PoseInFrame& pose() const;
  PROTOBUF_NODISCARD ::viam::common::v1::PoseInFrame* release_pose();
  ::viam::common::v1::PoseInFrame* mutable_pose();
  void set_allocated_pose(::viam::common::v1::PoseInFrame* pose);
  private:
  const ::viam::common::v1::PoseInFrame& _internal_pose() const;
  ::viam::common::v1::PoseInFrame* _internal_mutable_pose();
  public:
  void unsafe_arena_set_allocated_pose(
      ::viam::common::v1::PoseInFrame* pose);
  ::viam::common::v1::PoseInFrame* unsafe_arena_release_pose();

  // @@protoc_insertion_point(class_scope:viam.robot.v1.TransformPoseResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::viam::common::v1::PoseInFrame* pose_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class ResourceNamesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.robot.v1.ResourceNamesRequest) */ {
 public:
  inline ResourceNamesRequest() : ResourceNamesRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ResourceNamesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResourceNamesRequest(const ResourceNamesRequest& from);
  ResourceNamesRequest(ResourceNamesRequest&& from) noexcept
    : ResourceNamesRequest() {
    *this = ::std::move(from);
  }

  inline ResourceNamesRequest& operator=(const ResourceNamesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResourceNamesRequest& operator=(ResourceNamesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResourceNamesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResourceNamesRequest* internal_default_instance() {
    return reinterpret_cast<const ResourceNamesRequest*>(
               &_ResourceNamesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ResourceNamesRequest& a, ResourceNamesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ResourceNamesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResourceNamesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResourceNamesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResourceNamesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ResourceNamesRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ResourceNamesRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.robot.v1.ResourceNamesRequest";
  }
  protected:
  explicit ResourceNamesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.robot.v1.ResourceNamesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_robot_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class ResourceNamesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.robot.v1.ResourceNamesResponse) */ {
 public:
  inline ResourceNamesResponse() : ResourceNamesResponse(nullptr) {}
  ~ResourceNamesResponse() override;
  explicit PROTOBUF_CONSTEXPR ResourceNamesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResourceNamesResponse(const ResourceNamesResponse& from);
  ResourceNamesResponse(ResourceNamesResponse&& from) noexcept
    : ResourceNamesResponse() {
    *this = ::std::move(from);
  }

  inline ResourceNamesResponse& operator=(const ResourceNamesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResourceNamesResponse& operator=(ResourceNamesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResourceNamesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResourceNamesResponse* internal_default_instance() {
    return reinterpret_cast<const ResourceNamesResponse*>(
               &_ResourceNamesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ResourceNamesResponse& a, ResourceNamesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ResourceNamesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResourceNamesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResourceNamesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResourceNamesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResourceNamesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResourceNamesResponse& from) {
    ResourceNamesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResourceNamesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.robot.v1.ResourceNamesResponse";
  }
  protected:
  explicit ResourceNamesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResourcesFieldNumber = 1,
  };
  // repeated .viam.common.v1.ResourceName resources = 1 [json_name = "resources"];
  int resources_size() const;
  private:
  int _internal_resources_size() const;
  public:
  void clear_resources();
  ::viam::common::v1::ResourceName* mutable_resources(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::common::v1::ResourceName >*
      mutable_resources();
  private:
  const ::viam::common::v1::ResourceName& _internal_resources(int index) const;
  ::viam::common::v1::ResourceName* _internal_add_resources();
  public:
  const ::viam::common::v1::ResourceName& resources(int index) const;
  ::viam::common::v1::ResourceName* add_resources();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::common::v1::ResourceName >&
      resources() const;

  // @@protoc_insertion_point(class_scope:viam.robot.v1.ResourceNamesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::common::v1::ResourceName > resources_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class ResourceRPCSubtype final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.robot.v1.ResourceRPCSubtype) */ {
 public:
  inline ResourceRPCSubtype() : ResourceRPCSubtype(nullptr) {}
  ~ResourceRPCSubtype() override;
  explicit PROTOBUF_CONSTEXPR ResourceRPCSubtype(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResourceRPCSubtype(const ResourceRPCSubtype& from);
  ResourceRPCSubtype(ResourceRPCSubtype&& from) noexcept
    : ResourceRPCSubtype() {
    *this = ::std::move(from);
  }

  inline ResourceRPCSubtype& operator=(const ResourceRPCSubtype& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResourceRPCSubtype& operator=(ResourceRPCSubtype&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResourceRPCSubtype& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResourceRPCSubtype* internal_default_instance() {
    return reinterpret_cast<const ResourceRPCSubtype*>(
               &_ResourceRPCSubtype_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ResourceRPCSubtype& a, ResourceRPCSubtype& b) {
    a.Swap(&b);
  }
  inline void Swap(ResourceRPCSubtype* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResourceRPCSubtype* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResourceRPCSubtype* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResourceRPCSubtype>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResourceRPCSubtype& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResourceRPCSubtype& from) {
    ResourceRPCSubtype::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResourceRPCSubtype* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.robot.v1.ResourceRPCSubtype";
  }
  protected:
  explicit ResourceRPCSubtype(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProtoServiceFieldNumber = 2,
    kSubtypeFieldNumber = 1,
  };
  // string proto_service = 2 [json_name = "protoService"];
  void clear_proto_service();
  const std::string& proto_service() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_proto_service(ArgT0&& arg0, ArgT... args);
  std::string* mutable_proto_service();
  PROTOBUF_NODISCARD std::string* release_proto_service();
  void set_allocated_proto_service(std::string* proto_service);
  private:
  const std::string& _internal_proto_service() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_proto_service(const std::string& value);
  std::string* _internal_mutable_proto_service();
  public:

  // .viam.common.v1.ResourceName subtype = 1 [json_name = "subtype"];
  bool has_subtype() const;
  private:
  bool _internal_has_subtype() const;
  public:
  void clear_subtype();
  const ::viam::common::v1::ResourceName& subtype() const;
  PROTOBUF_NODISCARD ::viam::common::v1::ResourceName* release_subtype();
  ::viam::common::v1::ResourceName* mutable_subtype();
  void set_allocated_subtype(::viam::common::v1::ResourceName* subtype);
  private:
  const ::viam::common::v1::ResourceName& _internal_subtype() const;
  ::viam::common::v1::ResourceName* _internal_mutable_subtype();
  public:
  void unsafe_arena_set_allocated_subtype(
      ::viam::common::v1::ResourceName* subtype);
  ::viam::common::v1::ResourceName* unsafe_arena_release_subtype();

  // @@protoc_insertion_point(class_scope:viam.robot.v1.ResourceRPCSubtype)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr proto_service_;
    ::viam::common::v1::ResourceName* subtype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class ResourceRPCSubtypesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.robot.v1.ResourceRPCSubtypesRequest) */ {
 public:
  inline ResourceRPCSubtypesRequest() : ResourceRPCSubtypesRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ResourceRPCSubtypesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResourceRPCSubtypesRequest(const ResourceRPCSubtypesRequest& from);
  ResourceRPCSubtypesRequest(ResourceRPCSubtypesRequest&& from) noexcept
    : ResourceRPCSubtypesRequest() {
    *this = ::std::move(from);
  }

  inline ResourceRPCSubtypesRequest& operator=(const ResourceRPCSubtypesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResourceRPCSubtypesRequest& operator=(ResourceRPCSubtypesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResourceRPCSubtypesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResourceRPCSubtypesRequest* internal_default_instance() {
    return reinterpret_cast<const ResourceRPCSubtypesRequest*>(
               &_ResourceRPCSubtypesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ResourceRPCSubtypesRequest& a, ResourceRPCSubtypesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ResourceRPCSubtypesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResourceRPCSubtypesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResourceRPCSubtypesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResourceRPCSubtypesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ResourceRPCSubtypesRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ResourceRPCSubtypesRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.robot.v1.ResourceRPCSubtypesRequest";
  }
  protected:
  explicit ResourceRPCSubtypesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.robot.v1.ResourceRPCSubtypesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_robot_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class ResourceRPCSubtypesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.robot.v1.ResourceRPCSubtypesResponse) */ {
 public:
  inline ResourceRPCSubtypesResponse() : ResourceRPCSubtypesResponse(nullptr) {}
  ~ResourceRPCSubtypesResponse() override;
  explicit PROTOBUF_CONSTEXPR ResourceRPCSubtypesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResourceRPCSubtypesResponse(const ResourceRPCSubtypesResponse& from);
  ResourceRPCSubtypesResponse(ResourceRPCSubtypesResponse&& from) noexcept
    : ResourceRPCSubtypesResponse() {
    *this = ::std::move(from);
  }

  inline ResourceRPCSubtypesResponse& operator=(const ResourceRPCSubtypesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResourceRPCSubtypesResponse& operator=(ResourceRPCSubtypesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResourceRPCSubtypesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResourceRPCSubtypesResponse* internal_default_instance() {
    return reinterpret_cast<const ResourceRPCSubtypesResponse*>(
               &_ResourceRPCSubtypesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ResourceRPCSubtypesResponse& a, ResourceRPCSubtypesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ResourceRPCSubtypesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResourceRPCSubtypesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResourceRPCSubtypesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResourceRPCSubtypesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResourceRPCSubtypesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResourceRPCSubtypesResponse& from) {
    ResourceRPCSubtypesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResourceRPCSubtypesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.robot.v1.ResourceRPCSubtypesResponse";
  }
  protected:
  explicit ResourceRPCSubtypesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResourceRpcSubtypesFieldNumber = 1,
  };
  // repeated .viam.robot.v1.ResourceRPCSubtype resource_rpc_subtypes = 1 [json_name = "resourceRpcSubtypes"];
  int resource_rpc_subtypes_size() const;
  private:
  int _internal_resource_rpc_subtypes_size() const;
  public:
  void clear_resource_rpc_subtypes();
  ::viam::robot::v1::ResourceRPCSubtype* mutable_resource_rpc_subtypes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::robot::v1::ResourceRPCSubtype >*
      mutable_resource_rpc_subtypes();
  private:
  const ::viam::robot::v1::ResourceRPCSubtype& _internal_resource_rpc_subtypes(int index) const;
  ::viam::robot::v1::ResourceRPCSubtype* _internal_add_resource_rpc_subtypes();
  public:
  const ::viam::robot::v1::ResourceRPCSubtype& resource_rpc_subtypes(int index) const;
  ::viam::robot::v1::ResourceRPCSubtype* add_resource_rpc_subtypes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::robot::v1::ResourceRPCSubtype >&
      resource_rpc_subtypes() const;

  // @@protoc_insertion_point(class_scope:viam.robot.v1.ResourceRPCSubtypesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::robot::v1::ResourceRPCSubtype > resource_rpc_subtypes_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class Operation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.robot.v1.Operation) */ {
 public:
  inline Operation() : Operation(nullptr) {}
  ~Operation() override;
  explicit PROTOBUF_CONSTEXPR Operation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Operation(const Operation& from);
  Operation(Operation&& from) noexcept
    : Operation() {
    *this = ::std::move(from);
  }

  inline Operation& operator=(const Operation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Operation& operator=(Operation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Operation& default_instance() {
    return *internal_default_instance();
  }
  static inline const Operation* internal_default_instance() {
    return reinterpret_cast<const Operation*>(
               &_Operation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Operation& a, Operation& b) {
    a.Swap(&b);
  }
  inline void Swap(Operation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Operation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Operation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Operation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Operation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Operation& from) {
    Operation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Operation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.robot.v1.Operation";
  }
  protected:
  explicit Operation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kMethodFieldNumber = 2,
    kSessionIdFieldNumber = 5,
    kArgumentsFieldNumber = 3,
    kStartedFieldNumber = 4,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string method = 2 [json_name = "method"];
  void clear_method();
  const std::string& method() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_method(ArgT0&& arg0, ArgT... args);
  std::string* mutable_method();
  PROTOBUF_NODISCARD std::string* release_method();
  void set_allocated_method(std::string* method);
  private:
  const std::string& _internal_method() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_method(const std::string& value);
  std::string* _internal_mutable_method();
  public:

  // optional string session_id = 5 [json_name = "sessionId"];
  bool has_session_id() const;
  private:
  bool _internal_has_session_id() const;
  public:
  void clear_session_id();
  const std::string& session_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_session_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_session_id();
  PROTOBUF_NODISCARD std::string* release_session_id();
  void set_allocated_session_id(std::string* session_id);
  private:
  const std::string& _internal_session_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(const std::string& value);
  std::string* _internal_mutable_session_id();
  public:

  // .google.protobuf.Struct arguments = 3 [json_name = "arguments"];
  bool has_arguments() const;
  private:
  bool _internal_has_arguments() const;
  public:
  void clear_arguments();
  const ::PROTOBUF_NAMESPACE_ID::Struct& arguments() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_arguments();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_arguments();
  void set_allocated_arguments(::PROTOBUF_NAMESPACE_ID::Struct* arguments);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_arguments() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_arguments();
  public:
  void unsafe_arena_set_allocated_arguments(
      ::PROTOBUF_NAMESPACE_ID::Struct* arguments);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_arguments();

  // .google.protobuf.Timestamp started = 4 [json_name = "started"];
  bool has_started() const;
  private:
  bool _internal_has_started() const;
  public:
  void clear_started();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& started() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_started();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_started();
  void set_allocated_started(::PROTOBUF_NAMESPACE_ID::Timestamp* started);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_started() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_started();
  public:
  void unsafe_arena_set_allocated_started(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* started);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_started();

  // @@protoc_insertion_point(class_scope:viam.robot.v1.Operation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr method_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
    ::PROTOBUF_NAMESPACE_ID::Struct* arguments_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* started_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class GetOperationsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.robot.v1.GetOperationsRequest) */ {
 public:
  inline GetOperationsRequest() : GetOperationsRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GetOperationsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetOperationsRequest(const GetOperationsRequest& from);
  GetOperationsRequest(GetOperationsRequest&& from) noexcept
    : GetOperationsRequest() {
    *this = ::std::move(from);
  }

  inline GetOperationsRequest& operator=(const GetOperationsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetOperationsRequest& operator=(GetOperationsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetOperationsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetOperationsRequest* internal_default_instance() {
    return reinterpret_cast<const GetOperationsRequest*>(
               &_GetOperationsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(GetOperationsRequest& a, GetOperationsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetOperationsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetOperationsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetOperationsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetOperationsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetOperationsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetOperationsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.robot.v1.GetOperationsRequest";
  }
  protected:
  explicit GetOperationsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.robot.v1.GetOperationsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_robot_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class GetOperationsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.robot.v1.GetOperationsResponse) */ {
 public:
  inline GetOperationsResponse() : GetOperationsResponse(nullptr) {}
  ~GetOperationsResponse() override;
  explicit PROTOBUF_CONSTEXPR GetOperationsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetOperationsResponse(const GetOperationsResponse& from);
  GetOperationsResponse(GetOperationsResponse&& from) noexcept
    : GetOperationsResponse() {
    *this = ::std::move(from);
  }

  inline GetOperationsResponse& operator=(const GetOperationsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetOperationsResponse& operator=(GetOperationsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetOperationsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetOperationsResponse* internal_default_instance() {
    return reinterpret_cast<const GetOperationsResponse*>(
               &_GetOperationsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(GetOperationsResponse& a, GetOperationsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetOperationsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetOperationsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetOperationsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetOperationsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetOperationsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetOperationsResponse& from) {
    GetOperationsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetOperationsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.robot.v1.GetOperationsResponse";
  }
  protected:
  explicit GetOperationsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOperationsFieldNumber = 1,
  };
  // repeated .viam.robot.v1.Operation operations = 1 [json_name = "operations"];
  int operations_size() const;
  private:
  int _internal_operations_size() const;
  public:
  void clear_operations();
  ::viam::robot::v1::Operation* mutable_operations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::robot::v1::Operation >*
      mutable_operations();
  private:
  const ::viam::robot::v1::Operation& _internal_operations(int index) const;
  ::viam::robot::v1::Operation* _internal_add_operations();
  public:
  const ::viam::robot::v1::Operation& operations(int index) const;
  ::viam::robot::v1::Operation* add_operations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::robot::v1::Operation >&
      operations() const;

  // @@protoc_insertion_point(class_scope:viam.robot.v1.GetOperationsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::robot::v1::Operation > operations_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class CancelOperationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.robot.v1.CancelOperationRequest) */ {
 public:
  inline CancelOperationRequest() : CancelOperationRequest(nullptr) {}
  ~CancelOperationRequest() override;
  explicit PROTOBUF_CONSTEXPR CancelOperationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CancelOperationRequest(const CancelOperationRequest& from);
  CancelOperationRequest(CancelOperationRequest&& from) noexcept
    : CancelOperationRequest() {
    *this = ::std::move(from);
  }

  inline CancelOperationRequest& operator=(const CancelOperationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CancelOperationRequest& operator=(CancelOperationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CancelOperationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CancelOperationRequest* internal_default_instance() {
    return reinterpret_cast<const CancelOperationRequest*>(
               &_CancelOperationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(CancelOperationRequest& a, CancelOperationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CancelOperationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CancelOperationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CancelOperationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CancelOperationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CancelOperationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CancelOperationRequest& from) {
    CancelOperationRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CancelOperationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.robot.v1.CancelOperationRequest";
  }
  protected:
  explicit CancelOperationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.robot.v1.CancelOperationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class CancelOperationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.robot.v1.CancelOperationResponse) */ {
 public:
  inline CancelOperationResponse() : CancelOperationResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR CancelOperationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CancelOperationResponse(const CancelOperationResponse& from);
  CancelOperationResponse(CancelOperationResponse&& from) noexcept
    : CancelOperationResponse() {
    *this = ::std::move(from);
  }

  inline CancelOperationResponse& operator=(const CancelOperationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CancelOperationResponse& operator=(CancelOperationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CancelOperationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CancelOperationResponse* internal_default_instance() {
    return reinterpret_cast<const CancelOperationResponse*>(
               &_CancelOperationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(CancelOperationResponse& a, CancelOperationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CancelOperationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CancelOperationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CancelOperationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CancelOperationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CancelOperationResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CancelOperationResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.robot.v1.CancelOperationResponse";
  }
  protected:
  explicit CancelOperationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.robot.v1.CancelOperationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_robot_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class BlockForOperationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.robot.v1.BlockForOperationRequest) */ {
 public:
  inline BlockForOperationRequest() : BlockForOperationRequest(nullptr) {}
  ~BlockForOperationRequest() override;
  explicit PROTOBUF_CONSTEXPR BlockForOperationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockForOperationRequest(const BlockForOperationRequest& from);
  BlockForOperationRequest(BlockForOperationRequest&& from) noexcept
    : BlockForOperationRequest() {
    *this = ::std::move(from);
  }

  inline BlockForOperationRequest& operator=(const BlockForOperationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockForOperationRequest& operator=(BlockForOperationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockForOperationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockForOperationRequest* internal_default_instance() {
    return reinterpret_cast<const BlockForOperationRequest*>(
               &_BlockForOperationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(BlockForOperationRequest& a, BlockForOperationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockForOperationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockForOperationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockForOperationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlockForOperationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlockForOperationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BlockForOperationRequest& from) {
    BlockForOperationRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockForOperationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.robot.v1.BlockForOperationRequest";
  }
  protected:
  explicit BlockForOperationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.robot.v1.BlockForOperationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class BlockForOperationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.robot.v1.BlockForOperationResponse) */ {
 public:
  inline BlockForOperationResponse() : BlockForOperationResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR BlockForOperationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockForOperationResponse(const BlockForOperationResponse& from);
  BlockForOperationResponse(BlockForOperationResponse&& from) noexcept
    : BlockForOperationResponse() {
    *this = ::std::move(from);
  }

  inline BlockForOperationResponse& operator=(const BlockForOperationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockForOperationResponse& operator=(BlockForOperationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockForOperationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockForOperationResponse* internal_default_instance() {
    return reinterpret_cast<const BlockForOperationResponse*>(
               &_BlockForOperationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(BlockForOperationResponse& a, BlockForOperationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockForOperationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockForOperationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockForOperationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlockForOperationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const BlockForOperationResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const BlockForOperationResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.robot.v1.BlockForOperationResponse";
  }
  protected:
  explicit BlockForOperationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.robot.v1.BlockForOperationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_robot_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class PeerConnectionInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.robot.v1.PeerConnectionInfo) */ {
 public:
  inline PeerConnectionInfo() : PeerConnectionInfo(nullptr) {}
  ~PeerConnectionInfo() override;
  explicit PROTOBUF_CONSTEXPR PeerConnectionInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PeerConnectionInfo(const PeerConnectionInfo& from);
  PeerConnectionInfo(PeerConnectionInfo&& from) noexcept
    : PeerConnectionInfo() {
    *this = ::std::move(from);
  }

  inline PeerConnectionInfo& operator=(const PeerConnectionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PeerConnectionInfo& operator=(PeerConnectionInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PeerConnectionInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const PeerConnectionInfo* internal_default_instance() {
    return reinterpret_cast<const PeerConnectionInfo*>(
               &_PeerConnectionInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(PeerConnectionInfo& a, PeerConnectionInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(PeerConnectionInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PeerConnectionInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PeerConnectionInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PeerConnectionInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PeerConnectionInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PeerConnectionInfo& from) {
    PeerConnectionInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PeerConnectionInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.robot.v1.PeerConnectionInfo";
  }
  protected:
  explicit PeerConnectionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRemoteAddressFieldNumber = 2,
    kLocalAddressFieldNumber = 3,
    kTypeFieldNumber = 1,
  };
  // optional string remote_address = 2 [json_name = "remoteAddress"];
  bool has_remote_address() const;
  private:
  bool _internal_has_remote_address() const;
  public:
  void clear_remote_address();
  const std::string& remote_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_remote_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_remote_address();
  PROTOBUF_NODISCARD std::string* release_remote_address();
  void set_allocated_remote_address(std::string* remote_address);
  private:
  const std::string& _internal_remote_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_remote_address(const std::string& value);
  std::string* _internal_mutable_remote_address();
  public:

  // optional string local_address = 3 [json_name = "localAddress"];
  bool has_local_address() const;
  private:
  bool _internal_has_local_address() const;
  public:
  void clear_local_address();
  const std::string& local_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_local_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_local_address();
  PROTOBUF_NODISCARD std::string* release_local_address();
  void set_allocated_local_address(std::string* local_address);
  private:
  const std::string& _internal_local_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_local_address(const std::string& value);
  std::string* _internal_mutable_local_address();
  public:

  // .viam.robot.v1.PeerConnectionType type = 1 [json_name = "type"];
  void clear_type();
  ::viam::robot::v1::PeerConnectionType type() const;
  void set_type(::viam::robot::v1::PeerConnectionType value);
  private:
  ::viam::robot::v1::PeerConnectionType _internal_type() const;
  void _internal_set_type(::viam::robot::v1::PeerConnectionType value);
  public:

  // @@protoc_insertion_point(class_scope:viam.robot.v1.PeerConnectionInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr remote_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr local_address_;
    int type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class Session final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.robot.v1.Session) */ {
 public:
  inline Session() : Session(nullptr) {}
  ~Session() override;
  explicit PROTOBUF_CONSTEXPR Session(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Session(const Session& from);
  Session(Session&& from) noexcept
    : Session() {
    *this = ::std::move(from);
  }

  inline Session& operator=(const Session& from) {
    CopyFrom(from);
    return *this;
  }
  inline Session& operator=(Session&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Session& default_instance() {
    return *internal_default_instance();
  }
  static inline const Session* internal_default_instance() {
    return reinterpret_cast<const Session*>(
               &_Session_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(Session& a, Session& b) {
    a.Swap(&b);
  }
  inline void Swap(Session* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Session* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Session* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Session>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Session& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Session& from) {
    Session::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Session* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.robot.v1.Session";
  }
  protected:
  explicit Session(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kPeerConnectionInfoFieldNumber = 2,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // optional .viam.robot.v1.PeerConnectionInfo peer_connection_info = 2 [json_name = "peerConnectionInfo"];
  bool has_peer_connection_info() const;
  private:
  bool _internal_has_peer_connection_info() const;
  public:
  void clear_peer_connection_info();
  const ::viam::robot::v1::PeerConnectionInfo& peer_connection_info() const;
  PROTOBUF_NODISCARD ::viam::robot::v1::PeerConnectionInfo* release_peer_connection_info();
  ::viam::robot::v1::PeerConnectionInfo* mutable_peer_connection_info();
  void set_allocated_peer_connection_info(::viam::robot::v1::PeerConnectionInfo* peer_connection_info);
  private:
  const ::viam::robot::v1::PeerConnectionInfo& _internal_peer_connection_info() const;
  ::viam::robot::v1::PeerConnectionInfo* _internal_mutable_peer_connection_info();
  public:
  void unsafe_arena_set_allocated_peer_connection_info(
      ::viam::robot::v1::PeerConnectionInfo* peer_connection_info);
  ::viam::robot::v1::PeerConnectionInfo* unsafe_arena_release_peer_connection_info();

  // @@protoc_insertion_point(class_scope:viam.robot.v1.Session)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::viam::robot::v1::PeerConnectionInfo* peer_connection_info_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class GetSessionsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.robot.v1.GetSessionsRequest) */ {
 public:
  inline GetSessionsRequest() : GetSessionsRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GetSessionsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetSessionsRequest(const GetSessionsRequest& from);
  GetSessionsRequest(GetSessionsRequest&& from) noexcept
    : GetSessionsRequest() {
    *this = ::std::move(from);
  }

  inline GetSessionsRequest& operator=(const GetSessionsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSessionsRequest& operator=(GetSessionsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSessionsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSessionsRequest* internal_default_instance() {
    return reinterpret_cast<const GetSessionsRequest*>(
               &_GetSessionsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(GetSessionsRequest& a, GetSessionsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSessionsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSessionsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSessionsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetSessionsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetSessionsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetSessionsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.robot.v1.GetSessionsRequest";
  }
  protected:
  explicit GetSessionsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.robot.v1.GetSessionsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_robot_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class GetSessionsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.robot.v1.GetSessionsResponse) */ {
 public:
  inline GetSessionsResponse() : GetSessionsResponse(nullptr) {}
  ~GetSessionsResponse() override;
  explicit PROTOBUF_CONSTEXPR GetSessionsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetSessionsResponse(const GetSessionsResponse& from);
  GetSessionsResponse(GetSessionsResponse&& from) noexcept
    : GetSessionsResponse() {
    *this = ::std::move(from);
  }

  inline GetSessionsResponse& operator=(const GetSessionsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSessionsResponse& operator=(GetSessionsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSessionsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSessionsResponse* internal_default_instance() {
    return reinterpret_cast<const GetSessionsResponse*>(
               &_GetSessionsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(GetSessionsResponse& a, GetSessionsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSessionsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSessionsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSessionsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetSessionsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetSessionsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetSessionsResponse& from) {
    GetSessionsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSessionsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.robot.v1.GetSessionsResponse";
  }
  protected:
  explicit GetSessionsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionsFieldNumber = 1,
  };
  // repeated .viam.robot.v1.Session sessions = 1 [json_name = "sessions"];
  int sessions_size() const;
  private:
  int _internal_sessions_size() const;
  public:
  void clear_sessions();
  ::viam::robot::v1::Session* mutable_sessions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::robot::v1::Session >*
      mutable_sessions();
  private:
  const ::viam::robot::v1::Session& _internal_sessions(int index) const;
  ::viam::robot::v1::Session* _internal_add_sessions();
  public:
  const ::viam::robot::v1::Session& sessions(int index) const;
  ::viam::robot::v1::Session* add_sessions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::robot::v1::Session >&
      sessions() const;

  // @@protoc_insertion_point(class_scope:viam.robot.v1.GetSessionsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::robot::v1::Session > sessions_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class DiscoveryQuery final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.robot.v1.DiscoveryQuery) */ {
 public:
  inline DiscoveryQuery() : DiscoveryQuery(nullptr) {}
  ~DiscoveryQuery() override;
  explicit PROTOBUF_CONSTEXPR DiscoveryQuery(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DiscoveryQuery(const DiscoveryQuery& from);
  DiscoveryQuery(DiscoveryQuery&& from) noexcept
    : DiscoveryQuery() {
    *this = ::std::move(from);
  }

  inline DiscoveryQuery& operator=(const DiscoveryQuery& from) {
    CopyFrom(from);
    return *this;
  }
  inline DiscoveryQuery& operator=(DiscoveryQuery&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DiscoveryQuery& default_instance() {
    return *internal_default_instance();
  }
  static inline const DiscoveryQuery* internal_default_instance() {
    return reinterpret_cast<const DiscoveryQuery*>(
               &_DiscoveryQuery_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(DiscoveryQuery& a, DiscoveryQuery& b) {
    a.Swap(&b);
  }
  inline void Swap(DiscoveryQuery* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DiscoveryQuery* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DiscoveryQuery* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DiscoveryQuery>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DiscoveryQuery& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DiscoveryQuery& from) {
    DiscoveryQuery::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DiscoveryQuery* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.robot.v1.DiscoveryQuery";
  }
  protected:
  explicit DiscoveryQuery(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubtypeFieldNumber = 1,
    kModelFieldNumber = 2,
  };
  // string subtype = 1 [json_name = "subtype"];
  void clear_subtype();
  const std::string& subtype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_subtype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_subtype();
  PROTOBUF_NODISCARD std::string* release_subtype();
  void set_allocated_subtype(std::string* subtype);
  private:
  const std::string& _internal_subtype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subtype(const std::string& value);
  std::string* _internal_mutable_subtype();
  public:

  // string model = 2 [json_name = "model"];
  void clear_model();
  const std::string& model() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model();
  PROTOBUF_NODISCARD std::string* release_model();
  void set_allocated_model(std::string* model);
  private:
  const std::string& _internal_model() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model(const std::string& value);
  std::string* _internal_mutable_model();
  public:

  // @@protoc_insertion_point(class_scope:viam.robot.v1.DiscoveryQuery)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subtype_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class Discovery final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.robot.v1.Discovery) */ {
 public:
  inline Discovery() : Discovery(nullptr) {}
  ~Discovery() override;
  explicit PROTOBUF_CONSTEXPR Discovery(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Discovery(const Discovery& from);
  Discovery(Discovery&& from) noexcept
    : Discovery() {
    *this = ::std::move(from);
  }

  inline Discovery& operator=(const Discovery& from) {
    CopyFrom(from);
    return *this;
  }
  inline Discovery& operator=(Discovery&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Discovery& default_instance() {
    return *internal_default_instance();
  }
  static inline const Discovery* internal_default_instance() {
    return reinterpret_cast<const Discovery*>(
               &_Discovery_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(Discovery& a, Discovery& b) {
    a.Swap(&b);
  }
  inline void Swap(Discovery* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Discovery* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Discovery* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Discovery>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Discovery& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Discovery& from) {
    Discovery::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Discovery* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.robot.v1.Discovery";
  }
  protected:
  explicit Discovery(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQueryFieldNumber = 1,
    kResultsFieldNumber = 2,
  };
  // .viam.robot.v1.DiscoveryQuery query = 1 [json_name = "query"];
  bool has_query() const;
  private:
  bool _internal_has_query() const;
  public:
  void clear_query();
  const ::viam::robot::v1::DiscoveryQuery& query() const;
  PROTOBUF_NODISCARD ::viam::robot::v1::DiscoveryQuery* release_query();
  ::viam::robot::v1::DiscoveryQuery* mutable_query();
  void set_allocated_query(::viam::robot::v1::DiscoveryQuery* query);
  private:
  const ::viam::robot::v1::DiscoveryQuery& _internal_query() const;
  ::viam::robot::v1::DiscoveryQuery* _internal_mutable_query();
  public:
  void unsafe_arena_set_allocated_query(
      ::viam::robot::v1::DiscoveryQuery* query);
  ::viam::robot::v1::DiscoveryQuery* unsafe_arena_release_query();

  // .google.protobuf.Struct results = 2 [json_name = "results"];
  bool has_results() const;
  private:
  bool _internal_has_results() const;
  public:
  void clear_results();
  const ::PROTOBUF_NAMESPACE_ID::Struct& results() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_results();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_results();
  void set_allocated_results(::PROTOBUF_NAMESPACE_ID::Struct* results);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_results() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_results();
  public:
  void unsafe_arena_set_allocated_results(
      ::PROTOBUF_NAMESPACE_ID::Struct* results);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_results();

  // @@protoc_insertion_point(class_scope:viam.robot.v1.Discovery)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::viam::robot::v1::DiscoveryQuery* query_;
    ::PROTOBUF_NAMESPACE_ID::Struct* results_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class DiscoverComponentsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.robot.v1.DiscoverComponentsRequest) */ {
 public:
  inline DiscoverComponentsRequest() : DiscoverComponentsRequest(nullptr) {}
  ~DiscoverComponentsRequest() override;
  explicit PROTOBUF_CONSTEXPR DiscoverComponentsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DiscoverComponentsRequest(const DiscoverComponentsRequest& from);
  DiscoverComponentsRequest(DiscoverComponentsRequest&& from) noexcept
    : DiscoverComponentsRequest() {
    *this = ::std::move(from);
  }

  inline DiscoverComponentsRequest& operator=(const DiscoverComponentsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DiscoverComponentsRequest& operator=(DiscoverComponentsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DiscoverComponentsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DiscoverComponentsRequest* internal_default_instance() {
    return reinterpret_cast<const DiscoverComponentsRequest*>(
               &_DiscoverComponentsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(DiscoverComponentsRequest& a, DiscoverComponentsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DiscoverComponentsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DiscoverComponentsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DiscoverComponentsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DiscoverComponentsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DiscoverComponentsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DiscoverComponentsRequest& from) {
    DiscoverComponentsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DiscoverComponentsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.robot.v1.DiscoverComponentsRequest";
  }
  protected:
  explicit DiscoverComponentsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQueriesFieldNumber = 1,
  };
  // repeated .viam.robot.v1.DiscoveryQuery queries = 1 [json_name = "queries"];
  int queries_size() const;
  private:
  int _internal_queries_size() const;
  public:
  void clear_queries();
  ::viam::robot::v1::DiscoveryQuery* mutable_queries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::robot::v1::DiscoveryQuery >*
      mutable_queries();
  private:
  const ::viam::robot::v1::DiscoveryQuery& _internal_queries(int index) const;
  ::viam::robot::v1::DiscoveryQuery* _internal_add_queries();
  public:
  const ::viam::robot::v1::DiscoveryQuery& queries(int index) const;
  ::viam::robot::v1::DiscoveryQuery* add_queries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::robot::v1::DiscoveryQuery >&
      queries() const;

  // @@protoc_insertion_point(class_scope:viam.robot.v1.DiscoverComponentsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::robot::v1::DiscoveryQuery > queries_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class DiscoverComponentsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.robot.v1.DiscoverComponentsResponse) */ {
 public:
  inline DiscoverComponentsResponse() : DiscoverComponentsResponse(nullptr) {}
  ~DiscoverComponentsResponse() override;
  explicit PROTOBUF_CONSTEXPR DiscoverComponentsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DiscoverComponentsResponse(const DiscoverComponentsResponse& from);
  DiscoverComponentsResponse(DiscoverComponentsResponse&& from) noexcept
    : DiscoverComponentsResponse() {
    *this = ::std::move(from);
  }

  inline DiscoverComponentsResponse& operator=(const DiscoverComponentsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DiscoverComponentsResponse& operator=(DiscoverComponentsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DiscoverComponentsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DiscoverComponentsResponse* internal_default_instance() {
    return reinterpret_cast<const DiscoverComponentsResponse*>(
               &_DiscoverComponentsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(DiscoverComponentsResponse& a, DiscoverComponentsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DiscoverComponentsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DiscoverComponentsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DiscoverComponentsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DiscoverComponentsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DiscoverComponentsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DiscoverComponentsResponse& from) {
    DiscoverComponentsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DiscoverComponentsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.robot.v1.DiscoverComponentsResponse";
  }
  protected:
  explicit DiscoverComponentsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDiscoveryFieldNumber = 1,
  };
  // repeated .viam.robot.v1.Discovery discovery = 1 [json_name = "discovery"];
  int discovery_size() const;
  private:
  int _internal_discovery_size() const;
  public:
  void clear_discovery();
  ::viam::robot::v1::Discovery* mutable_discovery(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::robot::v1::Discovery >*
      mutable_discovery();
  private:
  const ::viam::robot::v1::Discovery& _internal_discovery(int index) const;
  ::viam::robot::v1::Discovery* _internal_add_discovery();
  public:
  const ::viam::robot::v1::Discovery& discovery(int index) const;
  ::viam::robot::v1::Discovery* add_discovery();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::robot::v1::Discovery >&
      discovery() const;

  // @@protoc_insertion_point(class_scope:viam.robot.v1.DiscoverComponentsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::robot::v1::Discovery > discovery_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class Status final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.robot.v1.Status) */ {
 public:
  inline Status() : Status(nullptr) {}
  ~Status() override;
  explicit PROTOBUF_CONSTEXPR Status(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Status(const Status& from);
  Status(Status&& from) noexcept
    : Status() {
    *this = ::std::move(from);
  }

  inline Status& operator=(const Status& from) {
    CopyFrom(from);
    return *this;
  }
  inline Status& operator=(Status&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Status& default_instance() {
    return *internal_default_instance();
  }
  static inline const Status* internal_default_instance() {
    return reinterpret_cast<const Status*>(
               &_Status_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(Status& a, Status& b) {
    a.Swap(&b);
  }
  inline void Swap(Status* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Status* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Status* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Status>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Status& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Status& from) {
    Status::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Status* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.robot.v1.Status";
  }
  protected:
  explicit Status(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // .viam.common.v1.ResourceName name = 1 [json_name = "name"];
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const ::viam::common::v1::ResourceName& name() const;
  PROTOBUF_NODISCARD ::viam::common::v1::ResourceName* release_name();
  ::viam::common::v1::ResourceName* mutable_name();
  void set_allocated_name(::viam::common::v1::ResourceName* name);
  private:
  const ::viam::common::v1::ResourceName& _internal_name() const;
  ::viam::common::v1::ResourceName* _internal_mutable_name();
  public:
  void unsafe_arena_set_allocated_name(
      ::viam::common::v1::ResourceName* name);
  ::viam::common::v1::ResourceName* unsafe_arena_release_name();

  // .google.protobuf.Struct status = 2 [json_name = "status"];
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::PROTOBUF_NAMESPACE_ID::Struct& status() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_status();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_status();
  void set_allocated_status(::PROTOBUF_NAMESPACE_ID::Struct* status);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_status() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::PROTOBUF_NAMESPACE_ID::Struct* status);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:viam.robot.v1.Status)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::viam::common::v1::ResourceName* name_;
    ::PROTOBUF_NAMESPACE_ID::Struct* status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class GetStatusRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.robot.v1.GetStatusRequest) */ {
 public:
  inline GetStatusRequest() : GetStatusRequest(nullptr) {}
  ~GetStatusRequest() override;
  explicit PROTOBUF_CONSTEXPR GetStatusRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetStatusRequest(const GetStatusRequest& from);
  GetStatusRequest(GetStatusRequest&& from) noexcept
    : GetStatusRequest() {
    *this = ::std::move(from);
  }

  inline GetStatusRequest& operator=(const GetStatusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetStatusRequest& operator=(GetStatusRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetStatusRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetStatusRequest* internal_default_instance() {
    return reinterpret_cast<const GetStatusRequest*>(
               &_GetStatusRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(GetStatusRequest& a, GetStatusRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetStatusRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetStatusRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetStatusRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetStatusRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetStatusRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetStatusRequest& from) {
    GetStatusRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetStatusRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.robot.v1.GetStatusRequest";
  }
  protected:
  explicit GetStatusRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResourceNamesFieldNumber = 1,
  };
  // repeated .viam.common.v1.ResourceName resource_names = 1 [json_name = "resourceNames"];
  int resource_names_size() const;
  private:
  int _internal_resource_names_size() const;
  public:
  void clear_resource_names();
  ::viam::common::v1::ResourceName* mutable_resource_names(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::common::v1::ResourceName >*
      mutable_resource_names();
  private:
  const ::viam::common::v1::ResourceName& _internal_resource_names(int index) const;
  ::viam::common::v1::ResourceName* _internal_add_resource_names();
  public:
  const ::viam::common::v1::ResourceName& resource_names(int index) const;
  ::viam::common::v1::ResourceName* add_resource_names();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::common::v1::ResourceName >&
      resource_names() const;

  // @@protoc_insertion_point(class_scope:viam.robot.v1.GetStatusRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::common::v1::ResourceName > resource_names_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class GetStatusResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.robot.v1.GetStatusResponse) */ {
 public:
  inline GetStatusResponse() : GetStatusResponse(nullptr) {}
  ~GetStatusResponse() override;
  explicit PROTOBUF_CONSTEXPR GetStatusResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetStatusResponse(const GetStatusResponse& from);
  GetStatusResponse(GetStatusResponse&& from) noexcept
    : GetStatusResponse() {
    *this = ::std::move(from);
  }

  inline GetStatusResponse& operator=(const GetStatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetStatusResponse& operator=(GetStatusResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetStatusResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetStatusResponse* internal_default_instance() {
    return reinterpret_cast<const GetStatusResponse*>(
               &_GetStatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(GetStatusResponse& a, GetStatusResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetStatusResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetStatusResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetStatusResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetStatusResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetStatusResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetStatusResponse& from) {
    GetStatusResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetStatusResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.robot.v1.GetStatusResponse";
  }
  protected:
  explicit GetStatusResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // repeated .viam.robot.v1.Status status = 1 [json_name = "status"];
  int status_size() const;
  private:
  int _internal_status_size() const;
  public:
  void clear_status();
  ::viam::robot::v1::Status* mutable_status(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::robot::v1::Status >*
      mutable_status();
  private:
  const ::viam::robot::v1::Status& _internal_status(int index) const;
  ::viam::robot::v1::Status* _internal_add_status();
  public:
  const ::viam::robot::v1::Status& status(int index) const;
  ::viam::robot::v1::Status* add_status();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::robot::v1::Status >&
      status() const;

  // @@protoc_insertion_point(class_scope:viam.robot.v1.GetStatusResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::robot::v1::Status > status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class StreamStatusRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.robot.v1.StreamStatusRequest) */ {
 public:
  inline StreamStatusRequest() : StreamStatusRequest(nullptr) {}
  ~StreamStatusRequest() override;
  explicit PROTOBUF_CONSTEXPR StreamStatusRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamStatusRequest(const StreamStatusRequest& from);
  StreamStatusRequest(StreamStatusRequest&& from) noexcept
    : StreamStatusRequest() {
    *this = ::std::move(from);
  }

  inline StreamStatusRequest& operator=(const StreamStatusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamStatusRequest& operator=(StreamStatusRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamStatusRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamStatusRequest* internal_default_instance() {
    return reinterpret_cast<const StreamStatusRequest*>(
               &_StreamStatusRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(StreamStatusRequest& a, StreamStatusRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamStatusRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamStatusRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamStatusRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamStatusRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamStatusRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamStatusRequest& from) {
    StreamStatusRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamStatusRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.robot.v1.StreamStatusRequest";
  }
  protected:
  explicit StreamStatusRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResourceNamesFieldNumber = 1,
    kEveryFieldNumber = 2,
  };
  // repeated .viam.common.v1.ResourceName resource_names = 1 [json_name = "resourceNames"];
  int resource_names_size() const;
  private:
  int _internal_resource_names_size() const;
  public:
  void clear_resource_names();
  ::viam::common::v1::ResourceName* mutable_resource_names(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::common::v1::ResourceName >*
      mutable_resource_names();
  private:
  const ::viam::common::v1::ResourceName& _internal_resource_names(int index) const;
  ::viam::common::v1::ResourceName* _internal_add_resource_names();
  public:
  const ::viam::common::v1::ResourceName& resource_names(int index) const;
  ::viam::common::v1::ResourceName* add_resource_names();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::common::v1::ResourceName >&
      resource_names() const;

  // .google.protobuf.Duration every = 2 [json_name = "every"];
  bool has_every() const;
  private:
  bool _internal_has_every() const;
  public:
  void clear_every();
  const ::PROTOBUF_NAMESPACE_ID::Duration& every() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_every();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_every();
  void set_allocated_every(::PROTOBUF_NAMESPACE_ID::Duration* every);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_every() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_every();
  public:
  void unsafe_arena_set_allocated_every(
      ::PROTOBUF_NAMESPACE_ID::Duration* every);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_every();

  // @@protoc_insertion_point(class_scope:viam.robot.v1.StreamStatusRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::common::v1::ResourceName > resource_names_;
    ::PROTOBUF_NAMESPACE_ID::Duration* every_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class StreamStatusResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.robot.v1.StreamStatusResponse) */ {
 public:
  inline StreamStatusResponse() : StreamStatusResponse(nullptr) {}
  ~StreamStatusResponse() override;
  explicit PROTOBUF_CONSTEXPR StreamStatusResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamStatusResponse(const StreamStatusResponse& from);
  StreamStatusResponse(StreamStatusResponse&& from) noexcept
    : StreamStatusResponse() {
    *this = ::std::move(from);
  }

  inline StreamStatusResponse& operator=(const StreamStatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamStatusResponse& operator=(StreamStatusResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamStatusResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamStatusResponse* internal_default_instance() {
    return reinterpret_cast<const StreamStatusResponse*>(
               &_StreamStatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(StreamStatusResponse& a, StreamStatusResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamStatusResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamStatusResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamStatusResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamStatusResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamStatusResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamStatusResponse& from) {
    StreamStatusResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamStatusResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.robot.v1.StreamStatusResponse";
  }
  protected:
  explicit StreamStatusResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // repeated .viam.robot.v1.Status status = 1 [json_name = "status"];
  int status_size() const;
  private:
  int _internal_status_size() const;
  public:
  void clear_status();
  ::viam::robot::v1::Status* mutable_status(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::robot::v1::Status >*
      mutable_status();
  private:
  const ::viam::robot::v1::Status& _internal_status(int index) const;
  ::viam::robot::v1::Status* _internal_add_status();
  public:
  const ::viam::robot::v1::Status& status(int index) const;
  ::viam::robot::v1::Status* add_status();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::robot::v1::Status >&
      status() const;

  // @@protoc_insertion_point(class_scope:viam.robot.v1.StreamStatusResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::robot::v1::Status > status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class StopExtraParameters final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.robot.v1.StopExtraParameters) */ {
 public:
  inline StopExtraParameters() : StopExtraParameters(nullptr) {}
  ~StopExtraParameters() override;
  explicit PROTOBUF_CONSTEXPR StopExtraParameters(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StopExtraParameters(const StopExtraParameters& from);
  StopExtraParameters(StopExtraParameters&& from) noexcept
    : StopExtraParameters() {
    *this = ::std::move(from);
  }

  inline StopExtraParameters& operator=(const StopExtraParameters& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopExtraParameters& operator=(StopExtraParameters&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StopExtraParameters& default_instance() {
    return *internal_default_instance();
  }
  static inline const StopExtraParameters* internal_default_instance() {
    return reinterpret_cast<const StopExtraParameters*>(
               &_StopExtraParameters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(StopExtraParameters& a, StopExtraParameters& b) {
    a.Swap(&b);
  }
  inline void Swap(StopExtraParameters* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StopExtraParameters* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StopExtraParameters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StopExtraParameters>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StopExtraParameters& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StopExtraParameters& from) {
    StopExtraParameters::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StopExtraParameters* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.robot.v1.StopExtraParameters";
  }
  protected:
  explicit StopExtraParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kParamsFieldNumber = 2,
  };
  // .viam.common.v1.ResourceName name = 1 [json_name = "name"];
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const ::viam::common::v1::ResourceName& name() const;
  PROTOBUF_NODISCARD ::viam::common::v1::ResourceName* release_name();
  ::viam::common::v1::ResourceName* mutable_name();
  void set_allocated_name(::viam::common::v1::ResourceName* name);
  private:
  const ::viam::common::v1::ResourceName& _internal_name() const;
  ::viam::common::v1::ResourceName* _internal_mutable_name();
  public:
  void unsafe_arena_set_allocated_name(
      ::viam::common::v1::ResourceName* name);
  ::viam::common::v1::ResourceName* unsafe_arena_release_name();

  // .google.protobuf.Struct params = 2 [json_name = "params"];
  bool has_params() const;
  private:
  bool _internal_has_params() const;
  public:
  void clear_params();
  const ::PROTOBUF_NAMESPACE_ID::Struct& params() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_params();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_params();
  void set_allocated_params(::PROTOBUF_NAMESPACE_ID::Struct* params);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_params() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_params();
  public:
  void unsafe_arena_set_allocated_params(
      ::PROTOBUF_NAMESPACE_ID::Struct* params);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_params();

  // @@protoc_insertion_point(class_scope:viam.robot.v1.StopExtraParameters)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::viam::common::v1::ResourceName* name_;
    ::PROTOBUF_NAMESPACE_ID::Struct* params_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class StopAllRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.robot.v1.StopAllRequest) */ {
 public:
  inline StopAllRequest() : StopAllRequest(nullptr) {}
  ~StopAllRequest() override;
  explicit PROTOBUF_CONSTEXPR StopAllRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StopAllRequest(const StopAllRequest& from);
  StopAllRequest(StopAllRequest&& from) noexcept
    : StopAllRequest() {
    *this = ::std::move(from);
  }

  inline StopAllRequest& operator=(const StopAllRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopAllRequest& operator=(StopAllRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StopAllRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StopAllRequest* internal_default_instance() {
    return reinterpret_cast<const StopAllRequest*>(
               &_StopAllRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(StopAllRequest& a, StopAllRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StopAllRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StopAllRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StopAllRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StopAllRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StopAllRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StopAllRequest& from) {
    StopAllRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StopAllRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.robot.v1.StopAllRequest";
  }
  protected:
  explicit StopAllRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExtraFieldNumber = 99,
  };
  // repeated .viam.robot.v1.StopExtraParameters extra = 99 [json_name = "extra"];
  int extra_size() const;
  private:
  int _internal_extra_size() const;
  public:
  void clear_extra();
  ::viam::robot::v1::StopExtraParameters* mutable_extra(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::robot::v1::StopExtraParameters >*
      mutable_extra();
  private:
  const ::viam::robot::v1::StopExtraParameters& _internal_extra(int index) const;
  ::viam::robot::v1::StopExtraParameters* _internal_add_extra();
  public:
  const ::viam::robot::v1::StopExtraParameters& extra(int index) const;
  ::viam::robot::v1::StopExtraParameters* add_extra();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::robot::v1::StopExtraParameters >&
      extra() const;

  // @@protoc_insertion_point(class_scope:viam.robot.v1.StopAllRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::robot::v1::StopExtraParameters > extra_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class StopAllResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.robot.v1.StopAllResponse) */ {
 public:
  inline StopAllResponse() : StopAllResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR StopAllResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StopAllResponse(const StopAllResponse& from);
  StopAllResponse(StopAllResponse&& from) noexcept
    : StopAllResponse() {
    *this = ::std::move(from);
  }

  inline StopAllResponse& operator=(const StopAllResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopAllResponse& operator=(StopAllResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StopAllResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StopAllResponse* internal_default_instance() {
    return reinterpret_cast<const StopAllResponse*>(
               &_StopAllResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(StopAllResponse& a, StopAllResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StopAllResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StopAllResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StopAllResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StopAllResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const StopAllResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const StopAllResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.robot.v1.StopAllResponse";
  }
  protected:
  explicit StopAllResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.robot.v1.StopAllResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_robot_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class StartSessionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.robot.v1.StartSessionRequest) */ {
 public:
  inline StartSessionRequest() : StartSessionRequest(nullptr) {}
  ~StartSessionRequest() override;
  explicit PROTOBUF_CONSTEXPR StartSessionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StartSessionRequest(const StartSessionRequest& from);
  StartSessionRequest(StartSessionRequest&& from) noexcept
    : StartSessionRequest() {
    *this = ::std::move(from);
  }

  inline StartSessionRequest& operator=(const StartSessionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartSessionRequest& operator=(StartSessionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StartSessionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StartSessionRequest* internal_default_instance() {
    return reinterpret_cast<const StartSessionRequest*>(
               &_StartSessionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(StartSessionRequest& a, StartSessionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StartSessionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StartSessionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StartSessionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StartSessionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StartSessionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StartSessionRequest& from) {
    StartSessionRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StartSessionRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.robot.v1.StartSessionRequest";
  }
  protected:
  explicit StartSessionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResumeFieldNumber = 1,
  };
  // string resume = 1 [json_name = "resume"];
  void clear_resume();
  const std::string& resume() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resume(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resume();
  PROTOBUF_NODISCARD std::string* release_resume();
  void set_allocated_resume(std::string* resume);
  private:
  const std::string& _internal_resume() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resume(const std::string& value);
  std::string* _internal_mutable_resume();
  public:

  // @@protoc_insertion_point(class_scope:viam.robot.v1.StartSessionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resume_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class StartSessionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.robot.v1.StartSessionResponse) */ {
 public:
  inline StartSessionResponse() : StartSessionResponse(nullptr) {}
  ~StartSessionResponse() override;
  explicit PROTOBUF_CONSTEXPR StartSessionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StartSessionResponse(const StartSessionResponse& from);
  StartSessionResponse(StartSessionResponse&& from) noexcept
    : StartSessionResponse() {
    *this = ::std::move(from);
  }

  inline StartSessionResponse& operator=(const StartSessionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartSessionResponse& operator=(StartSessionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StartSessionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StartSessionResponse* internal_default_instance() {
    return reinterpret_cast<const StartSessionResponse*>(
               &_StartSessionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(StartSessionResponse& a, StartSessionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StartSessionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StartSessionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StartSessionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StartSessionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StartSessionResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StartSessionResponse& from) {
    StartSessionResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StartSessionResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.robot.v1.StartSessionResponse";
  }
  protected:
  explicit StartSessionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kHeartbeatWindowFieldNumber = 2,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .google.protobuf.Duration heartbeat_window = 2 [json_name = "heartbeatWindow"];
  bool has_heartbeat_window() const;
  private:
  bool _internal_has_heartbeat_window() const;
  public:
  void clear_heartbeat_window();
  const ::PROTOBUF_NAMESPACE_ID::Duration& heartbeat_window() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_heartbeat_window();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_heartbeat_window();
  void set_allocated_heartbeat_window(::PROTOBUF_NAMESPACE_ID::Duration* heartbeat_window);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_heartbeat_window() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_heartbeat_window();
  public:
  void unsafe_arena_set_allocated_heartbeat_window(
      ::PROTOBUF_NAMESPACE_ID::Duration* heartbeat_window);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_heartbeat_window();

  // @@protoc_insertion_point(class_scope:viam.robot.v1.StartSessionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::Duration* heartbeat_window_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class SendSessionHeartbeatRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:viam.robot.v1.SendSessionHeartbeatRequest) */ {
 public:
  inline SendSessionHeartbeatRequest() : SendSessionHeartbeatRequest(nullptr) {}
  ~SendSessionHeartbeatRequest() override;
  explicit PROTOBUF_CONSTEXPR SendSessionHeartbeatRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendSessionHeartbeatRequest(const SendSessionHeartbeatRequest& from);
  SendSessionHeartbeatRequest(SendSessionHeartbeatRequest&& from) noexcept
    : SendSessionHeartbeatRequest() {
    *this = ::std::move(from);
  }

  inline SendSessionHeartbeatRequest& operator=(const SendSessionHeartbeatRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendSessionHeartbeatRequest& operator=(SendSessionHeartbeatRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SendSessionHeartbeatRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendSessionHeartbeatRequest* internal_default_instance() {
    return reinterpret_cast<const SendSessionHeartbeatRequest*>(
               &_SendSessionHeartbeatRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(SendSessionHeartbeatRequest& a, SendSessionHeartbeatRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SendSessionHeartbeatRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendSessionHeartbeatRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SendSessionHeartbeatRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SendSessionHeartbeatRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SendSessionHeartbeatRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SendSessionHeartbeatRequest& from) {
    SendSessionHeartbeatRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendSessionHeartbeatRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.robot.v1.SendSessionHeartbeatRequest";
  }
  protected:
  explicit SendSessionHeartbeatRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:viam.robot.v1.SendSessionHeartbeatRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_2fv1_2frobot_2eproto;
};
// -------------------------------------------------------------------

class SendSessionHeartbeatResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:viam.robot.v1.SendSessionHeartbeatResponse) */ {
 public:
  inline SendSessionHeartbeatResponse() : SendSessionHeartbeatResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SendSessionHeartbeatResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendSessionHeartbeatResponse(const SendSessionHeartbeatResponse& from);
  SendSessionHeartbeatResponse(SendSessionHeartbeatResponse&& from) noexcept
    : SendSessionHeartbeatResponse() {
    *this = ::std::move(from);
  }

  inline SendSessionHeartbeatResponse& operator=(const SendSessionHeartbeatResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendSessionHeartbeatResponse& operator=(SendSessionHeartbeatResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SendSessionHeartbeatResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendSessionHeartbeatResponse* internal_default_instance() {
    return reinterpret_cast<const SendSessionHeartbeatResponse*>(
               &_SendSessionHeartbeatResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(SendSessionHeartbeatResponse& a, SendSessionHeartbeatResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SendSessionHeartbeatResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendSessionHeartbeatResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SendSessionHeartbeatResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SendSessionHeartbeatResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SendSessionHeartbeatResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SendSessionHeartbeatResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "viam.robot.v1.SendSessionHeartbeatResponse";
  }
  protected:
  explicit SendSessionHeartbeatResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:viam.robot.v1.SendSessionHeartbeatResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_robot_2fv1_2frobot_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// FrameSystemConfig

// .viam.common.v1.Transform frame = 1 [json_name = "frame"];
inline bool FrameSystemConfig::_internal_has_frame() const {
  return this != internal_default_instance() && _impl_.frame_ != nullptr;
}
inline bool FrameSystemConfig::has_frame() const {
  return _internal_has_frame();
}
inline const ::viam::common::v1::Transform& FrameSystemConfig::_internal_frame() const {
  const ::viam::common::v1::Transform* p = _impl_.frame_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::common::v1::Transform&>(
      ::viam::common::v1::_Transform_default_instance_);
}
inline const ::viam::common::v1::Transform& FrameSystemConfig::frame() const {
  // @@protoc_insertion_point(field_get:viam.robot.v1.FrameSystemConfig.frame)
  return _internal_frame();
}
inline void FrameSystemConfig::unsafe_arena_set_allocated_frame(
    ::viam::common::v1::Transform* frame) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.frame_);
  }
  _impl_.frame_ = frame;
  if (frame) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.robot.v1.FrameSystemConfig.frame)
}
inline ::viam::common::v1::Transform* FrameSystemConfig::release_frame() {
  
  ::viam::common::v1::Transform* temp = _impl_.frame_;
  _impl_.frame_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::common::v1::Transform* FrameSystemConfig::unsafe_arena_release_frame() {
  // @@protoc_insertion_point(field_release:viam.robot.v1.FrameSystemConfig.frame)
  
  ::viam::common::v1::Transform* temp = _impl_.frame_;
  _impl_.frame_ = nullptr;
  return temp;
}
inline ::viam::common::v1::Transform* FrameSystemConfig::_internal_mutable_frame() {
  
  if (_impl_.frame_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::common::v1::Transform>(GetArenaForAllocation());
    _impl_.frame_ = p;
  }
  return _impl_.frame_;
}
inline ::viam::common::v1::Transform* FrameSystemConfig::mutable_frame() {
  ::viam::common::v1::Transform* _msg = _internal_mutable_frame();
  // @@protoc_insertion_point(field_mutable:viam.robot.v1.FrameSystemConfig.frame)
  return _msg;
}
inline void FrameSystemConfig::set_allocated_frame(::viam::common::v1::Transform* frame) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.frame_);
  }
  if (frame) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(frame));
    if (message_arena != submessage_arena) {
      frame = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, frame, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.frame_ = frame;
  // @@protoc_insertion_point(field_set_allocated:viam.robot.v1.FrameSystemConfig.frame)
}

// .google.protobuf.Struct kinematics = 2 [json_name = "kinematics"];
inline bool FrameSystemConfig::_internal_has_kinematics() const {
  return this != internal_default_instance() && _impl_.kinematics_ != nullptr;
}
inline bool FrameSystemConfig::has_kinematics() const {
  return _internal_has_kinematics();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& FrameSystemConfig::_internal_kinematics() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.kinematics_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& FrameSystemConfig::kinematics() const {
  // @@protoc_insertion_point(field_get:viam.robot.v1.FrameSystemConfig.kinematics)
  return _internal_kinematics();
}
inline void FrameSystemConfig::unsafe_arena_set_allocated_kinematics(
    ::PROTOBUF_NAMESPACE_ID::Struct* kinematics) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.kinematics_);
  }
  _impl_.kinematics_ = kinematics;
  if (kinematics) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.robot.v1.FrameSystemConfig.kinematics)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* FrameSystemConfig::release_kinematics() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.kinematics_;
  _impl_.kinematics_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* FrameSystemConfig::unsafe_arena_release_kinematics() {
  // @@protoc_insertion_point(field_release:viam.robot.v1.FrameSystemConfig.kinematics)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.kinematics_;
  _impl_.kinematics_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* FrameSystemConfig::_internal_mutable_kinematics() {
  
  if (_impl_.kinematics_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.kinematics_ = p;
  }
  return _impl_.kinematics_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* FrameSystemConfig::mutable_kinematics() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_kinematics();
  // @@protoc_insertion_point(field_mutable:viam.robot.v1.FrameSystemConfig.kinematics)
  return _msg;
}
inline void FrameSystemConfig::set_allocated_kinematics(::PROTOBUF_NAMESPACE_ID::Struct* kinematics) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.kinematics_);
  }
  if (kinematics) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(kinematics));
    if (message_arena != submessage_arena) {
      kinematics = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, kinematics, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.kinematics_ = kinematics;
  // @@protoc_insertion_point(field_set_allocated:viam.robot.v1.FrameSystemConfig.kinematics)
}

// -------------------------------------------------------------------

// FrameSystemConfigRequest

// repeated .viam.common.v1.Transform supplemental_transforms = 1 [json_name = "supplementalTransforms"];
inline int FrameSystemConfigRequest::_internal_supplemental_transforms_size() const {
  return _impl_.supplemental_transforms_.size();
}
inline int FrameSystemConfigRequest::supplemental_transforms_size() const {
  return _internal_supplemental_transforms_size();
}
inline ::viam::common::v1::Transform* FrameSystemConfigRequest::mutable_supplemental_transforms(int index) {
  // @@protoc_insertion_point(field_mutable:viam.robot.v1.FrameSystemConfigRequest.supplemental_transforms)
  return _impl_.supplemental_transforms_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::common::v1::Transform >*
FrameSystemConfigRequest::mutable_supplemental_transforms() {
  // @@protoc_insertion_point(field_mutable_list:viam.robot.v1.FrameSystemConfigRequest.supplemental_transforms)
  return &_impl_.supplemental_transforms_;
}
inline const ::viam::common::v1::Transform& FrameSystemConfigRequest::_internal_supplemental_transforms(int index) const {
  return _impl_.supplemental_transforms_.Get(index);
}
inline const ::viam::common::v1::Transform& FrameSystemConfigRequest::supplemental_transforms(int index) const {
  // @@protoc_insertion_point(field_get:viam.robot.v1.FrameSystemConfigRequest.supplemental_transforms)
  return _internal_supplemental_transforms(index);
}
inline ::viam::common::v1::Transform* FrameSystemConfigRequest::_internal_add_supplemental_transforms() {
  return _impl_.supplemental_transforms_.Add();
}
inline ::viam::common::v1::Transform* FrameSystemConfigRequest::add_supplemental_transforms() {
  ::viam::common::v1::Transform* _add = _internal_add_supplemental_transforms();
  // @@protoc_insertion_point(field_add:viam.robot.v1.FrameSystemConfigRequest.supplemental_transforms)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::common::v1::Transform >&
FrameSystemConfigRequest::supplemental_transforms() const {
  // @@protoc_insertion_point(field_list:viam.robot.v1.FrameSystemConfigRequest.supplemental_transforms)
  return _impl_.supplemental_transforms_;
}

// -------------------------------------------------------------------

// FrameSystemConfigResponse

// repeated .viam.robot.v1.FrameSystemConfig frame_system_configs = 1 [json_name = "frameSystemConfigs"];
inline int FrameSystemConfigResponse::_internal_frame_system_configs_size() const {
  return _impl_.frame_system_configs_.size();
}
inline int FrameSystemConfigResponse::frame_system_configs_size() const {
  return _internal_frame_system_configs_size();
}
inline void FrameSystemConfigResponse::clear_frame_system_configs() {
  _impl_.frame_system_configs_.Clear();
}
inline ::viam::robot::v1::FrameSystemConfig* FrameSystemConfigResponse::mutable_frame_system_configs(int index) {
  // @@protoc_insertion_point(field_mutable:viam.robot.v1.FrameSystemConfigResponse.frame_system_configs)
  return _impl_.frame_system_configs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::robot::v1::FrameSystemConfig >*
FrameSystemConfigResponse::mutable_frame_system_configs() {
  // @@protoc_insertion_point(field_mutable_list:viam.robot.v1.FrameSystemConfigResponse.frame_system_configs)
  return &_impl_.frame_system_configs_;
}
inline const ::viam::robot::v1::FrameSystemConfig& FrameSystemConfigResponse::_internal_frame_system_configs(int index) const {
  return _impl_.frame_system_configs_.Get(index);
}
inline const ::viam::robot::v1::FrameSystemConfig& FrameSystemConfigResponse::frame_system_configs(int index) const {
  // @@protoc_insertion_point(field_get:viam.robot.v1.FrameSystemConfigResponse.frame_system_configs)
  return _internal_frame_system_configs(index);
}
inline ::viam::robot::v1::FrameSystemConfig* FrameSystemConfigResponse::_internal_add_frame_system_configs() {
  return _impl_.frame_system_configs_.Add();
}
inline ::viam::robot::v1::FrameSystemConfig* FrameSystemConfigResponse::add_frame_system_configs() {
  ::viam::robot::v1::FrameSystemConfig* _add = _internal_add_frame_system_configs();
  // @@protoc_insertion_point(field_add:viam.robot.v1.FrameSystemConfigResponse.frame_system_configs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::robot::v1::FrameSystemConfig >&
FrameSystemConfigResponse::frame_system_configs() const {
  // @@protoc_insertion_point(field_list:viam.robot.v1.FrameSystemConfigResponse.frame_system_configs)
  return _impl_.frame_system_configs_;
}

// -------------------------------------------------------------------

// TransformPoseRequest

// .viam.common.v1.PoseInFrame source = 1 [json_name = "source"];
inline bool TransformPoseRequest::_internal_has_source() const {
  return this != internal_default_instance() && _impl_.source_ != nullptr;
}
inline bool TransformPoseRequest::has_source() const {
  return _internal_has_source();
}
inline const ::viam::common::v1::PoseInFrame& TransformPoseRequest::_internal_source() const {
  const ::viam::common::v1::PoseInFrame* p = _impl_.source_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::common::v1::PoseInFrame&>(
      ::viam::common::v1::_PoseInFrame_default_instance_);
}
inline const ::viam::common::v1::PoseInFrame& TransformPoseRequest::source() const {
  // @@protoc_insertion_point(field_get:viam.robot.v1.TransformPoseRequest.source)
  return _internal_source();
}
inline void TransformPoseRequest::unsafe_arena_set_allocated_source(
    ::viam::common::v1::PoseInFrame* source) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.source_);
  }
  _impl_.source_ = source;
  if (source) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.robot.v1.TransformPoseRequest.source)
}
inline ::viam::common::v1::PoseInFrame* TransformPoseRequest::release_source() {
  
  ::viam::common::v1::PoseInFrame* temp = _impl_.source_;
  _impl_.source_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::common::v1::PoseInFrame* TransformPoseRequest::unsafe_arena_release_source() {
  // @@protoc_insertion_point(field_release:viam.robot.v1.TransformPoseRequest.source)
  
  ::viam::common::v1::PoseInFrame* temp = _impl_.source_;
  _impl_.source_ = nullptr;
  return temp;
}
inline ::viam::common::v1::PoseInFrame* TransformPoseRequest::_internal_mutable_source() {
  
  if (_impl_.source_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::common::v1::PoseInFrame>(GetArenaForAllocation());
    _impl_.source_ = p;
  }
  return _impl_.source_;
}
inline ::viam::common::v1::PoseInFrame* TransformPoseRequest::mutable_source() {
  ::viam::common::v1::PoseInFrame* _msg = _internal_mutable_source();
  // @@protoc_insertion_point(field_mutable:viam.robot.v1.TransformPoseRequest.source)
  return _msg;
}
inline void TransformPoseRequest::set_allocated_source(::viam::common::v1::PoseInFrame* source) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.source_);
  }
  if (source) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(source));
    if (message_arena != submessage_arena) {
      source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.source_ = source;
  // @@protoc_insertion_point(field_set_allocated:viam.robot.v1.TransformPoseRequest.source)
}

// string destination = 2 [json_name = "destination"];
inline void TransformPoseRequest::clear_destination() {
  _impl_.destination_.ClearToEmpty();
}
inline const std::string& TransformPoseRequest::destination() const {
  // @@protoc_insertion_point(field_get:viam.robot.v1.TransformPoseRequest.destination)
  return _internal_destination();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransformPoseRequest::set_destination(ArgT0&& arg0, ArgT... args) {
 
 _impl_.destination_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.robot.v1.TransformPoseRequest.destination)
}
inline std::string* TransformPoseRequest::mutable_destination() {
  std::string* _s = _internal_mutable_destination();
  // @@protoc_insertion_point(field_mutable:viam.robot.v1.TransformPoseRequest.destination)
  return _s;
}
inline const std::string& TransformPoseRequest::_internal_destination() const {
  return _impl_.destination_.Get();
}
inline void TransformPoseRequest::_internal_set_destination(const std::string& value) {
  
  _impl_.destination_.Set(value, GetArenaForAllocation());
}
inline std::string* TransformPoseRequest::_internal_mutable_destination() {
  
  return _impl_.destination_.Mutable(GetArenaForAllocation());
}
inline std::string* TransformPoseRequest::release_destination() {
  // @@protoc_insertion_point(field_release:viam.robot.v1.TransformPoseRequest.destination)
  return _impl_.destination_.Release();
}
inline void TransformPoseRequest::set_allocated_destination(std::string* destination) {
  if (destination != nullptr) {
    
  } else {
    
  }
  _impl_.destination_.SetAllocated(destination, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.destination_.IsDefault()) {
    _impl_.destination_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.robot.v1.TransformPoseRequest.destination)
}

// repeated .viam.common.v1.Transform supplemental_transforms = 3 [json_name = "supplementalTransforms"];
inline int TransformPoseRequest::_internal_supplemental_transforms_size() const {
  return _impl_.supplemental_transforms_.size();
}
inline int TransformPoseRequest::supplemental_transforms_size() const {
  return _internal_supplemental_transforms_size();
}
inline ::viam::common::v1::Transform* TransformPoseRequest::mutable_supplemental_transforms(int index) {
  // @@protoc_insertion_point(field_mutable:viam.robot.v1.TransformPoseRequest.supplemental_transforms)
  return _impl_.supplemental_transforms_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::common::v1::Transform >*
TransformPoseRequest::mutable_supplemental_transforms() {
  // @@protoc_insertion_point(field_mutable_list:viam.robot.v1.TransformPoseRequest.supplemental_transforms)
  return &_impl_.supplemental_transforms_;
}
inline const ::viam::common::v1::Transform& TransformPoseRequest::_internal_supplemental_transforms(int index) const {
  return _impl_.supplemental_transforms_.Get(index);
}
inline const ::viam::common::v1::Transform& TransformPoseRequest::supplemental_transforms(int index) const {
  // @@protoc_insertion_point(field_get:viam.robot.v1.TransformPoseRequest.supplemental_transforms)
  return _internal_supplemental_transforms(index);
}
inline ::viam::common::v1::Transform* TransformPoseRequest::_internal_add_supplemental_transforms() {
  return _impl_.supplemental_transforms_.Add();
}
inline ::viam::common::v1::Transform* TransformPoseRequest::add_supplemental_transforms() {
  ::viam::common::v1::Transform* _add = _internal_add_supplemental_transforms();
  // @@protoc_insertion_point(field_add:viam.robot.v1.TransformPoseRequest.supplemental_transforms)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::common::v1::Transform >&
TransformPoseRequest::supplemental_transforms() const {
  // @@protoc_insertion_point(field_list:viam.robot.v1.TransformPoseRequest.supplemental_transforms)
  return _impl_.supplemental_transforms_;
}

// -------------------------------------------------------------------

// TransformPoseResponse

// .viam.common.v1.PoseInFrame pose = 1 [json_name = "pose"];
inline bool TransformPoseResponse::_internal_has_pose() const {
  return this != internal_default_instance() && _impl_.pose_ != nullptr;
}
inline bool TransformPoseResponse::has_pose() const {
  return _internal_has_pose();
}
inline const ::viam::common::v1::PoseInFrame& TransformPoseResponse::_internal_pose() const {
  const ::viam::common::v1::PoseInFrame* p = _impl_.pose_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::common::v1::PoseInFrame&>(
      ::viam::common::v1::_PoseInFrame_default_instance_);
}
inline const ::viam::common::v1::PoseInFrame& TransformPoseResponse::pose() const {
  // @@protoc_insertion_point(field_get:viam.robot.v1.TransformPoseResponse.pose)
  return _internal_pose();
}
inline void TransformPoseResponse::unsafe_arena_set_allocated_pose(
    ::viam::common::v1::PoseInFrame* pose) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pose_);
  }
  _impl_.pose_ = pose;
  if (pose) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.robot.v1.TransformPoseResponse.pose)
}
inline ::viam::common::v1::PoseInFrame* TransformPoseResponse::release_pose() {
  
  ::viam::common::v1::PoseInFrame* temp = _impl_.pose_;
  _impl_.pose_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::common::v1::PoseInFrame* TransformPoseResponse::unsafe_arena_release_pose() {
  // @@protoc_insertion_point(field_release:viam.robot.v1.TransformPoseResponse.pose)
  
  ::viam::common::v1::PoseInFrame* temp = _impl_.pose_;
  _impl_.pose_ = nullptr;
  return temp;
}
inline ::viam::common::v1::PoseInFrame* TransformPoseResponse::_internal_mutable_pose() {
  
  if (_impl_.pose_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::common::v1::PoseInFrame>(GetArenaForAllocation());
    _impl_.pose_ = p;
  }
  return _impl_.pose_;
}
inline ::viam::common::v1::PoseInFrame* TransformPoseResponse::mutable_pose() {
  ::viam::common::v1::PoseInFrame* _msg = _internal_mutable_pose();
  // @@protoc_insertion_point(field_mutable:viam.robot.v1.TransformPoseResponse.pose)
  return _msg;
}
inline void TransformPoseResponse::set_allocated_pose(::viam::common::v1::PoseInFrame* pose) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pose_);
  }
  if (pose) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pose));
    if (message_arena != submessage_arena) {
      pose = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pose, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pose_ = pose;
  // @@protoc_insertion_point(field_set_allocated:viam.robot.v1.TransformPoseResponse.pose)
}

// -------------------------------------------------------------------

// ResourceNamesRequest

// -------------------------------------------------------------------

// ResourceNamesResponse

// repeated .viam.common.v1.ResourceName resources = 1 [json_name = "resources"];
inline int ResourceNamesResponse::_internal_resources_size() const {
  return _impl_.resources_.size();
}
inline int ResourceNamesResponse::resources_size() const {
  return _internal_resources_size();
}
inline ::viam::common::v1::ResourceName* ResourceNamesResponse::mutable_resources(int index) {
  // @@protoc_insertion_point(field_mutable:viam.robot.v1.ResourceNamesResponse.resources)
  return _impl_.resources_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::common::v1::ResourceName >*
ResourceNamesResponse::mutable_resources() {
  // @@protoc_insertion_point(field_mutable_list:viam.robot.v1.ResourceNamesResponse.resources)
  return &_impl_.resources_;
}
inline const ::viam::common::v1::ResourceName& ResourceNamesResponse::_internal_resources(int index) const {
  return _impl_.resources_.Get(index);
}
inline const ::viam::common::v1::ResourceName& ResourceNamesResponse::resources(int index) const {
  // @@protoc_insertion_point(field_get:viam.robot.v1.ResourceNamesResponse.resources)
  return _internal_resources(index);
}
inline ::viam::common::v1::ResourceName* ResourceNamesResponse::_internal_add_resources() {
  return _impl_.resources_.Add();
}
inline ::viam::common::v1::ResourceName* ResourceNamesResponse::add_resources() {
  ::viam::common::v1::ResourceName* _add = _internal_add_resources();
  // @@protoc_insertion_point(field_add:viam.robot.v1.ResourceNamesResponse.resources)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::common::v1::ResourceName >&
ResourceNamesResponse::resources() const {
  // @@protoc_insertion_point(field_list:viam.robot.v1.ResourceNamesResponse.resources)
  return _impl_.resources_;
}

// -------------------------------------------------------------------

// ResourceRPCSubtype

// .viam.common.v1.ResourceName subtype = 1 [json_name = "subtype"];
inline bool ResourceRPCSubtype::_internal_has_subtype() const {
  return this != internal_default_instance() && _impl_.subtype_ != nullptr;
}
inline bool ResourceRPCSubtype::has_subtype() const {
  return _internal_has_subtype();
}
inline const ::viam::common::v1::ResourceName& ResourceRPCSubtype::_internal_subtype() const {
  const ::viam::common::v1::ResourceName* p = _impl_.subtype_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::common::v1::ResourceName&>(
      ::viam::common::v1::_ResourceName_default_instance_);
}
inline const ::viam::common::v1::ResourceName& ResourceRPCSubtype::subtype() const {
  // @@protoc_insertion_point(field_get:viam.robot.v1.ResourceRPCSubtype.subtype)
  return _internal_subtype();
}
inline void ResourceRPCSubtype::unsafe_arena_set_allocated_subtype(
    ::viam::common::v1::ResourceName* subtype) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.subtype_);
  }
  _impl_.subtype_ = subtype;
  if (subtype) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.robot.v1.ResourceRPCSubtype.subtype)
}
inline ::viam::common::v1::ResourceName* ResourceRPCSubtype::release_subtype() {
  
  ::viam::common::v1::ResourceName* temp = _impl_.subtype_;
  _impl_.subtype_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::common::v1::ResourceName* ResourceRPCSubtype::unsafe_arena_release_subtype() {
  // @@protoc_insertion_point(field_release:viam.robot.v1.ResourceRPCSubtype.subtype)
  
  ::viam::common::v1::ResourceName* temp = _impl_.subtype_;
  _impl_.subtype_ = nullptr;
  return temp;
}
inline ::viam::common::v1::ResourceName* ResourceRPCSubtype::_internal_mutable_subtype() {
  
  if (_impl_.subtype_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::common::v1::ResourceName>(GetArenaForAllocation());
    _impl_.subtype_ = p;
  }
  return _impl_.subtype_;
}
inline ::viam::common::v1::ResourceName* ResourceRPCSubtype::mutable_subtype() {
  ::viam::common::v1::ResourceName* _msg = _internal_mutable_subtype();
  // @@protoc_insertion_point(field_mutable:viam.robot.v1.ResourceRPCSubtype.subtype)
  return _msg;
}
inline void ResourceRPCSubtype::set_allocated_subtype(::viam::common::v1::ResourceName* subtype) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.subtype_);
  }
  if (subtype) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(subtype));
    if (message_arena != submessage_arena) {
      subtype = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subtype, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.subtype_ = subtype;
  // @@protoc_insertion_point(field_set_allocated:viam.robot.v1.ResourceRPCSubtype.subtype)
}

// string proto_service = 2 [json_name = "protoService"];
inline void ResourceRPCSubtype::clear_proto_service() {
  _impl_.proto_service_.ClearToEmpty();
}
inline const std::string& ResourceRPCSubtype::proto_service() const {
  // @@protoc_insertion_point(field_get:viam.robot.v1.ResourceRPCSubtype.proto_service)
  return _internal_proto_service();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResourceRPCSubtype::set_proto_service(ArgT0&& arg0, ArgT... args) {
 
 _impl_.proto_service_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.robot.v1.ResourceRPCSubtype.proto_service)
}
inline std::string* ResourceRPCSubtype::mutable_proto_service() {
  std::string* _s = _internal_mutable_proto_service();
  // @@protoc_insertion_point(field_mutable:viam.robot.v1.ResourceRPCSubtype.proto_service)
  return _s;
}
inline const std::string& ResourceRPCSubtype::_internal_proto_service() const {
  return _impl_.proto_service_.Get();
}
inline void ResourceRPCSubtype::_internal_set_proto_service(const std::string& value) {
  
  _impl_.proto_service_.Set(value, GetArenaForAllocation());
}
inline std::string* ResourceRPCSubtype::_internal_mutable_proto_service() {
  
  return _impl_.proto_service_.Mutable(GetArenaForAllocation());
}
inline std::string* ResourceRPCSubtype::release_proto_service() {
  // @@protoc_insertion_point(field_release:viam.robot.v1.ResourceRPCSubtype.proto_service)
  return _impl_.proto_service_.Release();
}
inline void ResourceRPCSubtype::set_allocated_proto_service(std::string* proto_service) {
  if (proto_service != nullptr) {
    
  } else {
    
  }
  _impl_.proto_service_.SetAllocated(proto_service, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.proto_service_.IsDefault()) {
    _impl_.proto_service_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.robot.v1.ResourceRPCSubtype.proto_service)
}

// -------------------------------------------------------------------

// ResourceRPCSubtypesRequest

// -------------------------------------------------------------------

// ResourceRPCSubtypesResponse

// repeated .viam.robot.v1.ResourceRPCSubtype resource_rpc_subtypes = 1 [json_name = "resourceRpcSubtypes"];
inline int ResourceRPCSubtypesResponse::_internal_resource_rpc_subtypes_size() const {
  return _impl_.resource_rpc_subtypes_.size();
}
inline int ResourceRPCSubtypesResponse::resource_rpc_subtypes_size() const {
  return _internal_resource_rpc_subtypes_size();
}
inline void ResourceRPCSubtypesResponse::clear_resource_rpc_subtypes() {
  _impl_.resource_rpc_subtypes_.Clear();
}
inline ::viam::robot::v1::ResourceRPCSubtype* ResourceRPCSubtypesResponse::mutable_resource_rpc_subtypes(int index) {
  // @@protoc_insertion_point(field_mutable:viam.robot.v1.ResourceRPCSubtypesResponse.resource_rpc_subtypes)
  return _impl_.resource_rpc_subtypes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::robot::v1::ResourceRPCSubtype >*
ResourceRPCSubtypesResponse::mutable_resource_rpc_subtypes() {
  // @@protoc_insertion_point(field_mutable_list:viam.robot.v1.ResourceRPCSubtypesResponse.resource_rpc_subtypes)
  return &_impl_.resource_rpc_subtypes_;
}
inline const ::viam::robot::v1::ResourceRPCSubtype& ResourceRPCSubtypesResponse::_internal_resource_rpc_subtypes(int index) const {
  return _impl_.resource_rpc_subtypes_.Get(index);
}
inline const ::viam::robot::v1::ResourceRPCSubtype& ResourceRPCSubtypesResponse::resource_rpc_subtypes(int index) const {
  // @@protoc_insertion_point(field_get:viam.robot.v1.ResourceRPCSubtypesResponse.resource_rpc_subtypes)
  return _internal_resource_rpc_subtypes(index);
}
inline ::viam::robot::v1::ResourceRPCSubtype* ResourceRPCSubtypesResponse::_internal_add_resource_rpc_subtypes() {
  return _impl_.resource_rpc_subtypes_.Add();
}
inline ::viam::robot::v1::ResourceRPCSubtype* ResourceRPCSubtypesResponse::add_resource_rpc_subtypes() {
  ::viam::robot::v1::ResourceRPCSubtype* _add = _internal_add_resource_rpc_subtypes();
  // @@protoc_insertion_point(field_add:viam.robot.v1.ResourceRPCSubtypesResponse.resource_rpc_subtypes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::robot::v1::ResourceRPCSubtype >&
ResourceRPCSubtypesResponse::resource_rpc_subtypes() const {
  // @@protoc_insertion_point(field_list:viam.robot.v1.ResourceRPCSubtypesResponse.resource_rpc_subtypes)
  return _impl_.resource_rpc_subtypes_;
}

// -------------------------------------------------------------------

// Operation

// string id = 1 [json_name = "id"];
inline void Operation::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& Operation::id() const {
  // @@protoc_insertion_point(field_get:viam.robot.v1.Operation.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Operation::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.robot.v1.Operation.id)
}
inline std::string* Operation::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.robot.v1.Operation.id)
  return _s;
}
inline const std::string& Operation::_internal_id() const {
  return _impl_.id_.Get();
}
inline void Operation::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Operation::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* Operation::release_id() {
  // @@protoc_insertion_point(field_release:viam.robot.v1.Operation.id)
  return _impl_.id_.Release();
}
inline void Operation::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.robot.v1.Operation.id)
}

// string method = 2 [json_name = "method"];
inline void Operation::clear_method() {
  _impl_.method_.ClearToEmpty();
}
inline const std::string& Operation::method() const {
  // @@protoc_insertion_point(field_get:viam.robot.v1.Operation.method)
  return _internal_method();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Operation::set_method(ArgT0&& arg0, ArgT... args) {
 
 _impl_.method_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.robot.v1.Operation.method)
}
inline std::string* Operation::mutable_method() {
  std::string* _s = _internal_mutable_method();
  // @@protoc_insertion_point(field_mutable:viam.robot.v1.Operation.method)
  return _s;
}
inline const std::string& Operation::_internal_method() const {
  return _impl_.method_.Get();
}
inline void Operation::_internal_set_method(const std::string& value) {
  
  _impl_.method_.Set(value, GetArenaForAllocation());
}
inline std::string* Operation::_internal_mutable_method() {
  
  return _impl_.method_.Mutable(GetArenaForAllocation());
}
inline std::string* Operation::release_method() {
  // @@protoc_insertion_point(field_release:viam.robot.v1.Operation.method)
  return _impl_.method_.Release();
}
inline void Operation::set_allocated_method(std::string* method) {
  if (method != nullptr) {
    
  } else {
    
  }
  _impl_.method_.SetAllocated(method, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.method_.IsDefault()) {
    _impl_.method_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.robot.v1.Operation.method)
}

// .google.protobuf.Struct arguments = 3 [json_name = "arguments"];
inline bool Operation::_internal_has_arguments() const {
  return this != internal_default_instance() && _impl_.arguments_ != nullptr;
}
inline bool Operation::has_arguments() const {
  return _internal_has_arguments();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& Operation::_internal_arguments() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.arguments_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& Operation::arguments() const {
  // @@protoc_insertion_point(field_get:viam.robot.v1.Operation.arguments)
  return _internal_arguments();
}
inline void Operation::unsafe_arena_set_allocated_arguments(
    ::PROTOBUF_NAMESPACE_ID::Struct* arguments) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.arguments_);
  }
  _impl_.arguments_ = arguments;
  if (arguments) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.robot.v1.Operation.arguments)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Operation::release_arguments() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.arguments_;
  _impl_.arguments_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Operation::unsafe_arena_release_arguments() {
  // @@protoc_insertion_point(field_release:viam.robot.v1.Operation.arguments)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.arguments_;
  _impl_.arguments_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Operation::_internal_mutable_arguments() {
  
  if (_impl_.arguments_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.arguments_ = p;
  }
  return _impl_.arguments_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Operation::mutable_arguments() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_arguments();
  // @@protoc_insertion_point(field_mutable:viam.robot.v1.Operation.arguments)
  return _msg;
}
inline void Operation::set_allocated_arguments(::PROTOBUF_NAMESPACE_ID::Struct* arguments) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.arguments_);
  }
  if (arguments) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(arguments));
    if (message_arena != submessage_arena) {
      arguments = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, arguments, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.arguments_ = arguments;
  // @@protoc_insertion_point(field_set_allocated:viam.robot.v1.Operation.arguments)
}

// .google.protobuf.Timestamp started = 4 [json_name = "started"];
inline bool Operation::_internal_has_started() const {
  return this != internal_default_instance() && _impl_.started_ != nullptr;
}
inline bool Operation::has_started() const {
  return _internal_has_started();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Operation::_internal_started() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.started_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Operation::started() const {
  // @@protoc_insertion_point(field_get:viam.robot.v1.Operation.started)
  return _internal_started();
}
inline void Operation::unsafe_arena_set_allocated_started(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* started) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.started_);
  }
  _impl_.started_ = started;
  if (started) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.robot.v1.Operation.started)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Operation::release_started() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.started_;
  _impl_.started_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Operation::unsafe_arena_release_started() {
  // @@protoc_insertion_point(field_release:viam.robot.v1.Operation.started)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.started_;
  _impl_.started_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Operation::_internal_mutable_started() {
  
  if (_impl_.started_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.started_ = p;
  }
  return _impl_.started_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Operation::mutable_started() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_started();
  // @@protoc_insertion_point(field_mutable:viam.robot.v1.Operation.started)
  return _msg;
}
inline void Operation::set_allocated_started(::PROTOBUF_NAMESPACE_ID::Timestamp* started) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.started_);
  }
  if (started) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(started));
    if (message_arena != submessage_arena) {
      started = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, started, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.started_ = started;
  // @@protoc_insertion_point(field_set_allocated:viam.robot.v1.Operation.started)
}

// optional string session_id = 5 [json_name = "sessionId"];
inline bool Operation::_internal_has_session_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Operation::has_session_id() const {
  return _internal_has_session_id();
}
inline void Operation::clear_session_id() {
  _impl_.session_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Operation::session_id() const {
  // @@protoc_insertion_point(field_get:viam.robot.v1.Operation.session_id)
  return _internal_session_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Operation::set_session_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.session_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.robot.v1.Operation.session_id)
}
inline std::string* Operation::mutable_session_id() {
  std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:viam.robot.v1.Operation.session_id)
  return _s;
}
inline const std::string& Operation::_internal_session_id() const {
  return _impl_.session_id_.Get();
}
inline void Operation::_internal_set_session_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.session_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Operation::_internal_mutable_session_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.session_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Operation::release_session_id() {
  // @@protoc_insertion_point(field_release:viam.robot.v1.Operation.session_id)
  if (!_internal_has_session_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.session_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.session_id_.IsDefault()) {
    _impl_.session_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Operation::set_allocated_session_id(std::string* session_id) {
  if (session_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.session_id_.SetAllocated(session_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.session_id_.IsDefault()) {
    _impl_.session_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.robot.v1.Operation.session_id)
}

// -------------------------------------------------------------------

// GetOperationsRequest

// -------------------------------------------------------------------

// GetOperationsResponse

// repeated .viam.robot.v1.Operation operations = 1 [json_name = "operations"];
inline int GetOperationsResponse::_internal_operations_size() const {
  return _impl_.operations_.size();
}
inline int GetOperationsResponse::operations_size() const {
  return _internal_operations_size();
}
inline void GetOperationsResponse::clear_operations() {
  _impl_.operations_.Clear();
}
inline ::viam::robot::v1::Operation* GetOperationsResponse::mutable_operations(int index) {
  // @@protoc_insertion_point(field_mutable:viam.robot.v1.GetOperationsResponse.operations)
  return _impl_.operations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::robot::v1::Operation >*
GetOperationsResponse::mutable_operations() {
  // @@protoc_insertion_point(field_mutable_list:viam.robot.v1.GetOperationsResponse.operations)
  return &_impl_.operations_;
}
inline const ::viam::robot::v1::Operation& GetOperationsResponse::_internal_operations(int index) const {
  return _impl_.operations_.Get(index);
}
inline const ::viam::robot::v1::Operation& GetOperationsResponse::operations(int index) const {
  // @@protoc_insertion_point(field_get:viam.robot.v1.GetOperationsResponse.operations)
  return _internal_operations(index);
}
inline ::viam::robot::v1::Operation* GetOperationsResponse::_internal_add_operations() {
  return _impl_.operations_.Add();
}
inline ::viam::robot::v1::Operation* GetOperationsResponse::add_operations() {
  ::viam::robot::v1::Operation* _add = _internal_add_operations();
  // @@protoc_insertion_point(field_add:viam.robot.v1.GetOperationsResponse.operations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::robot::v1::Operation >&
GetOperationsResponse::operations() const {
  // @@protoc_insertion_point(field_list:viam.robot.v1.GetOperationsResponse.operations)
  return _impl_.operations_;
}

// -------------------------------------------------------------------

// CancelOperationRequest

// string id = 1 [json_name = "id"];
inline void CancelOperationRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& CancelOperationRequest::id() const {
  // @@protoc_insertion_point(field_get:viam.robot.v1.CancelOperationRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CancelOperationRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.robot.v1.CancelOperationRequest.id)
}
inline std::string* CancelOperationRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.robot.v1.CancelOperationRequest.id)
  return _s;
}
inline const std::string& CancelOperationRequest::_internal_id() const {
  return _impl_.id_.Get();
}
inline void CancelOperationRequest::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* CancelOperationRequest::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* CancelOperationRequest::release_id() {
  // @@protoc_insertion_point(field_release:viam.robot.v1.CancelOperationRequest.id)
  return _impl_.id_.Release();
}
inline void CancelOperationRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.robot.v1.CancelOperationRequest.id)
}

// -------------------------------------------------------------------

// CancelOperationResponse

// -------------------------------------------------------------------

// BlockForOperationRequest

// string id = 1 [json_name = "id"];
inline void BlockForOperationRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& BlockForOperationRequest::id() const {
  // @@protoc_insertion_point(field_get:viam.robot.v1.BlockForOperationRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BlockForOperationRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.robot.v1.BlockForOperationRequest.id)
}
inline std::string* BlockForOperationRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.robot.v1.BlockForOperationRequest.id)
  return _s;
}
inline const std::string& BlockForOperationRequest::_internal_id() const {
  return _impl_.id_.Get();
}
inline void BlockForOperationRequest::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* BlockForOperationRequest::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* BlockForOperationRequest::release_id() {
  // @@protoc_insertion_point(field_release:viam.robot.v1.BlockForOperationRequest.id)
  return _impl_.id_.Release();
}
inline void BlockForOperationRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.robot.v1.BlockForOperationRequest.id)
}

// -------------------------------------------------------------------

// BlockForOperationResponse

// -------------------------------------------------------------------

// PeerConnectionInfo

// .viam.robot.v1.PeerConnectionType type = 1 [json_name = "type"];
inline void PeerConnectionInfo::clear_type() {
  _impl_.type_ = 0;
}
inline ::viam::robot::v1::PeerConnectionType PeerConnectionInfo::_internal_type() const {
  return static_cast< ::viam::robot::v1::PeerConnectionType >(_impl_.type_);
}
inline ::viam::robot::v1::PeerConnectionType PeerConnectionInfo::type() const {
  // @@protoc_insertion_point(field_get:viam.robot.v1.PeerConnectionInfo.type)
  return _internal_type();
}
inline void PeerConnectionInfo::_internal_set_type(::viam::robot::v1::PeerConnectionType value) {
  
  _impl_.type_ = value;
}
inline void PeerConnectionInfo::set_type(::viam::robot::v1::PeerConnectionType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:viam.robot.v1.PeerConnectionInfo.type)
}

// optional string remote_address = 2 [json_name = "remoteAddress"];
inline bool PeerConnectionInfo::_internal_has_remote_address() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PeerConnectionInfo::has_remote_address() const {
  return _internal_has_remote_address();
}
inline void PeerConnectionInfo::clear_remote_address() {
  _impl_.remote_address_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PeerConnectionInfo::remote_address() const {
  // @@protoc_insertion_point(field_get:viam.robot.v1.PeerConnectionInfo.remote_address)
  return _internal_remote_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PeerConnectionInfo::set_remote_address(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.remote_address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.robot.v1.PeerConnectionInfo.remote_address)
}
inline std::string* PeerConnectionInfo::mutable_remote_address() {
  std::string* _s = _internal_mutable_remote_address();
  // @@protoc_insertion_point(field_mutable:viam.robot.v1.PeerConnectionInfo.remote_address)
  return _s;
}
inline const std::string& PeerConnectionInfo::_internal_remote_address() const {
  return _impl_.remote_address_.Get();
}
inline void PeerConnectionInfo::_internal_set_remote_address(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.remote_address_.Set(value, GetArenaForAllocation());
}
inline std::string* PeerConnectionInfo::_internal_mutable_remote_address() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.remote_address_.Mutable(GetArenaForAllocation());
}
inline std::string* PeerConnectionInfo::release_remote_address() {
  // @@protoc_insertion_point(field_release:viam.robot.v1.PeerConnectionInfo.remote_address)
  if (!_internal_has_remote_address()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.remote_address_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.remote_address_.IsDefault()) {
    _impl_.remote_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PeerConnectionInfo::set_allocated_remote_address(std::string* remote_address) {
  if (remote_address != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.remote_address_.SetAllocated(remote_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.remote_address_.IsDefault()) {
    _impl_.remote_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.robot.v1.PeerConnectionInfo.remote_address)
}

// optional string local_address = 3 [json_name = "localAddress"];
inline bool PeerConnectionInfo::_internal_has_local_address() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PeerConnectionInfo::has_local_address() const {
  return _internal_has_local_address();
}
inline void PeerConnectionInfo::clear_local_address() {
  _impl_.local_address_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PeerConnectionInfo::local_address() const {
  // @@protoc_insertion_point(field_get:viam.robot.v1.PeerConnectionInfo.local_address)
  return _internal_local_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PeerConnectionInfo::set_local_address(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.local_address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.robot.v1.PeerConnectionInfo.local_address)
}
inline std::string* PeerConnectionInfo::mutable_local_address() {
  std::string* _s = _internal_mutable_local_address();
  // @@protoc_insertion_point(field_mutable:viam.robot.v1.PeerConnectionInfo.local_address)
  return _s;
}
inline const std::string& PeerConnectionInfo::_internal_local_address() const {
  return _impl_.local_address_.Get();
}
inline void PeerConnectionInfo::_internal_set_local_address(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.local_address_.Set(value, GetArenaForAllocation());
}
inline std::string* PeerConnectionInfo::_internal_mutable_local_address() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.local_address_.Mutable(GetArenaForAllocation());
}
inline std::string* PeerConnectionInfo::release_local_address() {
  // @@protoc_insertion_point(field_release:viam.robot.v1.PeerConnectionInfo.local_address)
  if (!_internal_has_local_address()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.local_address_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.local_address_.IsDefault()) {
    _impl_.local_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PeerConnectionInfo::set_allocated_local_address(std::string* local_address) {
  if (local_address != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.local_address_.SetAllocated(local_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.local_address_.IsDefault()) {
    _impl_.local_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.robot.v1.PeerConnectionInfo.local_address)
}

// -------------------------------------------------------------------

// Session

// string id = 1 [json_name = "id"];
inline void Session::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& Session::id() const {
  // @@protoc_insertion_point(field_get:viam.robot.v1.Session.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Session::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.robot.v1.Session.id)
}
inline std::string* Session::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.robot.v1.Session.id)
  return _s;
}
inline const std::string& Session::_internal_id() const {
  return _impl_.id_.Get();
}
inline void Session::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Session::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* Session::release_id() {
  // @@protoc_insertion_point(field_release:viam.robot.v1.Session.id)
  return _impl_.id_.Release();
}
inline void Session::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.robot.v1.Session.id)
}

// optional .viam.robot.v1.PeerConnectionInfo peer_connection_info = 2 [json_name = "peerConnectionInfo"];
inline bool Session::_internal_has_peer_connection_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.peer_connection_info_ != nullptr);
  return value;
}
inline bool Session::has_peer_connection_info() const {
  return _internal_has_peer_connection_info();
}
inline void Session::clear_peer_connection_info() {
  if (_impl_.peer_connection_info_ != nullptr) _impl_.peer_connection_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::viam::robot::v1::PeerConnectionInfo& Session::_internal_peer_connection_info() const {
  const ::viam::robot::v1::PeerConnectionInfo* p = _impl_.peer_connection_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::robot::v1::PeerConnectionInfo&>(
      ::viam::robot::v1::_PeerConnectionInfo_default_instance_);
}
inline const ::viam::robot::v1::PeerConnectionInfo& Session::peer_connection_info() const {
  // @@protoc_insertion_point(field_get:viam.robot.v1.Session.peer_connection_info)
  return _internal_peer_connection_info();
}
inline void Session::unsafe_arena_set_allocated_peer_connection_info(
    ::viam::robot::v1::PeerConnectionInfo* peer_connection_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.peer_connection_info_);
  }
  _impl_.peer_connection_info_ = peer_connection_info;
  if (peer_connection_info) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.robot.v1.Session.peer_connection_info)
}
inline ::viam::robot::v1::PeerConnectionInfo* Session::release_peer_connection_info() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::viam::robot::v1::PeerConnectionInfo* temp = _impl_.peer_connection_info_;
  _impl_.peer_connection_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::robot::v1::PeerConnectionInfo* Session::unsafe_arena_release_peer_connection_info() {
  // @@protoc_insertion_point(field_release:viam.robot.v1.Session.peer_connection_info)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::viam::robot::v1::PeerConnectionInfo* temp = _impl_.peer_connection_info_;
  _impl_.peer_connection_info_ = nullptr;
  return temp;
}
inline ::viam::robot::v1::PeerConnectionInfo* Session::_internal_mutable_peer_connection_info() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.peer_connection_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::robot::v1::PeerConnectionInfo>(GetArenaForAllocation());
    _impl_.peer_connection_info_ = p;
  }
  return _impl_.peer_connection_info_;
}
inline ::viam::robot::v1::PeerConnectionInfo* Session::mutable_peer_connection_info() {
  ::viam::robot::v1::PeerConnectionInfo* _msg = _internal_mutable_peer_connection_info();
  // @@protoc_insertion_point(field_mutable:viam.robot.v1.Session.peer_connection_info)
  return _msg;
}
inline void Session::set_allocated_peer_connection_info(::viam::robot::v1::PeerConnectionInfo* peer_connection_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.peer_connection_info_;
  }
  if (peer_connection_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(peer_connection_info);
    if (message_arena != submessage_arena) {
      peer_connection_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, peer_connection_info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.peer_connection_info_ = peer_connection_info;
  // @@protoc_insertion_point(field_set_allocated:viam.robot.v1.Session.peer_connection_info)
}

// -------------------------------------------------------------------

// GetSessionsRequest

// -------------------------------------------------------------------

// GetSessionsResponse

// repeated .viam.robot.v1.Session sessions = 1 [json_name = "sessions"];
inline int GetSessionsResponse::_internal_sessions_size() const {
  return _impl_.sessions_.size();
}
inline int GetSessionsResponse::sessions_size() const {
  return _internal_sessions_size();
}
inline void GetSessionsResponse::clear_sessions() {
  _impl_.sessions_.Clear();
}
inline ::viam::robot::v1::Session* GetSessionsResponse::mutable_sessions(int index) {
  // @@protoc_insertion_point(field_mutable:viam.robot.v1.GetSessionsResponse.sessions)
  return _impl_.sessions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::robot::v1::Session >*
GetSessionsResponse::mutable_sessions() {
  // @@protoc_insertion_point(field_mutable_list:viam.robot.v1.GetSessionsResponse.sessions)
  return &_impl_.sessions_;
}
inline const ::viam::robot::v1::Session& GetSessionsResponse::_internal_sessions(int index) const {
  return _impl_.sessions_.Get(index);
}
inline const ::viam::robot::v1::Session& GetSessionsResponse::sessions(int index) const {
  // @@protoc_insertion_point(field_get:viam.robot.v1.GetSessionsResponse.sessions)
  return _internal_sessions(index);
}
inline ::viam::robot::v1::Session* GetSessionsResponse::_internal_add_sessions() {
  return _impl_.sessions_.Add();
}
inline ::viam::robot::v1::Session* GetSessionsResponse::add_sessions() {
  ::viam::robot::v1::Session* _add = _internal_add_sessions();
  // @@protoc_insertion_point(field_add:viam.robot.v1.GetSessionsResponse.sessions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::robot::v1::Session >&
GetSessionsResponse::sessions() const {
  // @@protoc_insertion_point(field_list:viam.robot.v1.GetSessionsResponse.sessions)
  return _impl_.sessions_;
}

// -------------------------------------------------------------------

// DiscoveryQuery

// string subtype = 1 [json_name = "subtype"];
inline void DiscoveryQuery::clear_subtype() {
  _impl_.subtype_.ClearToEmpty();
}
inline const std::string& DiscoveryQuery::subtype() const {
  // @@protoc_insertion_point(field_get:viam.robot.v1.DiscoveryQuery.subtype)
  return _internal_subtype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DiscoveryQuery::set_subtype(ArgT0&& arg0, ArgT... args) {
 
 _impl_.subtype_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.robot.v1.DiscoveryQuery.subtype)
}
inline std::string* DiscoveryQuery::mutable_subtype() {
  std::string* _s = _internal_mutable_subtype();
  // @@protoc_insertion_point(field_mutable:viam.robot.v1.DiscoveryQuery.subtype)
  return _s;
}
inline const std::string& DiscoveryQuery::_internal_subtype() const {
  return _impl_.subtype_.Get();
}
inline void DiscoveryQuery::_internal_set_subtype(const std::string& value) {
  
  _impl_.subtype_.Set(value, GetArenaForAllocation());
}
inline std::string* DiscoveryQuery::_internal_mutable_subtype() {
  
  return _impl_.subtype_.Mutable(GetArenaForAllocation());
}
inline std::string* DiscoveryQuery::release_subtype() {
  // @@protoc_insertion_point(field_release:viam.robot.v1.DiscoveryQuery.subtype)
  return _impl_.subtype_.Release();
}
inline void DiscoveryQuery::set_allocated_subtype(std::string* subtype) {
  if (subtype != nullptr) {
    
  } else {
    
  }
  _impl_.subtype_.SetAllocated(subtype, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.subtype_.IsDefault()) {
    _impl_.subtype_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.robot.v1.DiscoveryQuery.subtype)
}

// string model = 2 [json_name = "model"];
inline void DiscoveryQuery::clear_model() {
  _impl_.model_.ClearToEmpty();
}
inline const std::string& DiscoveryQuery::model() const {
  // @@protoc_insertion_point(field_get:viam.robot.v1.DiscoveryQuery.model)
  return _internal_model();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DiscoveryQuery::set_model(ArgT0&& arg0, ArgT... args) {
 
 _impl_.model_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.robot.v1.DiscoveryQuery.model)
}
inline std::string* DiscoveryQuery::mutable_model() {
  std::string* _s = _internal_mutable_model();
  // @@protoc_insertion_point(field_mutable:viam.robot.v1.DiscoveryQuery.model)
  return _s;
}
inline const std::string& DiscoveryQuery::_internal_model() const {
  return _impl_.model_.Get();
}
inline void DiscoveryQuery::_internal_set_model(const std::string& value) {
  
  _impl_.model_.Set(value, GetArenaForAllocation());
}
inline std::string* DiscoveryQuery::_internal_mutable_model() {
  
  return _impl_.model_.Mutable(GetArenaForAllocation());
}
inline std::string* DiscoveryQuery::release_model() {
  // @@protoc_insertion_point(field_release:viam.robot.v1.DiscoveryQuery.model)
  return _impl_.model_.Release();
}
inline void DiscoveryQuery::set_allocated_model(std::string* model) {
  if (model != nullptr) {
    
  } else {
    
  }
  _impl_.model_.SetAllocated(model, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.model_.IsDefault()) {
    _impl_.model_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.robot.v1.DiscoveryQuery.model)
}

// -------------------------------------------------------------------

// Discovery

// .viam.robot.v1.DiscoveryQuery query = 1 [json_name = "query"];
inline bool Discovery::_internal_has_query() const {
  return this != internal_default_instance() && _impl_.query_ != nullptr;
}
inline bool Discovery::has_query() const {
  return _internal_has_query();
}
inline void Discovery::clear_query() {
  if (GetArenaForAllocation() == nullptr && _impl_.query_ != nullptr) {
    delete _impl_.query_;
  }
  _impl_.query_ = nullptr;
}
inline const ::viam::robot::v1::DiscoveryQuery& Discovery::_internal_query() const {
  const ::viam::robot::v1::DiscoveryQuery* p = _impl_.query_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::robot::v1::DiscoveryQuery&>(
      ::viam::robot::v1::_DiscoveryQuery_default_instance_);
}
inline const ::viam::robot::v1::DiscoveryQuery& Discovery::query() const {
  // @@protoc_insertion_point(field_get:viam.robot.v1.Discovery.query)
  return _internal_query();
}
inline void Discovery::unsafe_arena_set_allocated_query(
    ::viam::robot::v1::DiscoveryQuery* query) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.query_);
  }
  _impl_.query_ = query;
  if (query) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.robot.v1.Discovery.query)
}
inline ::viam::robot::v1::DiscoveryQuery* Discovery::release_query() {
  
  ::viam::robot::v1::DiscoveryQuery* temp = _impl_.query_;
  _impl_.query_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::robot::v1::DiscoveryQuery* Discovery::unsafe_arena_release_query() {
  // @@protoc_insertion_point(field_release:viam.robot.v1.Discovery.query)
  
  ::viam::robot::v1::DiscoveryQuery* temp = _impl_.query_;
  _impl_.query_ = nullptr;
  return temp;
}
inline ::viam::robot::v1::DiscoveryQuery* Discovery::_internal_mutable_query() {
  
  if (_impl_.query_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::robot::v1::DiscoveryQuery>(GetArenaForAllocation());
    _impl_.query_ = p;
  }
  return _impl_.query_;
}
inline ::viam::robot::v1::DiscoveryQuery* Discovery::mutable_query() {
  ::viam::robot::v1::DiscoveryQuery* _msg = _internal_mutable_query();
  // @@protoc_insertion_point(field_mutable:viam.robot.v1.Discovery.query)
  return _msg;
}
inline void Discovery::set_allocated_query(::viam::robot::v1::DiscoveryQuery* query) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.query_;
  }
  if (query) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(query);
    if (message_arena != submessage_arena) {
      query = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, query, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.query_ = query;
  // @@protoc_insertion_point(field_set_allocated:viam.robot.v1.Discovery.query)
}

// .google.protobuf.Struct results = 2 [json_name = "results"];
inline bool Discovery::_internal_has_results() const {
  return this != internal_default_instance() && _impl_.results_ != nullptr;
}
inline bool Discovery::has_results() const {
  return _internal_has_results();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& Discovery::_internal_results() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.results_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& Discovery::results() const {
  // @@protoc_insertion_point(field_get:viam.robot.v1.Discovery.results)
  return _internal_results();
}
inline void Discovery::unsafe_arena_set_allocated_results(
    ::PROTOBUF_NAMESPACE_ID::Struct* results) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.results_);
  }
  _impl_.results_ = results;
  if (results) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.robot.v1.Discovery.results)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Discovery::release_results() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.results_;
  _impl_.results_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Discovery::unsafe_arena_release_results() {
  // @@protoc_insertion_point(field_release:viam.robot.v1.Discovery.results)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.results_;
  _impl_.results_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Discovery::_internal_mutable_results() {
  
  if (_impl_.results_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.results_ = p;
  }
  return _impl_.results_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Discovery::mutable_results() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_results();
  // @@protoc_insertion_point(field_mutable:viam.robot.v1.Discovery.results)
  return _msg;
}
inline void Discovery::set_allocated_results(::PROTOBUF_NAMESPACE_ID::Struct* results) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.results_);
  }
  if (results) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(results));
    if (message_arena != submessage_arena) {
      results = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, results, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.results_ = results;
  // @@protoc_insertion_point(field_set_allocated:viam.robot.v1.Discovery.results)
}

// -------------------------------------------------------------------

// DiscoverComponentsRequest

// repeated .viam.robot.v1.DiscoveryQuery queries = 1 [json_name = "queries"];
inline int DiscoverComponentsRequest::_internal_queries_size() const {
  return _impl_.queries_.size();
}
inline int DiscoverComponentsRequest::queries_size() const {
  return _internal_queries_size();
}
inline void DiscoverComponentsRequest::clear_queries() {
  _impl_.queries_.Clear();
}
inline ::viam::robot::v1::DiscoveryQuery* DiscoverComponentsRequest::mutable_queries(int index) {
  // @@protoc_insertion_point(field_mutable:viam.robot.v1.DiscoverComponentsRequest.queries)
  return _impl_.queries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::robot::v1::DiscoveryQuery >*
DiscoverComponentsRequest::mutable_queries() {
  // @@protoc_insertion_point(field_mutable_list:viam.robot.v1.DiscoverComponentsRequest.queries)
  return &_impl_.queries_;
}
inline const ::viam::robot::v1::DiscoveryQuery& DiscoverComponentsRequest::_internal_queries(int index) const {
  return _impl_.queries_.Get(index);
}
inline const ::viam::robot::v1::DiscoveryQuery& DiscoverComponentsRequest::queries(int index) const {
  // @@protoc_insertion_point(field_get:viam.robot.v1.DiscoverComponentsRequest.queries)
  return _internal_queries(index);
}
inline ::viam::robot::v1::DiscoveryQuery* DiscoverComponentsRequest::_internal_add_queries() {
  return _impl_.queries_.Add();
}
inline ::viam::robot::v1::DiscoveryQuery* DiscoverComponentsRequest::add_queries() {
  ::viam::robot::v1::DiscoveryQuery* _add = _internal_add_queries();
  // @@protoc_insertion_point(field_add:viam.robot.v1.DiscoverComponentsRequest.queries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::robot::v1::DiscoveryQuery >&
DiscoverComponentsRequest::queries() const {
  // @@protoc_insertion_point(field_list:viam.robot.v1.DiscoverComponentsRequest.queries)
  return _impl_.queries_;
}

// -------------------------------------------------------------------

// DiscoverComponentsResponse

// repeated .viam.robot.v1.Discovery discovery = 1 [json_name = "discovery"];
inline int DiscoverComponentsResponse::_internal_discovery_size() const {
  return _impl_.discovery_.size();
}
inline int DiscoverComponentsResponse::discovery_size() const {
  return _internal_discovery_size();
}
inline void DiscoverComponentsResponse::clear_discovery() {
  _impl_.discovery_.Clear();
}
inline ::viam::robot::v1::Discovery* DiscoverComponentsResponse::mutable_discovery(int index) {
  // @@protoc_insertion_point(field_mutable:viam.robot.v1.DiscoverComponentsResponse.discovery)
  return _impl_.discovery_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::robot::v1::Discovery >*
DiscoverComponentsResponse::mutable_discovery() {
  // @@protoc_insertion_point(field_mutable_list:viam.robot.v1.DiscoverComponentsResponse.discovery)
  return &_impl_.discovery_;
}
inline const ::viam::robot::v1::Discovery& DiscoverComponentsResponse::_internal_discovery(int index) const {
  return _impl_.discovery_.Get(index);
}
inline const ::viam::robot::v1::Discovery& DiscoverComponentsResponse::discovery(int index) const {
  // @@protoc_insertion_point(field_get:viam.robot.v1.DiscoverComponentsResponse.discovery)
  return _internal_discovery(index);
}
inline ::viam::robot::v1::Discovery* DiscoverComponentsResponse::_internal_add_discovery() {
  return _impl_.discovery_.Add();
}
inline ::viam::robot::v1::Discovery* DiscoverComponentsResponse::add_discovery() {
  ::viam::robot::v1::Discovery* _add = _internal_add_discovery();
  // @@protoc_insertion_point(field_add:viam.robot.v1.DiscoverComponentsResponse.discovery)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::robot::v1::Discovery >&
DiscoverComponentsResponse::discovery() const {
  // @@protoc_insertion_point(field_list:viam.robot.v1.DiscoverComponentsResponse.discovery)
  return _impl_.discovery_;
}

// -------------------------------------------------------------------

// Status

// .viam.common.v1.ResourceName name = 1 [json_name = "name"];
inline bool Status::_internal_has_name() const {
  return this != internal_default_instance() && _impl_.name_ != nullptr;
}
inline bool Status::has_name() const {
  return _internal_has_name();
}
inline const ::viam::common::v1::ResourceName& Status::_internal_name() const {
  const ::viam::common::v1::ResourceName* p = _impl_.name_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::common::v1::ResourceName&>(
      ::viam::common::v1::_ResourceName_default_instance_);
}
inline const ::viam::common::v1::ResourceName& Status::name() const {
  // @@protoc_insertion_point(field_get:viam.robot.v1.Status.name)
  return _internal_name();
}
inline void Status::unsafe_arena_set_allocated_name(
    ::viam::common::v1::ResourceName* name) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.name_);
  }
  _impl_.name_ = name;
  if (name) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.robot.v1.Status.name)
}
inline ::viam::common::v1::ResourceName* Status::release_name() {
  
  ::viam::common::v1::ResourceName* temp = _impl_.name_;
  _impl_.name_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::common::v1::ResourceName* Status::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_release:viam.robot.v1.Status.name)
  
  ::viam::common::v1::ResourceName* temp = _impl_.name_;
  _impl_.name_ = nullptr;
  return temp;
}
inline ::viam::common::v1::ResourceName* Status::_internal_mutable_name() {
  
  if (_impl_.name_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::common::v1::ResourceName>(GetArenaForAllocation());
    _impl_.name_ = p;
  }
  return _impl_.name_;
}
inline ::viam::common::v1::ResourceName* Status::mutable_name() {
  ::viam::common::v1::ResourceName* _msg = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.robot.v1.Status.name)
  return _msg;
}
inline void Status::set_allocated_name(::viam::common::v1::ResourceName* name) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.name_);
  }
  if (name) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(name));
    if (message_arena != submessage_arena) {
      name = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, name, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.name_ = name;
  // @@protoc_insertion_point(field_set_allocated:viam.robot.v1.Status.name)
}

// .google.protobuf.Struct status = 2 [json_name = "status"];
inline bool Status::_internal_has_status() const {
  return this != internal_default_instance() && _impl_.status_ != nullptr;
}
inline bool Status::has_status() const {
  return _internal_has_status();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& Status::_internal_status() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& Status::status() const {
  // @@protoc_insertion_point(field_get:viam.robot.v1.Status.status)
  return _internal_status();
}
inline void Status::unsafe_arena_set_allocated_status(
    ::PROTOBUF_NAMESPACE_ID::Struct* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.robot.v1.Status.status)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Status::release_status() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Status::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:viam.robot.v1.Status.status)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Status::_internal_mutable_status() {
  
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Status::mutable_status() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:viam.robot.v1.Status.status)
  return _msg;
}
inline void Status::set_allocated_status(::PROTOBUF_NAMESPACE_ID::Struct* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:viam.robot.v1.Status.status)
}

// -------------------------------------------------------------------

// GetStatusRequest

// repeated .viam.common.v1.ResourceName resource_names = 1 [json_name = "resourceNames"];
inline int GetStatusRequest::_internal_resource_names_size() const {
  return _impl_.resource_names_.size();
}
inline int GetStatusRequest::resource_names_size() const {
  return _internal_resource_names_size();
}
inline ::viam::common::v1::ResourceName* GetStatusRequest::mutable_resource_names(int index) {
  // @@protoc_insertion_point(field_mutable:viam.robot.v1.GetStatusRequest.resource_names)
  return _impl_.resource_names_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::common::v1::ResourceName >*
GetStatusRequest::mutable_resource_names() {
  // @@protoc_insertion_point(field_mutable_list:viam.robot.v1.GetStatusRequest.resource_names)
  return &_impl_.resource_names_;
}
inline const ::viam::common::v1::ResourceName& GetStatusRequest::_internal_resource_names(int index) const {
  return _impl_.resource_names_.Get(index);
}
inline const ::viam::common::v1::ResourceName& GetStatusRequest::resource_names(int index) const {
  // @@protoc_insertion_point(field_get:viam.robot.v1.GetStatusRequest.resource_names)
  return _internal_resource_names(index);
}
inline ::viam::common::v1::ResourceName* GetStatusRequest::_internal_add_resource_names() {
  return _impl_.resource_names_.Add();
}
inline ::viam::common::v1::ResourceName* GetStatusRequest::add_resource_names() {
  ::viam::common::v1::ResourceName* _add = _internal_add_resource_names();
  // @@protoc_insertion_point(field_add:viam.robot.v1.GetStatusRequest.resource_names)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::common::v1::ResourceName >&
GetStatusRequest::resource_names() const {
  // @@protoc_insertion_point(field_list:viam.robot.v1.GetStatusRequest.resource_names)
  return _impl_.resource_names_;
}

// -------------------------------------------------------------------

// GetStatusResponse

// repeated .viam.robot.v1.Status status = 1 [json_name = "status"];
inline int GetStatusResponse::_internal_status_size() const {
  return _impl_.status_.size();
}
inline int GetStatusResponse::status_size() const {
  return _internal_status_size();
}
inline void GetStatusResponse::clear_status() {
  _impl_.status_.Clear();
}
inline ::viam::robot::v1::Status* GetStatusResponse::mutable_status(int index) {
  // @@protoc_insertion_point(field_mutable:viam.robot.v1.GetStatusResponse.status)
  return _impl_.status_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::robot::v1::Status >*
GetStatusResponse::mutable_status() {
  // @@protoc_insertion_point(field_mutable_list:viam.robot.v1.GetStatusResponse.status)
  return &_impl_.status_;
}
inline const ::viam::robot::v1::Status& GetStatusResponse::_internal_status(int index) const {
  return _impl_.status_.Get(index);
}
inline const ::viam::robot::v1::Status& GetStatusResponse::status(int index) const {
  // @@protoc_insertion_point(field_get:viam.robot.v1.GetStatusResponse.status)
  return _internal_status(index);
}
inline ::viam::robot::v1::Status* GetStatusResponse::_internal_add_status() {
  return _impl_.status_.Add();
}
inline ::viam::robot::v1::Status* GetStatusResponse::add_status() {
  ::viam::robot::v1::Status* _add = _internal_add_status();
  // @@protoc_insertion_point(field_add:viam.robot.v1.GetStatusResponse.status)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::robot::v1::Status >&
GetStatusResponse::status() const {
  // @@protoc_insertion_point(field_list:viam.robot.v1.GetStatusResponse.status)
  return _impl_.status_;
}

// -------------------------------------------------------------------

// StreamStatusRequest

// repeated .viam.common.v1.ResourceName resource_names = 1 [json_name = "resourceNames"];
inline int StreamStatusRequest::_internal_resource_names_size() const {
  return _impl_.resource_names_.size();
}
inline int StreamStatusRequest::resource_names_size() const {
  return _internal_resource_names_size();
}
inline ::viam::common::v1::ResourceName* StreamStatusRequest::mutable_resource_names(int index) {
  // @@protoc_insertion_point(field_mutable:viam.robot.v1.StreamStatusRequest.resource_names)
  return _impl_.resource_names_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::common::v1::ResourceName >*
StreamStatusRequest::mutable_resource_names() {
  // @@protoc_insertion_point(field_mutable_list:viam.robot.v1.StreamStatusRequest.resource_names)
  return &_impl_.resource_names_;
}
inline const ::viam::common::v1::ResourceName& StreamStatusRequest::_internal_resource_names(int index) const {
  return _impl_.resource_names_.Get(index);
}
inline const ::viam::common::v1::ResourceName& StreamStatusRequest::resource_names(int index) const {
  // @@protoc_insertion_point(field_get:viam.robot.v1.StreamStatusRequest.resource_names)
  return _internal_resource_names(index);
}
inline ::viam::common::v1::ResourceName* StreamStatusRequest::_internal_add_resource_names() {
  return _impl_.resource_names_.Add();
}
inline ::viam::common::v1::ResourceName* StreamStatusRequest::add_resource_names() {
  ::viam::common::v1::ResourceName* _add = _internal_add_resource_names();
  // @@protoc_insertion_point(field_add:viam.robot.v1.StreamStatusRequest.resource_names)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::common::v1::ResourceName >&
StreamStatusRequest::resource_names() const {
  // @@protoc_insertion_point(field_list:viam.robot.v1.StreamStatusRequest.resource_names)
  return _impl_.resource_names_;
}

// .google.protobuf.Duration every = 2 [json_name = "every"];
inline bool StreamStatusRequest::_internal_has_every() const {
  return this != internal_default_instance() && _impl_.every_ != nullptr;
}
inline bool StreamStatusRequest::has_every() const {
  return _internal_has_every();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& StreamStatusRequest::_internal_every() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = _impl_.every_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& StreamStatusRequest::every() const {
  // @@protoc_insertion_point(field_get:viam.robot.v1.StreamStatusRequest.every)
  return _internal_every();
}
inline void StreamStatusRequest::unsafe_arena_set_allocated_every(
    ::PROTOBUF_NAMESPACE_ID::Duration* every) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.every_);
  }
  _impl_.every_ = every;
  if (every) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.robot.v1.StreamStatusRequest.every)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* StreamStatusRequest::release_every() {
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.every_;
  _impl_.every_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* StreamStatusRequest::unsafe_arena_release_every() {
  // @@protoc_insertion_point(field_release:viam.robot.v1.StreamStatusRequest.every)
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.every_;
  _impl_.every_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* StreamStatusRequest::_internal_mutable_every() {
  
  if (_impl_.every_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    _impl_.every_ = p;
  }
  return _impl_.every_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* StreamStatusRequest::mutable_every() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_every();
  // @@protoc_insertion_point(field_mutable:viam.robot.v1.StreamStatusRequest.every)
  return _msg;
}
inline void StreamStatusRequest::set_allocated_every(::PROTOBUF_NAMESPACE_ID::Duration* every) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.every_);
  }
  if (every) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(every));
    if (message_arena != submessage_arena) {
      every = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, every, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.every_ = every;
  // @@protoc_insertion_point(field_set_allocated:viam.robot.v1.StreamStatusRequest.every)
}

// -------------------------------------------------------------------

// StreamStatusResponse

// repeated .viam.robot.v1.Status status = 1 [json_name = "status"];
inline int StreamStatusResponse::_internal_status_size() const {
  return _impl_.status_.size();
}
inline int StreamStatusResponse::status_size() const {
  return _internal_status_size();
}
inline void StreamStatusResponse::clear_status() {
  _impl_.status_.Clear();
}
inline ::viam::robot::v1::Status* StreamStatusResponse::mutable_status(int index) {
  // @@protoc_insertion_point(field_mutable:viam.robot.v1.StreamStatusResponse.status)
  return _impl_.status_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::robot::v1::Status >*
StreamStatusResponse::mutable_status() {
  // @@protoc_insertion_point(field_mutable_list:viam.robot.v1.StreamStatusResponse.status)
  return &_impl_.status_;
}
inline const ::viam::robot::v1::Status& StreamStatusResponse::_internal_status(int index) const {
  return _impl_.status_.Get(index);
}
inline const ::viam::robot::v1::Status& StreamStatusResponse::status(int index) const {
  // @@protoc_insertion_point(field_get:viam.robot.v1.StreamStatusResponse.status)
  return _internal_status(index);
}
inline ::viam::robot::v1::Status* StreamStatusResponse::_internal_add_status() {
  return _impl_.status_.Add();
}
inline ::viam::robot::v1::Status* StreamStatusResponse::add_status() {
  ::viam::robot::v1::Status* _add = _internal_add_status();
  // @@protoc_insertion_point(field_add:viam.robot.v1.StreamStatusResponse.status)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::robot::v1::Status >&
StreamStatusResponse::status() const {
  // @@protoc_insertion_point(field_list:viam.robot.v1.StreamStatusResponse.status)
  return _impl_.status_;
}

// -------------------------------------------------------------------

// StopExtraParameters

// .viam.common.v1.ResourceName name = 1 [json_name = "name"];
inline bool StopExtraParameters::_internal_has_name() const {
  return this != internal_default_instance() && _impl_.name_ != nullptr;
}
inline bool StopExtraParameters::has_name() const {
  return _internal_has_name();
}
inline const ::viam::common::v1::ResourceName& StopExtraParameters::_internal_name() const {
  const ::viam::common::v1::ResourceName* p = _impl_.name_;
  return p != nullptr ? *p : reinterpret_cast<const ::viam::common::v1::ResourceName&>(
      ::viam::common::v1::_ResourceName_default_instance_);
}
inline const ::viam::common::v1::ResourceName& StopExtraParameters::name() const {
  // @@protoc_insertion_point(field_get:viam.robot.v1.StopExtraParameters.name)
  return _internal_name();
}
inline void StopExtraParameters::unsafe_arena_set_allocated_name(
    ::viam::common::v1::ResourceName* name) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.name_);
  }
  _impl_.name_ = name;
  if (name) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.robot.v1.StopExtraParameters.name)
}
inline ::viam::common::v1::ResourceName* StopExtraParameters::release_name() {
  
  ::viam::common::v1::ResourceName* temp = _impl_.name_;
  _impl_.name_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::viam::common::v1::ResourceName* StopExtraParameters::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_release:viam.robot.v1.StopExtraParameters.name)
  
  ::viam::common::v1::ResourceName* temp = _impl_.name_;
  _impl_.name_ = nullptr;
  return temp;
}
inline ::viam::common::v1::ResourceName* StopExtraParameters::_internal_mutable_name() {
  
  if (_impl_.name_ == nullptr) {
    auto* p = CreateMaybeMessage<::viam::common::v1::ResourceName>(GetArenaForAllocation());
    _impl_.name_ = p;
  }
  return _impl_.name_;
}
inline ::viam::common::v1::ResourceName* StopExtraParameters::mutable_name() {
  ::viam::common::v1::ResourceName* _msg = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:viam.robot.v1.StopExtraParameters.name)
  return _msg;
}
inline void StopExtraParameters::set_allocated_name(::viam::common::v1::ResourceName* name) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.name_);
  }
  if (name) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(name));
    if (message_arena != submessage_arena) {
      name = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, name, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.name_ = name;
  // @@protoc_insertion_point(field_set_allocated:viam.robot.v1.StopExtraParameters.name)
}

// .google.protobuf.Struct params = 2 [json_name = "params"];
inline bool StopExtraParameters::_internal_has_params() const {
  return this != internal_default_instance() && _impl_.params_ != nullptr;
}
inline bool StopExtraParameters::has_params() const {
  return _internal_has_params();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& StopExtraParameters::_internal_params() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.params_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& StopExtraParameters::params() const {
  // @@protoc_insertion_point(field_get:viam.robot.v1.StopExtraParameters.params)
  return _internal_params();
}
inline void StopExtraParameters::unsafe_arena_set_allocated_params(
    ::PROTOBUF_NAMESPACE_ID::Struct* params) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.params_);
  }
  _impl_.params_ = params;
  if (params) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.robot.v1.StopExtraParameters.params)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* StopExtraParameters::release_params() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.params_;
  _impl_.params_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* StopExtraParameters::unsafe_arena_release_params() {
  // @@protoc_insertion_point(field_release:viam.robot.v1.StopExtraParameters.params)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.params_;
  _impl_.params_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* StopExtraParameters::_internal_mutable_params() {
  
  if (_impl_.params_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.params_ = p;
  }
  return _impl_.params_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* StopExtraParameters::mutable_params() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_params();
  // @@protoc_insertion_point(field_mutable:viam.robot.v1.StopExtraParameters.params)
  return _msg;
}
inline void StopExtraParameters::set_allocated_params(::PROTOBUF_NAMESPACE_ID::Struct* params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.params_);
  }
  if (params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(params));
    if (message_arena != submessage_arena) {
      params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, params, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.params_ = params;
  // @@protoc_insertion_point(field_set_allocated:viam.robot.v1.StopExtraParameters.params)
}

// -------------------------------------------------------------------

// StopAllRequest

// repeated .viam.robot.v1.StopExtraParameters extra = 99 [json_name = "extra"];
inline int StopAllRequest::_internal_extra_size() const {
  return _impl_.extra_.size();
}
inline int StopAllRequest::extra_size() const {
  return _internal_extra_size();
}
inline void StopAllRequest::clear_extra() {
  _impl_.extra_.Clear();
}
inline ::viam::robot::v1::StopExtraParameters* StopAllRequest::mutable_extra(int index) {
  // @@protoc_insertion_point(field_mutable:viam.robot.v1.StopAllRequest.extra)
  return _impl_.extra_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::robot::v1::StopExtraParameters >*
StopAllRequest::mutable_extra() {
  // @@protoc_insertion_point(field_mutable_list:viam.robot.v1.StopAllRequest.extra)
  return &_impl_.extra_;
}
inline const ::viam::robot::v1::StopExtraParameters& StopAllRequest::_internal_extra(int index) const {
  return _impl_.extra_.Get(index);
}
inline const ::viam::robot::v1::StopExtraParameters& StopAllRequest::extra(int index) const {
  // @@protoc_insertion_point(field_get:viam.robot.v1.StopAllRequest.extra)
  return _internal_extra(index);
}
inline ::viam::robot::v1::StopExtraParameters* StopAllRequest::_internal_add_extra() {
  return _impl_.extra_.Add();
}
inline ::viam::robot::v1::StopExtraParameters* StopAllRequest::add_extra() {
  ::viam::robot::v1::StopExtraParameters* _add = _internal_add_extra();
  // @@protoc_insertion_point(field_add:viam.robot.v1.StopAllRequest.extra)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::viam::robot::v1::StopExtraParameters >&
StopAllRequest::extra() const {
  // @@protoc_insertion_point(field_list:viam.robot.v1.StopAllRequest.extra)
  return _impl_.extra_;
}

// -------------------------------------------------------------------

// StopAllResponse

// -------------------------------------------------------------------

// StartSessionRequest

// string resume = 1 [json_name = "resume"];
inline void StartSessionRequest::clear_resume() {
  _impl_.resume_.ClearToEmpty();
}
inline const std::string& StartSessionRequest::resume() const {
  // @@protoc_insertion_point(field_get:viam.robot.v1.StartSessionRequest.resume)
  return _internal_resume();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StartSessionRequest::set_resume(ArgT0&& arg0, ArgT... args) {
 
 _impl_.resume_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.robot.v1.StartSessionRequest.resume)
}
inline std::string* StartSessionRequest::mutable_resume() {
  std::string* _s = _internal_mutable_resume();
  // @@protoc_insertion_point(field_mutable:viam.robot.v1.StartSessionRequest.resume)
  return _s;
}
inline const std::string& StartSessionRequest::_internal_resume() const {
  return _impl_.resume_.Get();
}
inline void StartSessionRequest::_internal_set_resume(const std::string& value) {
  
  _impl_.resume_.Set(value, GetArenaForAllocation());
}
inline std::string* StartSessionRequest::_internal_mutable_resume() {
  
  return _impl_.resume_.Mutable(GetArenaForAllocation());
}
inline std::string* StartSessionRequest::release_resume() {
  // @@protoc_insertion_point(field_release:viam.robot.v1.StartSessionRequest.resume)
  return _impl_.resume_.Release();
}
inline void StartSessionRequest::set_allocated_resume(std::string* resume) {
  if (resume != nullptr) {
    
  } else {
    
  }
  _impl_.resume_.SetAllocated(resume, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.resume_.IsDefault()) {
    _impl_.resume_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.robot.v1.StartSessionRequest.resume)
}

// -------------------------------------------------------------------

// StartSessionResponse

// string id = 1 [json_name = "id"];
inline void StartSessionResponse::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& StartSessionResponse::id() const {
  // @@protoc_insertion_point(field_get:viam.robot.v1.StartSessionResponse.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StartSessionResponse::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.robot.v1.StartSessionResponse.id)
}
inline std::string* StartSessionResponse::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.robot.v1.StartSessionResponse.id)
  return _s;
}
inline const std::string& StartSessionResponse::_internal_id() const {
  return _impl_.id_.Get();
}
inline void StartSessionResponse::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* StartSessionResponse::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* StartSessionResponse::release_id() {
  // @@protoc_insertion_point(field_release:viam.robot.v1.StartSessionResponse.id)
  return _impl_.id_.Release();
}
inline void StartSessionResponse::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.robot.v1.StartSessionResponse.id)
}

// .google.protobuf.Duration heartbeat_window = 2 [json_name = "heartbeatWindow"];
inline bool StartSessionResponse::_internal_has_heartbeat_window() const {
  return this != internal_default_instance() && _impl_.heartbeat_window_ != nullptr;
}
inline bool StartSessionResponse::has_heartbeat_window() const {
  return _internal_has_heartbeat_window();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& StartSessionResponse::_internal_heartbeat_window() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = _impl_.heartbeat_window_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& StartSessionResponse::heartbeat_window() const {
  // @@protoc_insertion_point(field_get:viam.robot.v1.StartSessionResponse.heartbeat_window)
  return _internal_heartbeat_window();
}
inline void StartSessionResponse::unsafe_arena_set_allocated_heartbeat_window(
    ::PROTOBUF_NAMESPACE_ID::Duration* heartbeat_window) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.heartbeat_window_);
  }
  _impl_.heartbeat_window_ = heartbeat_window;
  if (heartbeat_window) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:viam.robot.v1.StartSessionResponse.heartbeat_window)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* StartSessionResponse::release_heartbeat_window() {
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.heartbeat_window_;
  _impl_.heartbeat_window_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* StartSessionResponse::unsafe_arena_release_heartbeat_window() {
  // @@protoc_insertion_point(field_release:viam.robot.v1.StartSessionResponse.heartbeat_window)
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.heartbeat_window_;
  _impl_.heartbeat_window_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* StartSessionResponse::_internal_mutable_heartbeat_window() {
  
  if (_impl_.heartbeat_window_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    _impl_.heartbeat_window_ = p;
  }
  return _impl_.heartbeat_window_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* StartSessionResponse::mutable_heartbeat_window() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_heartbeat_window();
  // @@protoc_insertion_point(field_mutable:viam.robot.v1.StartSessionResponse.heartbeat_window)
  return _msg;
}
inline void StartSessionResponse::set_allocated_heartbeat_window(::PROTOBUF_NAMESPACE_ID::Duration* heartbeat_window) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.heartbeat_window_);
  }
  if (heartbeat_window) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(heartbeat_window));
    if (message_arena != submessage_arena) {
      heartbeat_window = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, heartbeat_window, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.heartbeat_window_ = heartbeat_window;
  // @@protoc_insertion_point(field_set_allocated:viam.robot.v1.StartSessionResponse.heartbeat_window)
}

// -------------------------------------------------------------------

// SendSessionHeartbeatRequest

// string id = 1 [json_name = "id"];
inline void SendSessionHeartbeatRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& SendSessionHeartbeatRequest::id() const {
  // @@protoc_insertion_point(field_get:viam.robot.v1.SendSessionHeartbeatRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SendSessionHeartbeatRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:viam.robot.v1.SendSessionHeartbeatRequest.id)
}
inline std::string* SendSessionHeartbeatRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:viam.robot.v1.SendSessionHeartbeatRequest.id)
  return _s;
}
inline const std::string& SendSessionHeartbeatRequest::_internal_id() const {
  return _impl_.id_.Get();
}
inline void SendSessionHeartbeatRequest::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* SendSessionHeartbeatRequest::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* SendSessionHeartbeatRequest::release_id() {
  // @@protoc_insertion_point(field_release:viam.robot.v1.SendSessionHeartbeatRequest.id)
  return _impl_.id_.Release();
}
inline void SendSessionHeartbeatRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:viam.robot.v1.SendSessionHeartbeatRequest.id)
}

// -------------------------------------------------------------------

// SendSessionHeartbeatResponse

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace robot
}  // namespace viam

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::viam::robot::v1::PeerConnectionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::viam::robot::v1::PeerConnectionType>() {
  return ::viam::robot::v1::PeerConnectionType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_robot_2fv1_2frobot_2eproto
