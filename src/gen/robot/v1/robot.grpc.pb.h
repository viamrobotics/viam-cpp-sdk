// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: robot/v1/robot.proto
#ifndef GRPC_robot_2fv1_2frobot_2eproto__INCLUDED
#define GRPC_robot_2fv1_2frobot_2eproto__INCLUDED

#include "robot/v1/robot.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace viam {
namespace robot {
namespace v1 {

// A RobotService encompasses all functionality of some robot comprised of parts, local and remote.
class RobotService final {
 public:
  static constexpr char const* service_full_name() {
    return "viam.robot.v1.RobotService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status GetOperations(::grpc::ClientContext* context, const ::viam::robot::v1::GetOperationsRequest& request, ::viam::robot::v1::GetOperationsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::GetOperationsResponse>> AsyncGetOperations(::grpc::ClientContext* context, const ::viam::robot::v1::GetOperationsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::GetOperationsResponse>>(AsyncGetOperationsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::GetOperationsResponse>> PrepareAsyncGetOperations(::grpc::ClientContext* context, const ::viam::robot::v1::GetOperationsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::GetOperationsResponse>>(PrepareAsyncGetOperationsRaw(context, request, cq));
    }
    virtual ::grpc::Status GetSessions(::grpc::ClientContext* context, const ::viam::robot::v1::GetSessionsRequest& request, ::viam::robot::v1::GetSessionsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::GetSessionsResponse>> AsyncGetSessions(::grpc::ClientContext* context, const ::viam::robot::v1::GetSessionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::GetSessionsResponse>>(AsyncGetSessionsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::GetSessionsResponse>> PrepareAsyncGetSessions(::grpc::ClientContext* context, const ::viam::robot::v1::GetSessionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::GetSessionsResponse>>(PrepareAsyncGetSessionsRaw(context, request, cq));
    }
    // ResourceNames returns the list of all resources.
    virtual ::grpc::Status ResourceNames(::grpc::ClientContext* context, const ::viam::robot::v1::ResourceNamesRequest& request, ::viam::robot::v1::ResourceNamesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::ResourceNamesResponse>> AsyncResourceNames(::grpc::ClientContext* context, const ::viam::robot::v1::ResourceNamesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::ResourceNamesResponse>>(AsyncResourceNamesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::ResourceNamesResponse>> PrepareAsyncResourceNames(::grpc::ClientContext* context, const ::viam::robot::v1::ResourceNamesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::ResourceNamesResponse>>(PrepareAsyncResourceNamesRaw(context, request, cq));
    }
    // ResourceRPCSubtypes returns the list of all resource types.
    virtual ::grpc::Status ResourceRPCSubtypes(::grpc::ClientContext* context, const ::viam::robot::v1::ResourceRPCSubtypesRequest& request, ::viam::robot::v1::ResourceRPCSubtypesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::ResourceRPCSubtypesResponse>> AsyncResourceRPCSubtypes(::grpc::ClientContext* context, const ::viam::robot::v1::ResourceRPCSubtypesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::ResourceRPCSubtypesResponse>>(AsyncResourceRPCSubtypesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::ResourceRPCSubtypesResponse>> PrepareAsyncResourceRPCSubtypes(::grpc::ClientContext* context, const ::viam::robot::v1::ResourceRPCSubtypesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::ResourceRPCSubtypesResponse>>(PrepareAsyncResourceRPCSubtypesRaw(context, request, cq));
    }
    virtual ::grpc::Status CancelOperation(::grpc::ClientContext* context, const ::viam::robot::v1::CancelOperationRequest& request, ::viam::robot::v1::CancelOperationResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::CancelOperationResponse>> AsyncCancelOperation(::grpc::ClientContext* context, const ::viam::robot::v1::CancelOperationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::CancelOperationResponse>>(AsyncCancelOperationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::CancelOperationResponse>> PrepareAsyncCancelOperation(::grpc::ClientContext* context, const ::viam::robot::v1::CancelOperationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::CancelOperationResponse>>(PrepareAsyncCancelOperationRaw(context, request, cq));
    }
    virtual ::grpc::Status BlockForOperation(::grpc::ClientContext* context, const ::viam::robot::v1::BlockForOperationRequest& request, ::viam::robot::v1::BlockForOperationResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::BlockForOperationResponse>> AsyncBlockForOperation(::grpc::ClientContext* context, const ::viam::robot::v1::BlockForOperationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::BlockForOperationResponse>>(AsyncBlockForOperationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::BlockForOperationResponse>> PrepareAsyncBlockForOperation(::grpc::ClientContext* context, const ::viam::robot::v1::BlockForOperationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::BlockForOperationResponse>>(PrepareAsyncBlockForOperationRaw(context, request, cq));
    }
    // DiscoverComponents returns the list of discovered component configurations.
    virtual ::grpc::Status DiscoverComponents(::grpc::ClientContext* context, const ::viam::robot::v1::DiscoverComponentsRequest& request, ::viam::robot::v1::DiscoverComponentsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::DiscoverComponentsResponse>> AsyncDiscoverComponents(::grpc::ClientContext* context, const ::viam::robot::v1::DiscoverComponentsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::DiscoverComponentsResponse>>(AsyncDiscoverComponentsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::DiscoverComponentsResponse>> PrepareAsyncDiscoverComponents(::grpc::ClientContext* context, const ::viam::robot::v1::DiscoverComponentsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::DiscoverComponentsResponse>>(PrepareAsyncDiscoverComponentsRaw(context, request, cq));
    }
    virtual ::grpc::Status FrameSystemConfig(::grpc::ClientContext* context, const ::viam::robot::v1::FrameSystemConfigRequest& request, ::viam::robot::v1::FrameSystemConfigResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::FrameSystemConfigResponse>> AsyncFrameSystemConfig(::grpc::ClientContext* context, const ::viam::robot::v1::FrameSystemConfigRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::FrameSystemConfigResponse>>(AsyncFrameSystemConfigRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::FrameSystemConfigResponse>> PrepareAsyncFrameSystemConfig(::grpc::ClientContext* context, const ::viam::robot::v1::FrameSystemConfigRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::FrameSystemConfigResponse>>(PrepareAsyncFrameSystemConfigRaw(context, request, cq));
    }
    virtual ::grpc::Status TransformPose(::grpc::ClientContext* context, const ::viam::robot::v1::TransformPoseRequest& request, ::viam::robot::v1::TransformPoseResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::TransformPoseResponse>> AsyncTransformPose(::grpc::ClientContext* context, const ::viam::robot::v1::TransformPoseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::TransformPoseResponse>>(AsyncTransformPoseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::TransformPoseResponse>> PrepareAsyncTransformPose(::grpc::ClientContext* context, const ::viam::robot::v1::TransformPoseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::TransformPoseResponse>>(PrepareAsyncTransformPoseRaw(context, request, cq));
    }
    // GetStatus returns the list of all statuses requested. An empty request signifies all resources.
    virtual ::grpc::Status GetStatus(::grpc::ClientContext* context, const ::viam::robot::v1::GetStatusRequest& request, ::viam::robot::v1::GetStatusResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::GetStatusResponse>> AsyncGetStatus(::grpc::ClientContext* context, const ::viam::robot::v1::GetStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::GetStatusResponse>>(AsyncGetStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::GetStatusResponse>> PrepareAsyncGetStatus(::grpc::ClientContext* context, const ::viam::robot::v1::GetStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::GetStatusResponse>>(PrepareAsyncGetStatusRaw(context, request, cq));
    }
    // StreamStatus periodically sends the status of all statuses requested. An empty request signifies all resources.
    std::unique_ptr< ::grpc::ClientReaderInterface< ::viam::robot::v1::StreamStatusResponse>> StreamStatus(::grpc::ClientContext* context, const ::viam::robot::v1::StreamStatusRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::viam::robot::v1::StreamStatusResponse>>(StreamStatusRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::viam::robot::v1::StreamStatusResponse>> AsyncStreamStatus(::grpc::ClientContext* context, const ::viam::robot::v1::StreamStatusRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::viam::robot::v1::StreamStatusResponse>>(AsyncStreamStatusRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::viam::robot::v1::StreamStatusResponse>> PrepareAsyncStreamStatus(::grpc::ClientContext* context, const ::viam::robot::v1::StreamStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::viam::robot::v1::StreamStatusResponse>>(PrepareAsyncStreamStatusRaw(context, request, cq));
    }
    // StopAll will stop all current and outstanding operations for the robot and stops all actuators and movement
    virtual ::grpc::Status StopAll(::grpc::ClientContext* context, const ::viam::robot::v1::StopAllRequest& request, ::viam::robot::v1::StopAllResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::StopAllResponse>> AsyncStopAll(::grpc::ClientContext* context, const ::viam::robot::v1::StopAllRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::StopAllResponse>>(AsyncStopAllRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::StopAllResponse>> PrepareAsyncStopAll(::grpc::ClientContext* context, const ::viam::robot::v1::StopAllRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::StopAllResponse>>(PrepareAsyncStopAllRaw(context, request, cq));
    }
    // StartSession creates a new session that expects at least one heartbeat within the returned window.
    // If the window lapses, any resources that have safety heart monitored methods, where this session was
    // the last caller on the resource, will be stopped.
    virtual ::grpc::Status StartSession(::grpc::ClientContext* context, const ::viam::robot::v1::StartSessionRequest& request, ::viam::robot::v1::StartSessionResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::StartSessionResponse>> AsyncStartSession(::grpc::ClientContext* context, const ::viam::robot::v1::StartSessionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::StartSessionResponse>>(AsyncStartSessionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::StartSessionResponse>> PrepareAsyncStartSession(::grpc::ClientContext* context, const ::viam::robot::v1::StartSessionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::StartSessionResponse>>(PrepareAsyncStartSessionRaw(context, request, cq));
    }
    // SendSessionHeartbeat sends a heartbeat to the given session. If the session has expired, a
    // SESSION_EXPIRED error will be returned.
    virtual ::grpc::Status SendSessionHeartbeat(::grpc::ClientContext* context, const ::viam::robot::v1::SendSessionHeartbeatRequest& request, ::viam::robot::v1::SendSessionHeartbeatResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::SendSessionHeartbeatResponse>> AsyncSendSessionHeartbeat(::grpc::ClientContext* context, const ::viam::robot::v1::SendSessionHeartbeatRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::SendSessionHeartbeatResponse>>(AsyncSendSessionHeartbeatRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::SendSessionHeartbeatResponse>> PrepareAsyncSendSessionHeartbeat(::grpc::ClientContext* context, const ::viam::robot::v1::SendSessionHeartbeatRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::SendSessionHeartbeatResponse>>(PrepareAsyncSendSessionHeartbeatRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      virtual void GetOperations(::grpc::ClientContext* context, const ::viam::robot::v1::GetOperationsRequest* request, ::viam::robot::v1::GetOperationsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetOperations(::grpc::ClientContext* context, const ::viam::robot::v1::GetOperationsRequest* request, ::viam::robot::v1::GetOperationsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetSessions(::grpc::ClientContext* context, const ::viam::robot::v1::GetSessionsRequest* request, ::viam::robot::v1::GetSessionsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetSessions(::grpc::ClientContext* context, const ::viam::robot::v1::GetSessionsRequest* request, ::viam::robot::v1::GetSessionsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // ResourceNames returns the list of all resources.
      virtual void ResourceNames(::grpc::ClientContext* context, const ::viam::robot::v1::ResourceNamesRequest* request, ::viam::robot::v1::ResourceNamesResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ResourceNames(::grpc::ClientContext* context, const ::viam::robot::v1::ResourceNamesRequest* request, ::viam::robot::v1::ResourceNamesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // ResourceRPCSubtypes returns the list of all resource types.
      virtual void ResourceRPCSubtypes(::grpc::ClientContext* context, const ::viam::robot::v1::ResourceRPCSubtypesRequest* request, ::viam::robot::v1::ResourceRPCSubtypesResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ResourceRPCSubtypes(::grpc::ClientContext* context, const ::viam::robot::v1::ResourceRPCSubtypesRequest* request, ::viam::robot::v1::ResourceRPCSubtypesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void CancelOperation(::grpc::ClientContext* context, const ::viam::robot::v1::CancelOperationRequest* request, ::viam::robot::v1::CancelOperationResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CancelOperation(::grpc::ClientContext* context, const ::viam::robot::v1::CancelOperationRequest* request, ::viam::robot::v1::CancelOperationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void BlockForOperation(::grpc::ClientContext* context, const ::viam::robot::v1::BlockForOperationRequest* request, ::viam::robot::v1::BlockForOperationResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void BlockForOperation(::grpc::ClientContext* context, const ::viam::robot::v1::BlockForOperationRequest* request, ::viam::robot::v1::BlockForOperationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // DiscoverComponents returns the list of discovered component configurations.
      virtual void DiscoverComponents(::grpc::ClientContext* context, const ::viam::robot::v1::DiscoverComponentsRequest* request, ::viam::robot::v1::DiscoverComponentsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DiscoverComponents(::grpc::ClientContext* context, const ::viam::robot::v1::DiscoverComponentsRequest* request, ::viam::robot::v1::DiscoverComponentsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void FrameSystemConfig(::grpc::ClientContext* context, const ::viam::robot::v1::FrameSystemConfigRequest* request, ::viam::robot::v1::FrameSystemConfigResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void FrameSystemConfig(::grpc::ClientContext* context, const ::viam::robot::v1::FrameSystemConfigRequest* request, ::viam::robot::v1::FrameSystemConfigResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void TransformPose(::grpc::ClientContext* context, const ::viam::robot::v1::TransformPoseRequest* request, ::viam::robot::v1::TransformPoseResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void TransformPose(::grpc::ClientContext* context, const ::viam::robot::v1::TransformPoseRequest* request, ::viam::robot::v1::TransformPoseResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // GetStatus returns the list of all statuses requested. An empty request signifies all resources.
      virtual void GetStatus(::grpc::ClientContext* context, const ::viam::robot::v1::GetStatusRequest* request, ::viam::robot::v1::GetStatusResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetStatus(::grpc::ClientContext* context, const ::viam::robot::v1::GetStatusRequest* request, ::viam::robot::v1::GetStatusResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // StreamStatus periodically sends the status of all statuses requested. An empty request signifies all resources.
      virtual void StreamStatus(::grpc::ClientContext* context, const ::viam::robot::v1::StreamStatusRequest* request, ::grpc::ClientReadReactor< ::viam::robot::v1::StreamStatusResponse>* reactor) = 0;
      // StopAll will stop all current and outstanding operations for the robot and stops all actuators and movement
      virtual void StopAll(::grpc::ClientContext* context, const ::viam::robot::v1::StopAllRequest* request, ::viam::robot::v1::StopAllResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StopAll(::grpc::ClientContext* context, const ::viam::robot::v1::StopAllRequest* request, ::viam::robot::v1::StopAllResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // StartSession creates a new session that expects at least one heartbeat within the returned window.
      // If the window lapses, any resources that have safety heart monitored methods, where this session was
      // the last caller on the resource, will be stopped.
      virtual void StartSession(::grpc::ClientContext* context, const ::viam::robot::v1::StartSessionRequest* request, ::viam::robot::v1::StartSessionResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StartSession(::grpc::ClientContext* context, const ::viam::robot::v1::StartSessionRequest* request, ::viam::robot::v1::StartSessionResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // SendSessionHeartbeat sends a heartbeat to the given session. If the session has expired, a
      // SESSION_EXPIRED error will be returned.
      virtual void SendSessionHeartbeat(::grpc::ClientContext* context, const ::viam::robot::v1::SendSessionHeartbeatRequest* request, ::viam::robot::v1::SendSessionHeartbeatResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SendSessionHeartbeat(::grpc::ClientContext* context, const ::viam::robot::v1::SendSessionHeartbeatRequest* request, ::viam::robot::v1::SendSessionHeartbeatResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::GetOperationsResponse>* AsyncGetOperationsRaw(::grpc::ClientContext* context, const ::viam::robot::v1::GetOperationsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::GetOperationsResponse>* PrepareAsyncGetOperationsRaw(::grpc::ClientContext* context, const ::viam::robot::v1::GetOperationsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::GetSessionsResponse>* AsyncGetSessionsRaw(::grpc::ClientContext* context, const ::viam::robot::v1::GetSessionsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::GetSessionsResponse>* PrepareAsyncGetSessionsRaw(::grpc::ClientContext* context, const ::viam::robot::v1::GetSessionsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::ResourceNamesResponse>* AsyncResourceNamesRaw(::grpc::ClientContext* context, const ::viam::robot::v1::ResourceNamesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::ResourceNamesResponse>* PrepareAsyncResourceNamesRaw(::grpc::ClientContext* context, const ::viam::robot::v1::ResourceNamesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::ResourceRPCSubtypesResponse>* AsyncResourceRPCSubtypesRaw(::grpc::ClientContext* context, const ::viam::robot::v1::ResourceRPCSubtypesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::ResourceRPCSubtypesResponse>* PrepareAsyncResourceRPCSubtypesRaw(::grpc::ClientContext* context, const ::viam::robot::v1::ResourceRPCSubtypesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::CancelOperationResponse>* AsyncCancelOperationRaw(::grpc::ClientContext* context, const ::viam::robot::v1::CancelOperationRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::CancelOperationResponse>* PrepareAsyncCancelOperationRaw(::grpc::ClientContext* context, const ::viam::robot::v1::CancelOperationRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::BlockForOperationResponse>* AsyncBlockForOperationRaw(::grpc::ClientContext* context, const ::viam::robot::v1::BlockForOperationRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::BlockForOperationResponse>* PrepareAsyncBlockForOperationRaw(::grpc::ClientContext* context, const ::viam::robot::v1::BlockForOperationRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::DiscoverComponentsResponse>* AsyncDiscoverComponentsRaw(::grpc::ClientContext* context, const ::viam::robot::v1::DiscoverComponentsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::DiscoverComponentsResponse>* PrepareAsyncDiscoverComponentsRaw(::grpc::ClientContext* context, const ::viam::robot::v1::DiscoverComponentsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::FrameSystemConfigResponse>* AsyncFrameSystemConfigRaw(::grpc::ClientContext* context, const ::viam::robot::v1::FrameSystemConfigRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::FrameSystemConfigResponse>* PrepareAsyncFrameSystemConfigRaw(::grpc::ClientContext* context, const ::viam::robot::v1::FrameSystemConfigRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::TransformPoseResponse>* AsyncTransformPoseRaw(::grpc::ClientContext* context, const ::viam::robot::v1::TransformPoseRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::TransformPoseResponse>* PrepareAsyncTransformPoseRaw(::grpc::ClientContext* context, const ::viam::robot::v1::TransformPoseRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::GetStatusResponse>* AsyncGetStatusRaw(::grpc::ClientContext* context, const ::viam::robot::v1::GetStatusRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::GetStatusResponse>* PrepareAsyncGetStatusRaw(::grpc::ClientContext* context, const ::viam::robot::v1::GetStatusRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::viam::robot::v1::StreamStatusResponse>* StreamStatusRaw(::grpc::ClientContext* context, const ::viam::robot::v1::StreamStatusRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::viam::robot::v1::StreamStatusResponse>* AsyncStreamStatusRaw(::grpc::ClientContext* context, const ::viam::robot::v1::StreamStatusRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::viam::robot::v1::StreamStatusResponse>* PrepareAsyncStreamStatusRaw(::grpc::ClientContext* context, const ::viam::robot::v1::StreamStatusRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::StopAllResponse>* AsyncStopAllRaw(::grpc::ClientContext* context, const ::viam::robot::v1::StopAllRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::StopAllResponse>* PrepareAsyncStopAllRaw(::grpc::ClientContext* context, const ::viam::robot::v1::StopAllRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::StartSessionResponse>* AsyncStartSessionRaw(::grpc::ClientContext* context, const ::viam::robot::v1::StartSessionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::StartSessionResponse>* PrepareAsyncStartSessionRaw(::grpc::ClientContext* context, const ::viam::robot::v1::StartSessionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::SendSessionHeartbeatResponse>* AsyncSendSessionHeartbeatRaw(::grpc::ClientContext* context, const ::viam::robot::v1::SendSessionHeartbeatRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::viam::robot::v1::SendSessionHeartbeatResponse>* PrepareAsyncSendSessionHeartbeatRaw(::grpc::ClientContext* context, const ::viam::robot::v1::SendSessionHeartbeatRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status GetOperations(::grpc::ClientContext* context, const ::viam::robot::v1::GetOperationsRequest& request, ::viam::robot::v1::GetOperationsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::GetOperationsResponse>> AsyncGetOperations(::grpc::ClientContext* context, const ::viam::robot::v1::GetOperationsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::GetOperationsResponse>>(AsyncGetOperationsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::GetOperationsResponse>> PrepareAsyncGetOperations(::grpc::ClientContext* context, const ::viam::robot::v1::GetOperationsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::GetOperationsResponse>>(PrepareAsyncGetOperationsRaw(context, request, cq));
    }
    ::grpc::Status GetSessions(::grpc::ClientContext* context, const ::viam::robot::v1::GetSessionsRequest& request, ::viam::robot::v1::GetSessionsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::GetSessionsResponse>> AsyncGetSessions(::grpc::ClientContext* context, const ::viam::robot::v1::GetSessionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::GetSessionsResponse>>(AsyncGetSessionsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::GetSessionsResponse>> PrepareAsyncGetSessions(::grpc::ClientContext* context, const ::viam::robot::v1::GetSessionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::GetSessionsResponse>>(PrepareAsyncGetSessionsRaw(context, request, cq));
    }
    ::grpc::Status ResourceNames(::grpc::ClientContext* context, const ::viam::robot::v1::ResourceNamesRequest& request, ::viam::robot::v1::ResourceNamesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::ResourceNamesResponse>> AsyncResourceNames(::grpc::ClientContext* context, const ::viam::robot::v1::ResourceNamesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::ResourceNamesResponse>>(AsyncResourceNamesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::ResourceNamesResponse>> PrepareAsyncResourceNames(::grpc::ClientContext* context, const ::viam::robot::v1::ResourceNamesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::ResourceNamesResponse>>(PrepareAsyncResourceNamesRaw(context, request, cq));
    }
    ::grpc::Status ResourceRPCSubtypes(::grpc::ClientContext* context, const ::viam::robot::v1::ResourceRPCSubtypesRequest& request, ::viam::robot::v1::ResourceRPCSubtypesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::ResourceRPCSubtypesResponse>> AsyncResourceRPCSubtypes(::grpc::ClientContext* context, const ::viam::robot::v1::ResourceRPCSubtypesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::ResourceRPCSubtypesResponse>>(AsyncResourceRPCSubtypesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::ResourceRPCSubtypesResponse>> PrepareAsyncResourceRPCSubtypes(::grpc::ClientContext* context, const ::viam::robot::v1::ResourceRPCSubtypesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::ResourceRPCSubtypesResponse>>(PrepareAsyncResourceRPCSubtypesRaw(context, request, cq));
    }
    ::grpc::Status CancelOperation(::grpc::ClientContext* context, const ::viam::robot::v1::CancelOperationRequest& request, ::viam::robot::v1::CancelOperationResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::CancelOperationResponse>> AsyncCancelOperation(::grpc::ClientContext* context, const ::viam::robot::v1::CancelOperationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::CancelOperationResponse>>(AsyncCancelOperationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::CancelOperationResponse>> PrepareAsyncCancelOperation(::grpc::ClientContext* context, const ::viam::robot::v1::CancelOperationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::CancelOperationResponse>>(PrepareAsyncCancelOperationRaw(context, request, cq));
    }
    ::grpc::Status BlockForOperation(::grpc::ClientContext* context, const ::viam::robot::v1::BlockForOperationRequest& request, ::viam::robot::v1::BlockForOperationResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::BlockForOperationResponse>> AsyncBlockForOperation(::grpc::ClientContext* context, const ::viam::robot::v1::BlockForOperationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::BlockForOperationResponse>>(AsyncBlockForOperationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::BlockForOperationResponse>> PrepareAsyncBlockForOperation(::grpc::ClientContext* context, const ::viam::robot::v1::BlockForOperationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::BlockForOperationResponse>>(PrepareAsyncBlockForOperationRaw(context, request, cq));
    }
    ::grpc::Status DiscoverComponents(::grpc::ClientContext* context, const ::viam::robot::v1::DiscoverComponentsRequest& request, ::viam::robot::v1::DiscoverComponentsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::DiscoverComponentsResponse>> AsyncDiscoverComponents(::grpc::ClientContext* context, const ::viam::robot::v1::DiscoverComponentsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::DiscoverComponentsResponse>>(AsyncDiscoverComponentsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::DiscoverComponentsResponse>> PrepareAsyncDiscoverComponents(::grpc::ClientContext* context, const ::viam::robot::v1::DiscoverComponentsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::DiscoverComponentsResponse>>(PrepareAsyncDiscoverComponentsRaw(context, request, cq));
    }
    ::grpc::Status FrameSystemConfig(::grpc::ClientContext* context, const ::viam::robot::v1::FrameSystemConfigRequest& request, ::viam::robot::v1::FrameSystemConfigResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::FrameSystemConfigResponse>> AsyncFrameSystemConfig(::grpc::ClientContext* context, const ::viam::robot::v1::FrameSystemConfigRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::FrameSystemConfigResponse>>(AsyncFrameSystemConfigRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::FrameSystemConfigResponse>> PrepareAsyncFrameSystemConfig(::grpc::ClientContext* context, const ::viam::robot::v1::FrameSystemConfigRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::FrameSystemConfigResponse>>(PrepareAsyncFrameSystemConfigRaw(context, request, cq));
    }
    ::grpc::Status TransformPose(::grpc::ClientContext* context, const ::viam::robot::v1::TransformPoseRequest& request, ::viam::robot::v1::TransformPoseResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::TransformPoseResponse>> AsyncTransformPose(::grpc::ClientContext* context, const ::viam::robot::v1::TransformPoseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::TransformPoseResponse>>(AsyncTransformPoseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::TransformPoseResponse>> PrepareAsyncTransformPose(::grpc::ClientContext* context, const ::viam::robot::v1::TransformPoseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::TransformPoseResponse>>(PrepareAsyncTransformPoseRaw(context, request, cq));
    }
    ::grpc::Status GetStatus(::grpc::ClientContext* context, const ::viam::robot::v1::GetStatusRequest& request, ::viam::robot::v1::GetStatusResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::GetStatusResponse>> AsyncGetStatus(::grpc::ClientContext* context, const ::viam::robot::v1::GetStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::GetStatusResponse>>(AsyncGetStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::GetStatusResponse>> PrepareAsyncGetStatus(::grpc::ClientContext* context, const ::viam::robot::v1::GetStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::GetStatusResponse>>(PrepareAsyncGetStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::viam::robot::v1::StreamStatusResponse>> StreamStatus(::grpc::ClientContext* context, const ::viam::robot::v1::StreamStatusRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::viam::robot::v1::StreamStatusResponse>>(StreamStatusRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::viam::robot::v1::StreamStatusResponse>> AsyncStreamStatus(::grpc::ClientContext* context, const ::viam::robot::v1::StreamStatusRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::viam::robot::v1::StreamStatusResponse>>(AsyncStreamStatusRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::viam::robot::v1::StreamStatusResponse>> PrepareAsyncStreamStatus(::grpc::ClientContext* context, const ::viam::robot::v1::StreamStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::viam::robot::v1::StreamStatusResponse>>(PrepareAsyncStreamStatusRaw(context, request, cq));
    }
    ::grpc::Status StopAll(::grpc::ClientContext* context, const ::viam::robot::v1::StopAllRequest& request, ::viam::robot::v1::StopAllResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::StopAllResponse>> AsyncStopAll(::grpc::ClientContext* context, const ::viam::robot::v1::StopAllRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::StopAllResponse>>(AsyncStopAllRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::StopAllResponse>> PrepareAsyncStopAll(::grpc::ClientContext* context, const ::viam::robot::v1::StopAllRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::StopAllResponse>>(PrepareAsyncStopAllRaw(context, request, cq));
    }
    ::grpc::Status StartSession(::grpc::ClientContext* context, const ::viam::robot::v1::StartSessionRequest& request, ::viam::robot::v1::StartSessionResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::StartSessionResponse>> AsyncStartSession(::grpc::ClientContext* context, const ::viam::robot::v1::StartSessionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::StartSessionResponse>>(AsyncStartSessionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::StartSessionResponse>> PrepareAsyncStartSession(::grpc::ClientContext* context, const ::viam::robot::v1::StartSessionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::StartSessionResponse>>(PrepareAsyncStartSessionRaw(context, request, cq));
    }
    ::grpc::Status SendSessionHeartbeat(::grpc::ClientContext* context, const ::viam::robot::v1::SendSessionHeartbeatRequest& request, ::viam::robot::v1::SendSessionHeartbeatResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::SendSessionHeartbeatResponse>> AsyncSendSessionHeartbeat(::grpc::ClientContext* context, const ::viam::robot::v1::SendSessionHeartbeatRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::SendSessionHeartbeatResponse>>(AsyncSendSessionHeartbeatRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::SendSessionHeartbeatResponse>> PrepareAsyncSendSessionHeartbeat(::grpc::ClientContext* context, const ::viam::robot::v1::SendSessionHeartbeatRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::SendSessionHeartbeatResponse>>(PrepareAsyncSendSessionHeartbeatRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void GetOperations(::grpc::ClientContext* context, const ::viam::robot::v1::GetOperationsRequest* request, ::viam::robot::v1::GetOperationsResponse* response, std::function<void(::grpc::Status)>) override;
      void GetOperations(::grpc::ClientContext* context, const ::viam::robot::v1::GetOperationsRequest* request, ::viam::robot::v1::GetOperationsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetSessions(::grpc::ClientContext* context, const ::viam::robot::v1::GetSessionsRequest* request, ::viam::robot::v1::GetSessionsResponse* response, std::function<void(::grpc::Status)>) override;
      void GetSessions(::grpc::ClientContext* context, const ::viam::robot::v1::GetSessionsRequest* request, ::viam::robot::v1::GetSessionsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ResourceNames(::grpc::ClientContext* context, const ::viam::robot::v1::ResourceNamesRequest* request, ::viam::robot::v1::ResourceNamesResponse* response, std::function<void(::grpc::Status)>) override;
      void ResourceNames(::grpc::ClientContext* context, const ::viam::robot::v1::ResourceNamesRequest* request, ::viam::robot::v1::ResourceNamesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ResourceRPCSubtypes(::grpc::ClientContext* context, const ::viam::robot::v1::ResourceRPCSubtypesRequest* request, ::viam::robot::v1::ResourceRPCSubtypesResponse* response, std::function<void(::grpc::Status)>) override;
      void ResourceRPCSubtypes(::grpc::ClientContext* context, const ::viam::robot::v1::ResourceRPCSubtypesRequest* request, ::viam::robot::v1::ResourceRPCSubtypesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void CancelOperation(::grpc::ClientContext* context, const ::viam::robot::v1::CancelOperationRequest* request, ::viam::robot::v1::CancelOperationResponse* response, std::function<void(::grpc::Status)>) override;
      void CancelOperation(::grpc::ClientContext* context, const ::viam::robot::v1::CancelOperationRequest* request, ::viam::robot::v1::CancelOperationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void BlockForOperation(::grpc::ClientContext* context, const ::viam::robot::v1::BlockForOperationRequest* request, ::viam::robot::v1::BlockForOperationResponse* response, std::function<void(::grpc::Status)>) override;
      void BlockForOperation(::grpc::ClientContext* context, const ::viam::robot::v1::BlockForOperationRequest* request, ::viam::robot::v1::BlockForOperationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void DiscoverComponents(::grpc::ClientContext* context, const ::viam::robot::v1::DiscoverComponentsRequest* request, ::viam::robot::v1::DiscoverComponentsResponse* response, std::function<void(::grpc::Status)>) override;
      void DiscoverComponents(::grpc::ClientContext* context, const ::viam::robot::v1::DiscoverComponentsRequest* request, ::viam::robot::v1::DiscoverComponentsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void FrameSystemConfig(::grpc::ClientContext* context, const ::viam::robot::v1::FrameSystemConfigRequest* request, ::viam::robot::v1::FrameSystemConfigResponse* response, std::function<void(::grpc::Status)>) override;
      void FrameSystemConfig(::grpc::ClientContext* context, const ::viam::robot::v1::FrameSystemConfigRequest* request, ::viam::robot::v1::FrameSystemConfigResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void TransformPose(::grpc::ClientContext* context, const ::viam::robot::v1::TransformPoseRequest* request, ::viam::robot::v1::TransformPoseResponse* response, std::function<void(::grpc::Status)>) override;
      void TransformPose(::grpc::ClientContext* context, const ::viam::robot::v1::TransformPoseRequest* request, ::viam::robot::v1::TransformPoseResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetStatus(::grpc::ClientContext* context, const ::viam::robot::v1::GetStatusRequest* request, ::viam::robot::v1::GetStatusResponse* response, std::function<void(::grpc::Status)>) override;
      void GetStatus(::grpc::ClientContext* context, const ::viam::robot::v1::GetStatusRequest* request, ::viam::robot::v1::GetStatusResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void StreamStatus(::grpc::ClientContext* context, const ::viam::robot::v1::StreamStatusRequest* request, ::grpc::ClientReadReactor< ::viam::robot::v1::StreamStatusResponse>* reactor) override;
      void StopAll(::grpc::ClientContext* context, const ::viam::robot::v1::StopAllRequest* request, ::viam::robot::v1::StopAllResponse* response, std::function<void(::grpc::Status)>) override;
      void StopAll(::grpc::ClientContext* context, const ::viam::robot::v1::StopAllRequest* request, ::viam::robot::v1::StopAllResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void StartSession(::grpc::ClientContext* context, const ::viam::robot::v1::StartSessionRequest* request, ::viam::robot::v1::StartSessionResponse* response, std::function<void(::grpc::Status)>) override;
      void StartSession(::grpc::ClientContext* context, const ::viam::robot::v1::StartSessionRequest* request, ::viam::robot::v1::StartSessionResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SendSessionHeartbeat(::grpc::ClientContext* context, const ::viam::robot::v1::SendSessionHeartbeatRequest* request, ::viam::robot::v1::SendSessionHeartbeatResponse* response, std::function<void(::grpc::Status)>) override;
      void SendSessionHeartbeat(::grpc::ClientContext* context, const ::viam::robot::v1::SendSessionHeartbeatRequest* request, ::viam::robot::v1::SendSessionHeartbeatResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::GetOperationsResponse>* AsyncGetOperationsRaw(::grpc::ClientContext* context, const ::viam::robot::v1::GetOperationsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::GetOperationsResponse>* PrepareAsyncGetOperationsRaw(::grpc::ClientContext* context, const ::viam::robot::v1::GetOperationsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::GetSessionsResponse>* AsyncGetSessionsRaw(::grpc::ClientContext* context, const ::viam::robot::v1::GetSessionsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::GetSessionsResponse>* PrepareAsyncGetSessionsRaw(::grpc::ClientContext* context, const ::viam::robot::v1::GetSessionsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::ResourceNamesResponse>* AsyncResourceNamesRaw(::grpc::ClientContext* context, const ::viam::robot::v1::ResourceNamesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::ResourceNamesResponse>* PrepareAsyncResourceNamesRaw(::grpc::ClientContext* context, const ::viam::robot::v1::ResourceNamesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::ResourceRPCSubtypesResponse>* AsyncResourceRPCSubtypesRaw(::grpc::ClientContext* context, const ::viam::robot::v1::ResourceRPCSubtypesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::ResourceRPCSubtypesResponse>* PrepareAsyncResourceRPCSubtypesRaw(::grpc::ClientContext* context, const ::viam::robot::v1::ResourceRPCSubtypesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::CancelOperationResponse>* AsyncCancelOperationRaw(::grpc::ClientContext* context, const ::viam::robot::v1::CancelOperationRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::CancelOperationResponse>* PrepareAsyncCancelOperationRaw(::grpc::ClientContext* context, const ::viam::robot::v1::CancelOperationRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::BlockForOperationResponse>* AsyncBlockForOperationRaw(::grpc::ClientContext* context, const ::viam::robot::v1::BlockForOperationRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::BlockForOperationResponse>* PrepareAsyncBlockForOperationRaw(::grpc::ClientContext* context, const ::viam::robot::v1::BlockForOperationRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::DiscoverComponentsResponse>* AsyncDiscoverComponentsRaw(::grpc::ClientContext* context, const ::viam::robot::v1::DiscoverComponentsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::DiscoverComponentsResponse>* PrepareAsyncDiscoverComponentsRaw(::grpc::ClientContext* context, const ::viam::robot::v1::DiscoverComponentsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::FrameSystemConfigResponse>* AsyncFrameSystemConfigRaw(::grpc::ClientContext* context, const ::viam::robot::v1::FrameSystemConfigRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::FrameSystemConfigResponse>* PrepareAsyncFrameSystemConfigRaw(::grpc::ClientContext* context, const ::viam::robot::v1::FrameSystemConfigRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::TransformPoseResponse>* AsyncTransformPoseRaw(::grpc::ClientContext* context, const ::viam::robot::v1::TransformPoseRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::TransformPoseResponse>* PrepareAsyncTransformPoseRaw(::grpc::ClientContext* context, const ::viam::robot::v1::TransformPoseRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::GetStatusResponse>* AsyncGetStatusRaw(::grpc::ClientContext* context, const ::viam::robot::v1::GetStatusRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::GetStatusResponse>* PrepareAsyncGetStatusRaw(::grpc::ClientContext* context, const ::viam::robot::v1::GetStatusRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::viam::robot::v1::StreamStatusResponse>* StreamStatusRaw(::grpc::ClientContext* context, const ::viam::robot::v1::StreamStatusRequest& request) override;
    ::grpc::ClientAsyncReader< ::viam::robot::v1::StreamStatusResponse>* AsyncStreamStatusRaw(::grpc::ClientContext* context, const ::viam::robot::v1::StreamStatusRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::viam::robot::v1::StreamStatusResponse>* PrepareAsyncStreamStatusRaw(::grpc::ClientContext* context, const ::viam::robot::v1::StreamStatusRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::StopAllResponse>* AsyncStopAllRaw(::grpc::ClientContext* context, const ::viam::robot::v1::StopAllRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::StopAllResponse>* PrepareAsyncStopAllRaw(::grpc::ClientContext* context, const ::viam::robot::v1::StopAllRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::StartSessionResponse>* AsyncStartSessionRaw(::grpc::ClientContext* context, const ::viam::robot::v1::StartSessionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::StartSessionResponse>* PrepareAsyncStartSessionRaw(::grpc::ClientContext* context, const ::viam::robot::v1::StartSessionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::SendSessionHeartbeatResponse>* AsyncSendSessionHeartbeatRaw(::grpc::ClientContext* context, const ::viam::robot::v1::SendSessionHeartbeatRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::viam::robot::v1::SendSessionHeartbeatResponse>* PrepareAsyncSendSessionHeartbeatRaw(::grpc::ClientContext* context, const ::viam::robot::v1::SendSessionHeartbeatRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_GetOperations_;
    const ::grpc::internal::RpcMethod rpcmethod_GetSessions_;
    const ::grpc::internal::RpcMethod rpcmethod_ResourceNames_;
    const ::grpc::internal::RpcMethod rpcmethod_ResourceRPCSubtypes_;
    const ::grpc::internal::RpcMethod rpcmethod_CancelOperation_;
    const ::grpc::internal::RpcMethod rpcmethod_BlockForOperation_;
    const ::grpc::internal::RpcMethod rpcmethod_DiscoverComponents_;
    const ::grpc::internal::RpcMethod rpcmethod_FrameSystemConfig_;
    const ::grpc::internal::RpcMethod rpcmethod_TransformPose_;
    const ::grpc::internal::RpcMethod rpcmethod_GetStatus_;
    const ::grpc::internal::RpcMethod rpcmethod_StreamStatus_;
    const ::grpc::internal::RpcMethod rpcmethod_StopAll_;
    const ::grpc::internal::RpcMethod rpcmethod_StartSession_;
    const ::grpc::internal::RpcMethod rpcmethod_SendSessionHeartbeat_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status GetOperations(::grpc::ServerContext* context, const ::viam::robot::v1::GetOperationsRequest* request, ::viam::robot::v1::GetOperationsResponse* response);
    virtual ::grpc::Status GetSessions(::grpc::ServerContext* context, const ::viam::robot::v1::GetSessionsRequest* request, ::viam::robot::v1::GetSessionsResponse* response);
    // ResourceNames returns the list of all resources.
    virtual ::grpc::Status ResourceNames(::grpc::ServerContext* context, const ::viam::robot::v1::ResourceNamesRequest* request, ::viam::robot::v1::ResourceNamesResponse* response);
    // ResourceRPCSubtypes returns the list of all resource types.
    virtual ::grpc::Status ResourceRPCSubtypes(::grpc::ServerContext* context, const ::viam::robot::v1::ResourceRPCSubtypesRequest* request, ::viam::robot::v1::ResourceRPCSubtypesResponse* response);
    virtual ::grpc::Status CancelOperation(::grpc::ServerContext* context, const ::viam::robot::v1::CancelOperationRequest* request, ::viam::robot::v1::CancelOperationResponse* response);
    virtual ::grpc::Status BlockForOperation(::grpc::ServerContext* context, const ::viam::robot::v1::BlockForOperationRequest* request, ::viam::robot::v1::BlockForOperationResponse* response);
    // DiscoverComponents returns the list of discovered component configurations.
    virtual ::grpc::Status DiscoverComponents(::grpc::ServerContext* context, const ::viam::robot::v1::DiscoverComponentsRequest* request, ::viam::robot::v1::DiscoverComponentsResponse* response);
    virtual ::grpc::Status FrameSystemConfig(::grpc::ServerContext* context, const ::viam::robot::v1::FrameSystemConfigRequest* request, ::viam::robot::v1::FrameSystemConfigResponse* response);
    virtual ::grpc::Status TransformPose(::grpc::ServerContext* context, const ::viam::robot::v1::TransformPoseRequest* request, ::viam::robot::v1::TransformPoseResponse* response);
    // GetStatus returns the list of all statuses requested. An empty request signifies all resources.
    virtual ::grpc::Status GetStatus(::grpc::ServerContext* context, const ::viam::robot::v1::GetStatusRequest* request, ::viam::robot::v1::GetStatusResponse* response);
    // StreamStatus periodically sends the status of all statuses requested. An empty request signifies all resources.
    virtual ::grpc::Status StreamStatus(::grpc::ServerContext* context, const ::viam::robot::v1::StreamStatusRequest* request, ::grpc::ServerWriter< ::viam::robot::v1::StreamStatusResponse>* writer);
    // StopAll will stop all current and outstanding operations for the robot and stops all actuators and movement
    virtual ::grpc::Status StopAll(::grpc::ServerContext* context, const ::viam::robot::v1::StopAllRequest* request, ::viam::robot::v1::StopAllResponse* response);
    // StartSession creates a new session that expects at least one heartbeat within the returned window.
    // If the window lapses, any resources that have safety heart monitored methods, where this session was
    // the last caller on the resource, will be stopped.
    virtual ::grpc::Status StartSession(::grpc::ServerContext* context, const ::viam::robot::v1::StartSessionRequest* request, ::viam::robot::v1::StartSessionResponse* response);
    // SendSessionHeartbeat sends a heartbeat to the given session. If the session has expired, a
    // SESSION_EXPIRED error will be returned.
    virtual ::grpc::Status SendSessionHeartbeat(::grpc::ServerContext* context, const ::viam::robot::v1::SendSessionHeartbeatRequest* request, ::viam::robot::v1::SendSessionHeartbeatResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_GetOperations : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetOperations() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_GetOperations() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetOperations(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::GetOperationsRequest* /*request*/, ::viam::robot::v1::GetOperationsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetOperations(::grpc::ServerContext* context, ::viam::robot::v1::GetOperationsRequest* request, ::grpc::ServerAsyncResponseWriter< ::viam::robot::v1::GetOperationsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetSessions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetSessions() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_GetSessions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSessions(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::GetSessionsRequest* /*request*/, ::viam::robot::v1::GetSessionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSessions(::grpc::ServerContext* context, ::viam::robot::v1::GetSessionsRequest* request, ::grpc::ServerAsyncResponseWriter< ::viam::robot::v1::GetSessionsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ResourceNames : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ResourceNames() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_ResourceNames() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResourceNames(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::ResourceNamesRequest* /*request*/, ::viam::robot::v1::ResourceNamesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestResourceNames(::grpc::ServerContext* context, ::viam::robot::v1::ResourceNamesRequest* request, ::grpc::ServerAsyncResponseWriter< ::viam::robot::v1::ResourceNamesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ResourceRPCSubtypes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ResourceRPCSubtypes() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_ResourceRPCSubtypes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResourceRPCSubtypes(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::ResourceRPCSubtypesRequest* /*request*/, ::viam::robot::v1::ResourceRPCSubtypesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestResourceRPCSubtypes(::grpc::ServerContext* context, ::viam::robot::v1::ResourceRPCSubtypesRequest* request, ::grpc::ServerAsyncResponseWriter< ::viam::robot::v1::ResourceRPCSubtypesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CancelOperation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CancelOperation() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_CancelOperation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CancelOperation(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::CancelOperationRequest* /*request*/, ::viam::robot::v1::CancelOperationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCancelOperation(::grpc::ServerContext* context, ::viam::robot::v1::CancelOperationRequest* request, ::grpc::ServerAsyncResponseWriter< ::viam::robot::v1::CancelOperationResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_BlockForOperation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_BlockForOperation() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_BlockForOperation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BlockForOperation(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::BlockForOperationRequest* /*request*/, ::viam::robot::v1::BlockForOperationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBlockForOperation(::grpc::ServerContext* context, ::viam::robot::v1::BlockForOperationRequest* request, ::grpc::ServerAsyncResponseWriter< ::viam::robot::v1::BlockForOperationResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DiscoverComponents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DiscoverComponents() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_DiscoverComponents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DiscoverComponents(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::DiscoverComponentsRequest* /*request*/, ::viam::robot::v1::DiscoverComponentsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDiscoverComponents(::grpc::ServerContext* context, ::viam::robot::v1::DiscoverComponentsRequest* request, ::grpc::ServerAsyncResponseWriter< ::viam::robot::v1::DiscoverComponentsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_FrameSystemConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_FrameSystemConfig() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_FrameSystemConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrameSystemConfig(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::FrameSystemConfigRequest* /*request*/, ::viam::robot::v1::FrameSystemConfigResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFrameSystemConfig(::grpc::ServerContext* context, ::viam::robot::v1::FrameSystemConfigRequest* request, ::grpc::ServerAsyncResponseWriter< ::viam::robot::v1::FrameSystemConfigResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_TransformPose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_TransformPose() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_TransformPose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TransformPose(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::TransformPoseRequest* /*request*/, ::viam::robot::v1::TransformPoseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTransformPose(::grpc::ServerContext* context, ::viam::robot::v1::TransformPoseRequest* request, ::grpc::ServerAsyncResponseWriter< ::viam::robot::v1::TransformPoseResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetStatus() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_GetStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStatus(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::GetStatusRequest* /*request*/, ::viam::robot::v1::GetStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetStatus(::grpc::ServerContext* context, ::viam::robot::v1::GetStatusRequest* request, ::grpc::ServerAsyncResponseWriter< ::viam::robot::v1::GetStatusResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StreamStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_StreamStatus() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_StreamStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamStatus(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::StreamStatusRequest* /*request*/, ::grpc::ServerWriter< ::viam::robot::v1::StreamStatusResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStreamStatus(::grpc::ServerContext* context, ::viam::robot::v1::StreamStatusRequest* request, ::grpc::ServerAsyncWriter< ::viam::robot::v1::StreamStatusResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(10, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StopAll : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_StopAll() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_StopAll() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopAll(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::StopAllRequest* /*request*/, ::viam::robot::v1::StopAllResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStopAll(::grpc::ServerContext* context, ::viam::robot::v1::StopAllRequest* request, ::grpc::ServerAsyncResponseWriter< ::viam::robot::v1::StopAllResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StartSession : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_StartSession() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_StartSession() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartSession(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::StartSessionRequest* /*request*/, ::viam::robot::v1::StartSessionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStartSession(::grpc::ServerContext* context, ::viam::robot::v1::StartSessionRequest* request, ::grpc::ServerAsyncResponseWriter< ::viam::robot::v1::StartSessionResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SendSessionHeartbeat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SendSessionHeartbeat() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_SendSessionHeartbeat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendSessionHeartbeat(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::SendSessionHeartbeatRequest* /*request*/, ::viam::robot::v1::SendSessionHeartbeatResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSendSessionHeartbeat(::grpc::ServerContext* context, ::viam::robot::v1::SendSessionHeartbeatRequest* request, ::grpc::ServerAsyncResponseWriter< ::viam::robot::v1::SendSessionHeartbeatResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_GetOperations<WithAsyncMethod_GetSessions<WithAsyncMethod_ResourceNames<WithAsyncMethod_ResourceRPCSubtypes<WithAsyncMethod_CancelOperation<WithAsyncMethod_BlockForOperation<WithAsyncMethod_DiscoverComponents<WithAsyncMethod_FrameSystemConfig<WithAsyncMethod_TransformPose<WithAsyncMethod_GetStatus<WithAsyncMethod_StreamStatus<WithAsyncMethod_StopAll<WithAsyncMethod_StartSession<WithAsyncMethod_SendSessionHeartbeat<Service > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_GetOperations : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetOperations() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::viam::robot::v1::GetOperationsRequest, ::viam::robot::v1::GetOperationsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::viam::robot::v1::GetOperationsRequest* request, ::viam::robot::v1::GetOperationsResponse* response) { return this->GetOperations(context, request, response); }));}
    void SetMessageAllocatorFor_GetOperations(
        ::grpc::MessageAllocator< ::viam::robot::v1::GetOperationsRequest, ::viam::robot::v1::GetOperationsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::viam::robot::v1::GetOperationsRequest, ::viam::robot::v1::GetOperationsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetOperations() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetOperations(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::GetOperationsRequest* /*request*/, ::viam::robot::v1::GetOperationsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetOperations(
      ::grpc::CallbackServerContext* /*context*/, const ::viam::robot::v1::GetOperationsRequest* /*request*/, ::viam::robot::v1::GetOperationsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetSessions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetSessions() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::viam::robot::v1::GetSessionsRequest, ::viam::robot::v1::GetSessionsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::viam::robot::v1::GetSessionsRequest* request, ::viam::robot::v1::GetSessionsResponse* response) { return this->GetSessions(context, request, response); }));}
    void SetMessageAllocatorFor_GetSessions(
        ::grpc::MessageAllocator< ::viam::robot::v1::GetSessionsRequest, ::viam::robot::v1::GetSessionsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::viam::robot::v1::GetSessionsRequest, ::viam::robot::v1::GetSessionsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetSessions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSessions(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::GetSessionsRequest* /*request*/, ::viam::robot::v1::GetSessionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetSessions(
      ::grpc::CallbackServerContext* /*context*/, const ::viam::robot::v1::GetSessionsRequest* /*request*/, ::viam::robot::v1::GetSessionsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ResourceNames : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ResourceNames() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::viam::robot::v1::ResourceNamesRequest, ::viam::robot::v1::ResourceNamesResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::viam::robot::v1::ResourceNamesRequest* request, ::viam::robot::v1::ResourceNamesResponse* response) { return this->ResourceNames(context, request, response); }));}
    void SetMessageAllocatorFor_ResourceNames(
        ::grpc::MessageAllocator< ::viam::robot::v1::ResourceNamesRequest, ::viam::robot::v1::ResourceNamesResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::viam::robot::v1::ResourceNamesRequest, ::viam::robot::v1::ResourceNamesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ResourceNames() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResourceNames(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::ResourceNamesRequest* /*request*/, ::viam::robot::v1::ResourceNamesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ResourceNames(
      ::grpc::CallbackServerContext* /*context*/, const ::viam::robot::v1::ResourceNamesRequest* /*request*/, ::viam::robot::v1::ResourceNamesResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ResourceRPCSubtypes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ResourceRPCSubtypes() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::viam::robot::v1::ResourceRPCSubtypesRequest, ::viam::robot::v1::ResourceRPCSubtypesResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::viam::robot::v1::ResourceRPCSubtypesRequest* request, ::viam::robot::v1::ResourceRPCSubtypesResponse* response) { return this->ResourceRPCSubtypes(context, request, response); }));}
    void SetMessageAllocatorFor_ResourceRPCSubtypes(
        ::grpc::MessageAllocator< ::viam::robot::v1::ResourceRPCSubtypesRequest, ::viam::robot::v1::ResourceRPCSubtypesResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::viam::robot::v1::ResourceRPCSubtypesRequest, ::viam::robot::v1::ResourceRPCSubtypesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ResourceRPCSubtypes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResourceRPCSubtypes(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::ResourceRPCSubtypesRequest* /*request*/, ::viam::robot::v1::ResourceRPCSubtypesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ResourceRPCSubtypes(
      ::grpc::CallbackServerContext* /*context*/, const ::viam::robot::v1::ResourceRPCSubtypesRequest* /*request*/, ::viam::robot::v1::ResourceRPCSubtypesResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_CancelOperation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_CancelOperation() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::viam::robot::v1::CancelOperationRequest, ::viam::robot::v1::CancelOperationResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::viam::robot::v1::CancelOperationRequest* request, ::viam::robot::v1::CancelOperationResponse* response) { return this->CancelOperation(context, request, response); }));}
    void SetMessageAllocatorFor_CancelOperation(
        ::grpc::MessageAllocator< ::viam::robot::v1::CancelOperationRequest, ::viam::robot::v1::CancelOperationResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::viam::robot::v1::CancelOperationRequest, ::viam::robot::v1::CancelOperationResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_CancelOperation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CancelOperation(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::CancelOperationRequest* /*request*/, ::viam::robot::v1::CancelOperationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CancelOperation(
      ::grpc::CallbackServerContext* /*context*/, const ::viam::robot::v1::CancelOperationRequest* /*request*/, ::viam::robot::v1::CancelOperationResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_BlockForOperation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_BlockForOperation() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::viam::robot::v1::BlockForOperationRequest, ::viam::robot::v1::BlockForOperationResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::viam::robot::v1::BlockForOperationRequest* request, ::viam::robot::v1::BlockForOperationResponse* response) { return this->BlockForOperation(context, request, response); }));}
    void SetMessageAllocatorFor_BlockForOperation(
        ::grpc::MessageAllocator< ::viam::robot::v1::BlockForOperationRequest, ::viam::robot::v1::BlockForOperationResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::viam::robot::v1::BlockForOperationRequest, ::viam::robot::v1::BlockForOperationResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_BlockForOperation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BlockForOperation(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::BlockForOperationRequest* /*request*/, ::viam::robot::v1::BlockForOperationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* BlockForOperation(
      ::grpc::CallbackServerContext* /*context*/, const ::viam::robot::v1::BlockForOperationRequest* /*request*/, ::viam::robot::v1::BlockForOperationResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_DiscoverComponents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_DiscoverComponents() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::viam::robot::v1::DiscoverComponentsRequest, ::viam::robot::v1::DiscoverComponentsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::viam::robot::v1::DiscoverComponentsRequest* request, ::viam::robot::v1::DiscoverComponentsResponse* response) { return this->DiscoverComponents(context, request, response); }));}
    void SetMessageAllocatorFor_DiscoverComponents(
        ::grpc::MessageAllocator< ::viam::robot::v1::DiscoverComponentsRequest, ::viam::robot::v1::DiscoverComponentsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::viam::robot::v1::DiscoverComponentsRequest, ::viam::robot::v1::DiscoverComponentsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_DiscoverComponents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DiscoverComponents(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::DiscoverComponentsRequest* /*request*/, ::viam::robot::v1::DiscoverComponentsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DiscoverComponents(
      ::grpc::CallbackServerContext* /*context*/, const ::viam::robot::v1::DiscoverComponentsRequest* /*request*/, ::viam::robot::v1::DiscoverComponentsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_FrameSystemConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_FrameSystemConfig() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::viam::robot::v1::FrameSystemConfigRequest, ::viam::robot::v1::FrameSystemConfigResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::viam::robot::v1::FrameSystemConfigRequest* request, ::viam::robot::v1::FrameSystemConfigResponse* response) { return this->FrameSystemConfig(context, request, response); }));}
    void SetMessageAllocatorFor_FrameSystemConfig(
        ::grpc::MessageAllocator< ::viam::robot::v1::FrameSystemConfigRequest, ::viam::robot::v1::FrameSystemConfigResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::viam::robot::v1::FrameSystemConfigRequest, ::viam::robot::v1::FrameSystemConfigResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_FrameSystemConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrameSystemConfig(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::FrameSystemConfigRequest* /*request*/, ::viam::robot::v1::FrameSystemConfigResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* FrameSystemConfig(
      ::grpc::CallbackServerContext* /*context*/, const ::viam::robot::v1::FrameSystemConfigRequest* /*request*/, ::viam::robot::v1::FrameSystemConfigResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_TransformPose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_TransformPose() {
      ::grpc::Service::MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::viam::robot::v1::TransformPoseRequest, ::viam::robot::v1::TransformPoseResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::viam::robot::v1::TransformPoseRequest* request, ::viam::robot::v1::TransformPoseResponse* response) { return this->TransformPose(context, request, response); }));}
    void SetMessageAllocatorFor_TransformPose(
        ::grpc::MessageAllocator< ::viam::robot::v1::TransformPoseRequest, ::viam::robot::v1::TransformPoseResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::viam::robot::v1::TransformPoseRequest, ::viam::robot::v1::TransformPoseResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_TransformPose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TransformPose(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::TransformPoseRequest* /*request*/, ::viam::robot::v1::TransformPoseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* TransformPose(
      ::grpc::CallbackServerContext* /*context*/, const ::viam::robot::v1::TransformPoseRequest* /*request*/, ::viam::robot::v1::TransformPoseResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetStatus() {
      ::grpc::Service::MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::viam::robot::v1::GetStatusRequest, ::viam::robot::v1::GetStatusResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::viam::robot::v1::GetStatusRequest* request, ::viam::robot::v1::GetStatusResponse* response) { return this->GetStatus(context, request, response); }));}
    void SetMessageAllocatorFor_GetStatus(
        ::grpc::MessageAllocator< ::viam::robot::v1::GetStatusRequest, ::viam::robot::v1::GetStatusResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::viam::robot::v1::GetStatusRequest, ::viam::robot::v1::GetStatusResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStatus(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::GetStatusRequest* /*request*/, ::viam::robot::v1::GetStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::viam::robot::v1::GetStatusRequest* /*request*/, ::viam::robot::v1::GetStatusResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_StreamStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_StreamStatus() {
      ::grpc::Service::MarkMethodCallback(10,
          new ::grpc::internal::CallbackServerStreamingHandler< ::viam::robot::v1::StreamStatusRequest, ::viam::robot::v1::StreamStatusResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::viam::robot::v1::StreamStatusRequest* request) { return this->StreamStatus(context, request); }));
    }
    ~WithCallbackMethod_StreamStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamStatus(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::StreamStatusRequest* /*request*/, ::grpc::ServerWriter< ::viam::robot::v1::StreamStatusResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::viam::robot::v1::StreamStatusResponse>* StreamStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::viam::robot::v1::StreamStatusRequest* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_StopAll : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_StopAll() {
      ::grpc::Service::MarkMethodCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::viam::robot::v1::StopAllRequest, ::viam::robot::v1::StopAllResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::viam::robot::v1::StopAllRequest* request, ::viam::robot::v1::StopAllResponse* response) { return this->StopAll(context, request, response); }));}
    void SetMessageAllocatorFor_StopAll(
        ::grpc::MessageAllocator< ::viam::robot::v1::StopAllRequest, ::viam::robot::v1::StopAllResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::viam::robot::v1::StopAllRequest, ::viam::robot::v1::StopAllResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_StopAll() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopAll(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::StopAllRequest* /*request*/, ::viam::robot::v1::StopAllResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* StopAll(
      ::grpc::CallbackServerContext* /*context*/, const ::viam::robot::v1::StopAllRequest* /*request*/, ::viam::robot::v1::StopAllResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_StartSession : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_StartSession() {
      ::grpc::Service::MarkMethodCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::viam::robot::v1::StartSessionRequest, ::viam::robot::v1::StartSessionResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::viam::robot::v1::StartSessionRequest* request, ::viam::robot::v1::StartSessionResponse* response) { return this->StartSession(context, request, response); }));}
    void SetMessageAllocatorFor_StartSession(
        ::grpc::MessageAllocator< ::viam::robot::v1::StartSessionRequest, ::viam::robot::v1::StartSessionResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::viam::robot::v1::StartSessionRequest, ::viam::robot::v1::StartSessionResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_StartSession() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartSession(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::StartSessionRequest* /*request*/, ::viam::robot::v1::StartSessionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* StartSession(
      ::grpc::CallbackServerContext* /*context*/, const ::viam::robot::v1::StartSessionRequest* /*request*/, ::viam::robot::v1::StartSessionResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SendSessionHeartbeat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SendSessionHeartbeat() {
      ::grpc::Service::MarkMethodCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::viam::robot::v1::SendSessionHeartbeatRequest, ::viam::robot::v1::SendSessionHeartbeatResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::viam::robot::v1::SendSessionHeartbeatRequest* request, ::viam::robot::v1::SendSessionHeartbeatResponse* response) { return this->SendSessionHeartbeat(context, request, response); }));}
    void SetMessageAllocatorFor_SendSessionHeartbeat(
        ::grpc::MessageAllocator< ::viam::robot::v1::SendSessionHeartbeatRequest, ::viam::robot::v1::SendSessionHeartbeatResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(13);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::viam::robot::v1::SendSessionHeartbeatRequest, ::viam::robot::v1::SendSessionHeartbeatResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SendSessionHeartbeat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendSessionHeartbeat(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::SendSessionHeartbeatRequest* /*request*/, ::viam::robot::v1::SendSessionHeartbeatResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SendSessionHeartbeat(
      ::grpc::CallbackServerContext* /*context*/, const ::viam::robot::v1::SendSessionHeartbeatRequest* /*request*/, ::viam::robot::v1::SendSessionHeartbeatResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_GetOperations<WithCallbackMethod_GetSessions<WithCallbackMethod_ResourceNames<WithCallbackMethod_ResourceRPCSubtypes<WithCallbackMethod_CancelOperation<WithCallbackMethod_BlockForOperation<WithCallbackMethod_DiscoverComponents<WithCallbackMethod_FrameSystemConfig<WithCallbackMethod_TransformPose<WithCallbackMethod_GetStatus<WithCallbackMethod_StreamStatus<WithCallbackMethod_StopAll<WithCallbackMethod_StartSession<WithCallbackMethod_SendSessionHeartbeat<Service > > > > > > > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_GetOperations : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetOperations() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_GetOperations() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetOperations(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::GetOperationsRequest* /*request*/, ::viam::robot::v1::GetOperationsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetSessions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetSessions() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_GetSessions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSessions(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::GetSessionsRequest* /*request*/, ::viam::robot::v1::GetSessionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ResourceNames : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ResourceNames() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_ResourceNames() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResourceNames(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::ResourceNamesRequest* /*request*/, ::viam::robot::v1::ResourceNamesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ResourceRPCSubtypes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ResourceRPCSubtypes() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_ResourceRPCSubtypes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResourceRPCSubtypes(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::ResourceRPCSubtypesRequest* /*request*/, ::viam::robot::v1::ResourceRPCSubtypesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CancelOperation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CancelOperation() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_CancelOperation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CancelOperation(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::CancelOperationRequest* /*request*/, ::viam::robot::v1::CancelOperationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_BlockForOperation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_BlockForOperation() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_BlockForOperation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BlockForOperation(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::BlockForOperationRequest* /*request*/, ::viam::robot::v1::BlockForOperationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DiscoverComponents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DiscoverComponents() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_DiscoverComponents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DiscoverComponents(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::DiscoverComponentsRequest* /*request*/, ::viam::robot::v1::DiscoverComponentsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_FrameSystemConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_FrameSystemConfig() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_FrameSystemConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrameSystemConfig(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::FrameSystemConfigRequest* /*request*/, ::viam::robot::v1::FrameSystemConfigResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_TransformPose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_TransformPose() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_TransformPose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TransformPose(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::TransformPoseRequest* /*request*/, ::viam::robot::v1::TransformPoseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetStatus() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_GetStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStatus(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::GetStatusRequest* /*request*/, ::viam::robot::v1::GetStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StreamStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_StreamStatus() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_StreamStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamStatus(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::StreamStatusRequest* /*request*/, ::grpc::ServerWriter< ::viam::robot::v1::StreamStatusResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StopAll : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_StopAll() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_StopAll() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopAll(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::StopAllRequest* /*request*/, ::viam::robot::v1::StopAllResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StartSession : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_StartSession() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_StartSession() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartSession(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::StartSessionRequest* /*request*/, ::viam::robot::v1::StartSessionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SendSessionHeartbeat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SendSessionHeartbeat() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_SendSessionHeartbeat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendSessionHeartbeat(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::SendSessionHeartbeatRequest* /*request*/, ::viam::robot::v1::SendSessionHeartbeatResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetOperations : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetOperations() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_GetOperations() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetOperations(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::GetOperationsRequest* /*request*/, ::viam::robot::v1::GetOperationsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetOperations(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetSessions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetSessions() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_GetSessions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSessions(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::GetSessionsRequest* /*request*/, ::viam::robot::v1::GetSessionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSessions(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ResourceNames : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ResourceNames() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_ResourceNames() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResourceNames(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::ResourceNamesRequest* /*request*/, ::viam::robot::v1::ResourceNamesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestResourceNames(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ResourceRPCSubtypes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ResourceRPCSubtypes() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_ResourceRPCSubtypes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResourceRPCSubtypes(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::ResourceRPCSubtypesRequest* /*request*/, ::viam::robot::v1::ResourceRPCSubtypesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestResourceRPCSubtypes(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CancelOperation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CancelOperation() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_CancelOperation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CancelOperation(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::CancelOperationRequest* /*request*/, ::viam::robot::v1::CancelOperationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCancelOperation(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_BlockForOperation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_BlockForOperation() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_BlockForOperation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BlockForOperation(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::BlockForOperationRequest* /*request*/, ::viam::robot::v1::BlockForOperationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBlockForOperation(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DiscoverComponents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DiscoverComponents() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_DiscoverComponents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DiscoverComponents(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::DiscoverComponentsRequest* /*request*/, ::viam::robot::v1::DiscoverComponentsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDiscoverComponents(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_FrameSystemConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_FrameSystemConfig() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_FrameSystemConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrameSystemConfig(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::FrameSystemConfigRequest* /*request*/, ::viam::robot::v1::FrameSystemConfigResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFrameSystemConfig(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_TransformPose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_TransformPose() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_TransformPose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TransformPose(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::TransformPoseRequest* /*request*/, ::viam::robot::v1::TransformPoseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTransformPose(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetStatus() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_GetStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStatus(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::GetStatusRequest* /*request*/, ::viam::robot::v1::GetStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetStatus(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StreamStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_StreamStatus() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_StreamStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamStatus(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::StreamStatusRequest* /*request*/, ::grpc::ServerWriter< ::viam::robot::v1::StreamStatusResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStreamStatus(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(10, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StopAll : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_StopAll() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_StopAll() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopAll(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::StopAllRequest* /*request*/, ::viam::robot::v1::StopAllResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStopAll(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StartSession : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_StartSession() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_StartSession() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartSession(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::StartSessionRequest* /*request*/, ::viam::robot::v1::StartSessionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStartSession(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SendSessionHeartbeat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SendSessionHeartbeat() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_SendSessionHeartbeat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendSessionHeartbeat(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::SendSessionHeartbeatRequest* /*request*/, ::viam::robot::v1::SendSessionHeartbeatResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSendSessionHeartbeat(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetOperations : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetOperations() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetOperations(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetOperations() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetOperations(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::GetOperationsRequest* /*request*/, ::viam::robot::v1::GetOperationsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetOperations(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetSessions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetSessions() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetSessions(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetSessions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSessions(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::GetSessionsRequest* /*request*/, ::viam::robot::v1::GetSessionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetSessions(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ResourceNames : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ResourceNames() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ResourceNames(context, request, response); }));
    }
    ~WithRawCallbackMethod_ResourceNames() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResourceNames(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::ResourceNamesRequest* /*request*/, ::viam::robot::v1::ResourceNamesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ResourceNames(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ResourceRPCSubtypes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ResourceRPCSubtypes() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ResourceRPCSubtypes(context, request, response); }));
    }
    ~WithRawCallbackMethod_ResourceRPCSubtypes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResourceRPCSubtypes(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::ResourceRPCSubtypesRequest* /*request*/, ::viam::robot::v1::ResourceRPCSubtypesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ResourceRPCSubtypes(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_CancelOperation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_CancelOperation() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CancelOperation(context, request, response); }));
    }
    ~WithRawCallbackMethod_CancelOperation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CancelOperation(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::CancelOperationRequest* /*request*/, ::viam::robot::v1::CancelOperationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CancelOperation(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_BlockForOperation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_BlockForOperation() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->BlockForOperation(context, request, response); }));
    }
    ~WithRawCallbackMethod_BlockForOperation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BlockForOperation(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::BlockForOperationRequest* /*request*/, ::viam::robot::v1::BlockForOperationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* BlockForOperation(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_DiscoverComponents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_DiscoverComponents() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DiscoverComponents(context, request, response); }));
    }
    ~WithRawCallbackMethod_DiscoverComponents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DiscoverComponents(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::DiscoverComponentsRequest* /*request*/, ::viam::robot::v1::DiscoverComponentsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DiscoverComponents(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_FrameSystemConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_FrameSystemConfig() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->FrameSystemConfig(context, request, response); }));
    }
    ~WithRawCallbackMethod_FrameSystemConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FrameSystemConfig(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::FrameSystemConfigRequest* /*request*/, ::viam::robot::v1::FrameSystemConfigResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* FrameSystemConfig(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_TransformPose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_TransformPose() {
      ::grpc::Service::MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->TransformPose(context, request, response); }));
    }
    ~WithRawCallbackMethod_TransformPose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TransformPose(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::TransformPoseRequest* /*request*/, ::viam::robot::v1::TransformPoseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* TransformPose(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetStatus() {
      ::grpc::Service::MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetStatus(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStatus(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::GetStatusRequest* /*request*/, ::viam::robot::v1::GetStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_StreamStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_StreamStatus() {
      ::grpc::Service::MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->StreamStatus(context, request); }));
    }
    ~WithRawCallbackMethod_StreamStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamStatus(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::StreamStatusRequest* /*request*/, ::grpc::ServerWriter< ::viam::robot::v1::StreamStatusResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* StreamStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_StopAll : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_StopAll() {
      ::grpc::Service::MarkMethodRawCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->StopAll(context, request, response); }));
    }
    ~WithRawCallbackMethod_StopAll() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopAll(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::StopAllRequest* /*request*/, ::viam::robot::v1::StopAllResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* StopAll(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_StartSession : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_StartSession() {
      ::grpc::Service::MarkMethodRawCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->StartSession(context, request, response); }));
    }
    ~WithRawCallbackMethod_StartSession() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartSession(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::StartSessionRequest* /*request*/, ::viam::robot::v1::StartSessionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* StartSession(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SendSessionHeartbeat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SendSessionHeartbeat() {
      ::grpc::Service::MarkMethodRawCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SendSessionHeartbeat(context, request, response); }));
    }
    ~WithRawCallbackMethod_SendSessionHeartbeat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendSessionHeartbeat(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::SendSessionHeartbeatRequest* /*request*/, ::viam::robot::v1::SendSessionHeartbeatResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SendSessionHeartbeat(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetOperations : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetOperations() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::viam::robot::v1::GetOperationsRequest, ::viam::robot::v1::GetOperationsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::viam::robot::v1::GetOperationsRequest, ::viam::robot::v1::GetOperationsResponse>* streamer) {
                       return this->StreamedGetOperations(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetOperations() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetOperations(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::GetOperationsRequest* /*request*/, ::viam::robot::v1::GetOperationsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetOperations(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::viam::robot::v1::GetOperationsRequest,::viam::robot::v1::GetOperationsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetSessions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetSessions() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::viam::robot::v1::GetSessionsRequest, ::viam::robot::v1::GetSessionsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::viam::robot::v1::GetSessionsRequest, ::viam::robot::v1::GetSessionsResponse>* streamer) {
                       return this->StreamedGetSessions(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetSessions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetSessions(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::GetSessionsRequest* /*request*/, ::viam::robot::v1::GetSessionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetSessions(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::viam::robot::v1::GetSessionsRequest,::viam::robot::v1::GetSessionsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ResourceNames : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ResourceNames() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::viam::robot::v1::ResourceNamesRequest, ::viam::robot::v1::ResourceNamesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::viam::robot::v1::ResourceNamesRequest, ::viam::robot::v1::ResourceNamesResponse>* streamer) {
                       return this->StreamedResourceNames(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ResourceNames() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ResourceNames(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::ResourceNamesRequest* /*request*/, ::viam::robot::v1::ResourceNamesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedResourceNames(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::viam::robot::v1::ResourceNamesRequest,::viam::robot::v1::ResourceNamesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ResourceRPCSubtypes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ResourceRPCSubtypes() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::viam::robot::v1::ResourceRPCSubtypesRequest, ::viam::robot::v1::ResourceRPCSubtypesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::viam::robot::v1::ResourceRPCSubtypesRequest, ::viam::robot::v1::ResourceRPCSubtypesResponse>* streamer) {
                       return this->StreamedResourceRPCSubtypes(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ResourceRPCSubtypes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ResourceRPCSubtypes(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::ResourceRPCSubtypesRequest* /*request*/, ::viam::robot::v1::ResourceRPCSubtypesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedResourceRPCSubtypes(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::viam::robot::v1::ResourceRPCSubtypesRequest,::viam::robot::v1::ResourceRPCSubtypesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CancelOperation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CancelOperation() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::viam::robot::v1::CancelOperationRequest, ::viam::robot::v1::CancelOperationResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::viam::robot::v1::CancelOperationRequest, ::viam::robot::v1::CancelOperationResponse>* streamer) {
                       return this->StreamedCancelOperation(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CancelOperation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CancelOperation(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::CancelOperationRequest* /*request*/, ::viam::robot::v1::CancelOperationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCancelOperation(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::viam::robot::v1::CancelOperationRequest,::viam::robot::v1::CancelOperationResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_BlockForOperation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_BlockForOperation() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::viam::robot::v1::BlockForOperationRequest, ::viam::robot::v1::BlockForOperationResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::viam::robot::v1::BlockForOperationRequest, ::viam::robot::v1::BlockForOperationResponse>* streamer) {
                       return this->StreamedBlockForOperation(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_BlockForOperation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status BlockForOperation(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::BlockForOperationRequest* /*request*/, ::viam::robot::v1::BlockForOperationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedBlockForOperation(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::viam::robot::v1::BlockForOperationRequest,::viam::robot::v1::BlockForOperationResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DiscoverComponents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DiscoverComponents() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::viam::robot::v1::DiscoverComponentsRequest, ::viam::robot::v1::DiscoverComponentsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::viam::robot::v1::DiscoverComponentsRequest, ::viam::robot::v1::DiscoverComponentsResponse>* streamer) {
                       return this->StreamedDiscoverComponents(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DiscoverComponents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DiscoverComponents(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::DiscoverComponentsRequest* /*request*/, ::viam::robot::v1::DiscoverComponentsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDiscoverComponents(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::viam::robot::v1::DiscoverComponentsRequest,::viam::robot::v1::DiscoverComponentsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_FrameSystemConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_FrameSystemConfig() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::viam::robot::v1::FrameSystemConfigRequest, ::viam::robot::v1::FrameSystemConfigResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::viam::robot::v1::FrameSystemConfigRequest, ::viam::robot::v1::FrameSystemConfigResponse>* streamer) {
                       return this->StreamedFrameSystemConfig(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_FrameSystemConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status FrameSystemConfig(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::FrameSystemConfigRequest* /*request*/, ::viam::robot::v1::FrameSystemConfigResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedFrameSystemConfig(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::viam::robot::v1::FrameSystemConfigRequest,::viam::robot::v1::FrameSystemConfigResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_TransformPose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_TransformPose() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::viam::robot::v1::TransformPoseRequest, ::viam::robot::v1::TransformPoseResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::viam::robot::v1::TransformPoseRequest, ::viam::robot::v1::TransformPoseResponse>* streamer) {
                       return this->StreamedTransformPose(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_TransformPose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status TransformPose(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::TransformPoseRequest* /*request*/, ::viam::robot::v1::TransformPoseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedTransformPose(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::viam::robot::v1::TransformPoseRequest,::viam::robot::v1::TransformPoseResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetStatus() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::viam::robot::v1::GetStatusRequest, ::viam::robot::v1::GetStatusResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::viam::robot::v1::GetStatusRequest, ::viam::robot::v1::GetStatusResponse>* streamer) {
                       return this->StreamedGetStatus(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetStatus(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::GetStatusRequest* /*request*/, ::viam::robot::v1::GetStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetStatus(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::viam::robot::v1::GetStatusRequest,::viam::robot::v1::GetStatusResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StopAll : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_StopAll() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::viam::robot::v1::StopAllRequest, ::viam::robot::v1::StopAllResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::viam::robot::v1::StopAllRequest, ::viam::robot::v1::StopAllResponse>* streamer) {
                       return this->StreamedStopAll(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_StopAll() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StopAll(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::StopAllRequest* /*request*/, ::viam::robot::v1::StopAllResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStopAll(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::viam::robot::v1::StopAllRequest,::viam::robot::v1::StopAllResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StartSession : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_StartSession() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler<
          ::viam::robot::v1::StartSessionRequest, ::viam::robot::v1::StartSessionResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::viam::robot::v1::StartSessionRequest, ::viam::robot::v1::StartSessionResponse>* streamer) {
                       return this->StreamedStartSession(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_StartSession() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StartSession(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::StartSessionRequest* /*request*/, ::viam::robot::v1::StartSessionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStartSession(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::viam::robot::v1::StartSessionRequest,::viam::robot::v1::StartSessionResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SendSessionHeartbeat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SendSessionHeartbeat() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler<
          ::viam::robot::v1::SendSessionHeartbeatRequest, ::viam::robot::v1::SendSessionHeartbeatResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::viam::robot::v1::SendSessionHeartbeatRequest, ::viam::robot::v1::SendSessionHeartbeatResponse>* streamer) {
                       return this->StreamedSendSessionHeartbeat(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SendSessionHeartbeat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SendSessionHeartbeat(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::SendSessionHeartbeatRequest* /*request*/, ::viam::robot::v1::SendSessionHeartbeatResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSendSessionHeartbeat(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::viam::robot::v1::SendSessionHeartbeatRequest,::viam::robot::v1::SendSessionHeartbeatResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_GetOperations<WithStreamedUnaryMethod_GetSessions<WithStreamedUnaryMethod_ResourceNames<WithStreamedUnaryMethod_ResourceRPCSubtypes<WithStreamedUnaryMethod_CancelOperation<WithStreamedUnaryMethod_BlockForOperation<WithStreamedUnaryMethod_DiscoverComponents<WithStreamedUnaryMethod_FrameSystemConfig<WithStreamedUnaryMethod_TransformPose<WithStreamedUnaryMethod_GetStatus<WithStreamedUnaryMethod_StopAll<WithStreamedUnaryMethod_StartSession<WithStreamedUnaryMethod_SendSessionHeartbeat<Service > > > > > > > > > > > > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_StreamStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_StreamStatus() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::viam::robot::v1::StreamStatusRequest, ::viam::robot::v1::StreamStatusResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::viam::robot::v1::StreamStatusRequest, ::viam::robot::v1::StreamStatusResponse>* streamer) {
                       return this->StreamedStreamStatus(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_StreamStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StreamStatus(::grpc::ServerContext* /*context*/, const ::viam::robot::v1::StreamStatusRequest* /*request*/, ::grpc::ServerWriter< ::viam::robot::v1::StreamStatusResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedStreamStatus(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::viam::robot::v1::StreamStatusRequest,::viam::robot::v1::StreamStatusResponse>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_StreamStatus<Service > SplitStreamedService;
  typedef WithStreamedUnaryMethod_GetOperations<WithStreamedUnaryMethod_GetSessions<WithStreamedUnaryMethod_ResourceNames<WithStreamedUnaryMethod_ResourceRPCSubtypes<WithStreamedUnaryMethod_CancelOperation<WithStreamedUnaryMethod_BlockForOperation<WithStreamedUnaryMethod_DiscoverComponents<WithStreamedUnaryMethod_FrameSystemConfig<WithStreamedUnaryMethod_TransformPose<WithStreamedUnaryMethod_GetStatus<WithSplitStreamingMethod_StreamStatus<WithStreamedUnaryMethod_StopAll<WithStreamedUnaryMethod_StartSession<WithStreamedUnaryMethod_SendSessionHeartbeat<Service > > > > > > > > > > > > > > StreamedService;
};

}  // namespace v1
}  // namespace robot
}  // namespace viam


#endif  // GRPC_robot_2fv1_2frobot_2eproto__INCLUDED
